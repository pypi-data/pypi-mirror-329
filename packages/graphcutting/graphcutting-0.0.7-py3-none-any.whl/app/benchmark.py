# Example of user code doing large-scale experimentation


def BENCHMARK(num_random_seeds = 5, nodes=[10, 20, 30], neighs=[2], parts=[2]):
    """
    The user can compare methods with different random seeds and graph topology
    `num_random_seeds` number of random seeds to produce an average score
    `nodes` the number of nodes generated by the random graph generation
    `neighs` the average number of edges (or "neighbors") connected to a node
    print the result and return nothing
    Example of print:
    #nodes: 10 #neigh: 2 #parts: 2 id: 0 strat: parallel_step_wise score: 331 time: 0.121
    #nodes: 10 #neigh: 2 #parts: 2 id: 1 strat: evol_gen20_pop1000_mut0.5 score: 309 time: 0.568
    #nodes: 10 #neigh: 2 #parts: 2 id: 2 strat: evol_gen20_pop1000_mut0.1 score: 311 time: 0.547
    [...]
    all lines is the average over `num_random_seeds` different random seeds.
    """

    import random
    import os
    import warnings
    warnings.simplefilter("ignore")
    os.environ["PYTHONWARNINGS"] = "ignore"  # Also affect subprocesses

    from graphcutting.EvolutionPart import EvolutionPart
    from graphcutting.MetisPart import MetisPart
    from graphcutting.StepWisePart import StepWisePart
    from graphcutting.ZoltanPart import ZoltanPart
    from graphcutting.Node2VecPart import Node2VecPart
    from graphcutting.GirvanNewmanPart import GirvanNewmanPart
    from graphcutting.LouvainPart import LouvainPart
    from graphcutting.SpectralPart import SpectralPart

    # Hide warnings
    import logging
    logging.getLogger("node2vec").setLevel(logging.WARNING)
    logging.getLogger("stellargraph").setLevel(logging.WARNING)

    # Utilities for benchmark
    from graphcutting.util import evaluate_partition, generate_graph, from_networkx_to_cg
    from graphcutting.util import plot_graph


    s0=StepWisePart(max_neigh_per_step=200, max_steps=100)
    s1=EvolutionPart(init_mutation_rate=0.5)
    s1b=EvolutionPart(init_mutation_rate=0.1)
    s2=MetisPart()
    s3=ZoltanPart("PHG")
    s4=ZoltanPart("SCOTCH")
    s5=ZoltanPart("PARMETIS")
    s6=Node2VecPart()
    s7=GirvanNewmanPart()
    s8=LouvainPart()
    s9=SpectralPart()

    methods=[s0, s1, s1b, s2, s3, s4, s5, s6, s7, s8, s9] # all my strategies


    import time

    exps=[]
    for NE in neighs:
        for NP in parts:
            for NO in nodes:
                for s in methods:
                    exps.append((NE, NP, NO, num_random_seeds, s))

    from collections import defaultdict
    res=defaultdict(lambda : [])
    for i in range(len(exps)):
        NE, NP, NO, NX, s = exps[i]
        scores=0.
        duration=0.

        for expid in range(NX):

            random.seed(expid)
            G = generate_graph(NO, NE)
            cg=from_networkx_to_cg(G)

            t=time.time()
            try:
                part=s.part(*cg ,   min(NP,len(cg[0]))  )
            except:
                part=[0]*len(cg[0]) #default

            duration+=time.time()-t
            scores+=evaluate_partition(*cg, part)

        mean_score=round(scores/NX)
        res[s.get_name()].append(mean_score)
        print("#nodes:", NO, "#neigh:", NE, "#parts:", NP, "id:", i, "strat:", s.get_name(),"score:", mean_score, "time:", round(duration/NX,3))

if __name__=="__main__":
    BENCHMARK()
