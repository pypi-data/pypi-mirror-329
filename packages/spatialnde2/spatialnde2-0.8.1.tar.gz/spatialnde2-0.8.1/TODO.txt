    
 * Should modify opencl cachemanager to use a thread pool for cleaning up
   buffers rather than recreating threads each time, as thread creation
   is pretty heavy-weight on Windows

 *** Document semantics for array change notification, definition of changed rectangles, etc. See notifications in x3d.hpp that are probably extraneous.
   Basically upon allocation the region is marked as "pending modification". Then any explicit modification (such as opencl write with dirty marking or
   explicit marking as modification clears the "pending modification" mark. When the array is marked as ready, any remaining "pending modifications"
   get turned into real notifications, invalidating any currently cached areas.
   Note that recording_storage_simple doesn't do any of this, and presumes if you cache something on a GPU and then write to it with the CPU, you
   will explicitly mark the region as CPU modified. 
 * Need to implement on-demand viewing/access methods a'la ProcExpr/ProcRGBA, high-level API that uses them.
 * Need to implement file i/o as well as socket/shared memory linkage to a remote recording database
 * Need to implement Python math functions. 
 * Need to add numpy dtypes for geometry_types to end of spatialnde2.i


 * Need to clean up data type architecture to properly use plug-ins and
 make new data types addable at run time
 * Need run-time explorable inheritance graph for recordings. 
 Equivalently:
   * Fixup the typemaps so as to allow run-time addition of additional types
   * Include an inheritance tree so we can follow the tree to find a renderable
     class from a custom class that doesn't provide a renderer. 




 * In recmath_compute_resource.cpp make the exception handler for math
   functions return an empty recording rather than causing a hang

 * *** Does the graphics_storage need to trigger mark_as_invalid on non-GPU-generated sub-arrays when the recording is
  marked as ready??? Probably in case the array is already GPU-cached, the openclcachemanager may need to know that the
  relevent region is not valid on the GPU (or alternatively make sure that freeing an array previously present in the same
  location would have marked the relevant region as not valid on the GPU and than unallocated regions are never considered valid)

 * Consider the various scenarios relating to the transaction lock and dataguzzler-python
   module locks. One possibility is that the dataguzzler-python module could choose to have
   its module lock precede the transaction lock rather than vice-versa.   
 * Alternatively, Implement module lock dropping on StartTransaction()/EndTransaction()

 * rec_display: Entire tree of display_info, channels, axes, units should be snapshotted and
    a copy rather than original passed alongside the display_requirements to the rendering chain.
    Then the rendering chain should queue up any changes so the compositor can issue them
    in the GUI thread. This will mean the rec_display structures no longer have to be thread
    safe. rec_display values (such as width, height, ColorIdx etc.) no longer need to be snapshotted
    in the compositor. Also provides a path for updates generated by on-demand channels and
    provides an architecture that can be easily ported over to (say) javascript for a web-based
    renderer.
    
 * compositor/renderer example: Need to implement locking of any data arrays marked with
   requires_locking_xxxx

 * Consider reducing follower arrays so that math functions determining vertex arrays, normals,  etc. have to allocate their own. This will remove
   conflicts in case of different ondemand functions in different rss contexts calculating the same thing.
   (has already been partly done)
 
 * Intelligent math function dispatch: Figuring out how many threads to delegate to a particular parallel algorithm

 * Synchronization of waveform database between multiple processes and/or multiple computers.
 * Improved bounding box library (bounding_hyperboxes.hpp)
 * C API wrapper for better ABI compatibility
 
 * Expression parser for defining math functions and/or coordinate transform operations. 

 * Need to implement scalar and waveform rendering modes in display_requirements.cpp

 * Implement Template for Cython capture of a SWIG shared pointer. See Dataguzzler-Python modules.rst for relevant code. Type safety could be achieved by making snde_rawaccessible extend with a method that returns typeid(T)::name() and then the template can check for a match. 
