#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# (c) Copyright 2025 Sensirion AG, Switzerland
#
#     THIS FILE IS AUTOMATICALLY GENERATED!
#
# Generator:     sensirion-driver-generator 1.1.2
# Product:       sfm3304
# Model-Version: 1.0.0
#
"""
The transfer classes specify the data that is transferred between host and sensor. The generated transfer classes
are used by the driver class and not intended for direct use.
"""

from enum import Enum
from sensirion_driver_adapters.transfer import Transfer
from sensirion_driver_adapters.rx_tx_data import TxData, RxData
from sensirion_driver_support_types.bitfield import BitField, BitfieldContainer


class ErrorCodeT(Enum):
    I2C_ERROR = 0
    TIMEOUT = 1

    def __int__(self):
        return self.value


class FilterOptions(Enum):
    T63_1MS = 33601
    T63_3MS = 50961
    T63_5MS = 56105
    T63_10MS = 60527

    def __int__(self):
        return self.value


class StatusWordT(BitfieldContainer):
    nr_of_averages = BitField(offset=0, width=9)
    command_argument_reception = BitField(offset=9, width=1)
    avg_mode_flag = BitField(offset=10, width=1)
    exp_smoothing_flag = BitField(offset=11, width=1)
    command_id = BitField(offset=12, width=4)


class FlowUnitT(BitfieldContainer):
    prefix = BitField(offset=0, width=4)
    time_base = BitField(offset=4, width=4)
    unit = BitField(offset=8, width=5)


class StartContinuousMeasurement(Transfer):
    """
    The sensor starts measuring both flow and temperature and provides a status word. All three measurement results can
    be read out through one single I2C read when the continuous measurement is running.
    This command uses the default low pass filter settin with a T63 of 3ms. To configure different low pass filter, use
    the specific method.
    """

    CMD_ID = 0x3603

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.004, slave_address=None, ignore_ack=False)


class StartContinuousMeasurementWithFilter(Transfer):
    """
    The sensor starts measuring both flow and temperature and provides a status word. All three measurement results can
    be read out through one single I2C read when the continuous measurement is running.
    """

    CMD_ID = 0x3603

    def __init__(self, a_filter):
        self._a_filter = a_filter

    def pack(self):
        return self.tx_data.pack([self._a_filter])

    tx = TxData(CMD_ID, '>HH', device_busy_delay=0.004, slave_address=None, ignore_ack=False)


class ReadMeasurementDataRaw(Transfer):
    """
    After a start continuous measurement command, the
    measurement results can be read out continuously with this command.
    The temperature and the consecutive bytes do not need to
    be read out (every time). The read sequence can be aborted
    by a NACK and a STOP condition.
    """

    def pack(self):
        return None

    rx = RxData('>hhH')


class ReadMeasurementFlowRaw(Transfer):
    """Read out only flow measurement from the sensor."""

    def pack(self):
        return None

    rx = RxData('>h')


class StopContinuousMeasurement(Transfer):
    """
    This command stops the continuous measurement and puts
    the sensor in idle mode. After it receives the stop command,
    the sensor needs up to 0.5ms to power down the heater, enter
    idle mode and be receptive for a new command.
    """

    CMD_ID = 0x3ff9

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H')


class ConfigureAveraging(Transfer):
    """
    This command configures the sensor’s averaging mode:
      - N=0 (default): average-until-read mode
      - 1≤N≤128: fixed-N averaging mode. N is the number of internal
        measurements that are averaged for one returned
        measurement value (i.e. the average over N flow samples,
        where N = CmdArgument, c.f. Sec. 3).

    The configured averaging mode will be used for flow measurements
    until a reset or re-execution of this command is performed. After a
    reset, averaging is set to fixed-N averaging mode with N = 2.
    The highest averaging number allowed is 128. If a higher number is
    used in the command argument, it will be overruled by the maximal
    value of 128 samples to average.
    If no averaging is desired, set N to 1.
    """

    CMD_ID = 0x366a

    def __init__(self, average_window):
        self._average_window = average_window

    def pack(self):
        return self.tx_data.pack([self._average_window])

    tx = TxData(CMD_ID, '>HH')


class ReadScaleOffsetUnit(Transfer):
    """
    This command provides the scale factor and offset to convert flow readings into physical units. The scale factor
    and offset are specific to the calibrated gas and its corresponding lookup table used for the
    flow measurement. Therefore, the gas needs to be specified in the command argument by the command code
    of the corresponding start continuous measurement.
    """

    CMD_ID = 0x3661

    def __init__(self, command_code):
        self._command_code = command_code

    def pack(self):
        return self.tx_data.pack([self._command_code])

    tx = TxData(CMD_ID, '>HH')
    rx = RxData('>hhH')


class EnterSleep(Transfer):
    """
    In sleep mode the sensor uses a minimum amount of power. The mode can only be entered from idle mode, i.e. when the
    sensor is not performing measurements.
    This mode is particularly useful for battery operated devices. To minimize the current in this mode, the complexity of the sleep
    mode circuit has been reduced as much as possible, which is mainly reflected by the way the sensor exits the sleep mode. In
    sleep mode the sensor cannot be soft reset.
    """

    CMD_ID = 0x3677

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H')


class ExitSleep(Transfer):
    """
    The sensor exits the sleep mode and enters the idle mode when
    it receives the valid I2C address and a write bit (‘0’).
    Note that the I2C address is not acknowledged. It is necessary to
    poll the sensor to see whether the sensor has received the
    address and has woken up. This should take typically 16ms.
    """

    CMD_ID = 0x0

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>B', device_busy_delay=0.002, slave_address=None, ignore_ack=True)


class ReadProductIdentifier(Transfer):
    """
    This command allows to read product identifier and the serial number.
    The command can only be executed from the idle mode, i.e. when the sensor is not performing measurements.
    """

    CMD_ID = 0xe102

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H')
    rx = RxData(descriptor='>I8B', convert_to_int=True)
