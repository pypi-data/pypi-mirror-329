#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# (c) Copyright 2025 Sensirion AG, Switzerland
#
#     THIS FILE IS AUTOMATICALLY GENERATED!
#
# Generator:     sensirion-driver-generator 1.1.2
# Product:       sfm3304
# Model-Version: 1.0.0
#
"""
The class Sfm3304DeviceBase implements the low level interface of the sensor.
The class Sfm3304Device extends the Sfm3304DeviceBase. It provides additional functions to ease the use of the
sensor.
"""

from sensirion_driver_adapters.transfer import execute_transfer
from sensirion_driver_support_types.mixin_access import MixinAccess
from sensirion_i2c_sfm3304.commands import (ConfigureAveraging, EnterSleep, ExitSleep, FlowUnitT,
                                            ReadMeasurementDataRaw, ReadMeasurementFlowRaw, ReadProductIdentifier,
                                            ReadScaleOffsetUnit, StartContinuousMeasurement,
                                            StartContinuousMeasurementWithFilter, StatusWordT,
                                            StopContinuousMeasurement)

from sensirion_i2c_sfm3304.result_types import (SignalFlow, SignalTemperature)


class Sfm3304DeviceBase:
    """Low level API implementation of SFM3304"""

    def __init__(self, channel):
        self._channel = channel

    @property
    def channel(self):
        return self._channel

    def start_continuous_measurement(self):
        """
        The sensor starts measuring both flow and temperature and provides a status word. All three measurement results can
        be read out through one single I2C read when the continuous measurement is running.
        This command uses the default low pass filter settin with a T63 of 3ms. To configure different low pass filter, use
        the specific method.

        .. note::
            The first measurement result will be available after 4ms. Small accuracy deviations (few % of reading) can occur during
            the first 50ms (including the 4ms)
        """
        transfer = StartContinuousMeasurement()
        return execute_transfer(self._channel, transfer)

    def start_continuous_measurement_with_filter(self, a_filter):
        """
        The sensor starts measuring both flow and temperature and provides a status word. All three measurement results can
        be read out through one single I2C read when the continuous measurement is running.

        :param a_filter:
            Filter setting for low pass filter on flow measurement. You can configure a time constant T63 by passing an integer from
            the following options: 1ms -> 33601, 3ms (default) -> 50961, 5ms -> 56105, 10ms -> 60527

        .. note::
            The first measurement result will be available after 4ms. Small accuracy deviations (few % of reading) can occur during
            the first 50ms (including the 4ms).

        :Example:
            .. code-block:: python

                sensor.start_continuous_measurement_with_filter(50961)

        """
        transfer = StartContinuousMeasurementWithFilter(a_filter)
        return execute_transfer(self._channel, transfer)

    def read_measurement_data_raw(self):
        """
        After a start continuous measurement command, the
        measurement results can be read out continuously with this command.
        The temperature and the consecutive bytes do not need to
        be read out (every time). The read sequence can be aborted
        by a NACK and a STOP condition.

        :return flow:
            Calibrated flow signal. Convert to gas flow in slm by (value - offset) / scale
        :return temperature:
            Calibrated temperature. Convert to degrees celsius by value / 200.
        :return status_word:
            Gives information about the measurement command that is currently running.
            A detailed description can be found in the data sheet.

        .. note::
            The first measurement result will be available after 4ms. Small accuracy deviations (few % of reading) can occur during
            the first 50ms (including the 4ms)
        """
        transfer = ReadMeasurementDataRaw()
        res_0, res_1, res_2 = execute_transfer(self._channel, transfer)
        return res_0, res_1, StatusWordT(res_2)

    def read_measurement_flow_raw(self):
        """
        Read out only flow measurement from the sensor.

        :return flow:
            Calibrated flow signal read from the sensor.
        """
        transfer = ReadMeasurementFlowRaw()
        return execute_transfer(self._channel, transfer)[0]

    def stop_continuous_measurement(self):
        """
        This command stops the continuous measurement and puts
        the sensor in idle mode. After it receives the stop command,
        the sensor needs up to 0.5ms to power down the heater, enter
        idle mode and be receptive for a new command.
        """
        transfer = StopContinuousMeasurement()
        return execute_transfer(self._channel, transfer)

    def configure_averaging(self, average_window):
        """
        This command configures the sensor’s averaging mode:
          - N=0 (default): average-until-read mode
          - 1≤N≤128: fixed-N averaging mode. N is the number of internal
            measurements that are averaged for one returned
            measurement value (i.e. the average over N flow samples,
            where N = CmdArgument, c.f. Sec. 3).

        The configured averaging mode will be used for flow measurements
        until a reset or re-execution of this command is performed. After a
        reset, averaging is set to fixed-N averaging mode with N = 2.
        The highest averaging number allowed is 128. If a higher number is
        used in the command argument, it will be overruled by the maximal
        value of 128 samples to average.
        If no averaging is desired, set N to 1.

        :param average_window:
            Average window configuration value.

        :Example:
            .. code-block:: python

                sensor.configure_averaging(2)

        """
        transfer = ConfigureAveraging(average_window)
        return execute_transfer(self._channel, transfer)

    def read_scale_offset_unit(self, command_code):
        """
        This command provides the scale factor and offset to convert flow readings into physical units. The scale factor
        and offset are specific to the calibrated gas and its corresponding lookup table used for the
        flow measurement. Therefore, the gas needs to be specified in the command argument by the command code
        of the corresponding start continuous measurement.

        :param command_code:
            For the SFM3304-xxx-D the only calibrated gas is air, the command argument is 0x3603.

        :return flow_scale_factor:
            Scale factor used by the sensor.
        :return flow_offset:
            Offset used by the sensor.
        :return flow_unit:
            Applicable flow unit.

        .. note::
            For the SFM3304-xxx-D, the flow unit is a fixed value 0x0148 and corresponds to slm: standard liter per minute at 20°C and
            1013.25 hPa pressure
        """
        transfer = ReadScaleOffsetUnit(command_code)
        res_0, res_1, res_2 = execute_transfer(self._channel, transfer)
        return res_0, res_1, FlowUnitT(res_2)

    def enter_sleep(self):
        """
        In sleep mode the sensor uses a minimum amount of power. The mode can only be entered from idle mode, i.e. when the
        sensor is not performing measurements.
        This mode is particularly useful for battery operated devices. To minimize the current in this mode, the complexity of the sleep
        mode circuit has been reduced as much as possible, which is mainly reflected by the way the sensor exits the sleep mode. In
        sleep mode the sensor cannot be soft reset.
        """
        transfer = EnterSleep()
        return execute_transfer(self._channel, transfer)

    def exit_sleep(self):
        """
        The sensor exits the sleep mode and enters the idle mode when
        it receives the valid I2C address and a write bit (‘0’).
        Note that the I2C address is not acknowledged. It is necessary to
        poll the sensor to see whether the sensor has received the
        address and has woken up. This should take typically 16ms.
        """
        transfer = ExitSleep()
        return execute_transfer(self._channel, transfer)

    def read_product_identifier(self):
        """
        This command allows to read product identifier and the serial number.
        The command can only be executed from the idle mode, i.e. when the sensor is not performing measurements.

        :return product_identifier:
            32-bit unique product and revision number. The number is listed in Table 13 below.
            Note that the last 8 bits are the revision number.
        :return serial_number:
            64-bit unique serial number in the format of an unsigned long integer.
            The serial number can be converted from binary into decimal, whereby in decimal it has the following format:
            yywwxxxxxx, where: yy: last 2 digits of calibration year, ww:
            calibration week, xxxxxx: unique 6-digit sequential number within the calibration week.
        """
        transfer = ReadProductIdentifier()
        return execute_transfer(self._channel, transfer)


class Sfm3304Device(Sfm3304DeviceBase):
    """Driver class implementation of SFM3304"""

    #: Access to base class
    sfm3304 = MixinAccess()

    def __init__(self, channel):
        super().__init__(channel)

    def read_measurement_data(self):
        """
        Read measurement data and apply appropriate scaling.

        :return a_flow:
            This signal represents the measured flow in slm (at 20°C and 1013.25hPa).
            It is scaled with the corresponding scaling factor and offset.
        :return a_temperature:
            Measured temperature in degrees Celsius. The raw value is scaled appropriately.
        :return a_status_word:

        """
        (raw_flow, raw_temp, status
         ) = self.read_measurement_data_raw()
        return (SignalFlow(raw_flow), SignalTemperature(raw_temp), status)

    def read_measurement_flow(self):
        """
        Read only the flow measurement data.

        :return a_flow:
            This signal represents the measured flow in slm (at 20°C and 1013.25hPa).
            It is scaled with the corresponding scaling factor and offset.
        """
        raw_flow = self.read_measurement_flow_raw()
        return SignalFlow(raw_flow)
