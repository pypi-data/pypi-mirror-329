Index: examples/booksToScrape/python/booksToScrape.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># autogenerated by ssc-gen DO NOT_EDIT\n\"\"\"Dummy parser config for http://books.toscrape.com/\"\"\"\n\nfrom __future__ import annotations\nimport re\nfrom typing import List, Dict, TypedDict, Union\nfrom contextlib import suppress\nimport sys\n\nif sys.version_info >= (3, 10):\n    from types import NoneType\nelse:\n    NoneType = type(None)\n\nfrom parsel import Selector, SelectorList\n\nT_Urls = List[str]\nT_UrlsMap = Dict[str, str]\nT_Books = TypedDict(\n    \"T_Books\",\n    {\n        \"name\": str,\n        \"image_url\": str,\n        \"url\": str,\n        \"rating\": str,\n        \"price\": int,\n    },\n)\nT_CataloguePage = TypedDict(\n    \"T_CataloguePage\",\n    {\n        \"title\": str,\n        \"urls\": T_Urls,\n        \"urls_map\": T_UrlsMap,\n        \"books\": List[T_Books],\n    },\n)\n\n\nclass Urls:\n    \"\"\"fetch add patches and urls from <a> tag\n\n    [\n        \"String\",\n        \"...\"\n    ]\"\"\"\n\n    def __init__(self, document: Union[str, SelectorList, Selector]) -> None:\n        self._doc = (\n            Selector(document) if isinstance(document, str) else document\n        )\n\n    def _split_doc(self, value: Selector) -> SelectorList:\n        value1 = value.css(\"a\")\n        return value1\n\n    def _parse_item(self, value: Selector) -> str:\n        value1 = value.attrib[\"href\"]\n        return value1\n\n    def parse(self) -> T_Urls:\n        return [self._parse_item(e) for e in self._split_doc(self._doc)]\n\n\nclass UrlsMap:\n    \"\"\"\n\n    {\n        \"<K>\": \"String\",\n        \"<KN>\": \"...\"\n    }\"\"\"\n\n    def __init__(self, document: Union[str, SelectorList, Selector]) -> None:\n        self._doc = (\n            Selector(document) if isinstance(document, str) else document\n        )\n\n    def _split_doc(self, value: Selector) -> SelectorList:\n        value1 = value.css(\"a\")\n        return value1\n\n    def _parse_key(self, value: Selector) -> str:\n        value1 = value.attrib[\"href\"]\n        return value1\n\n    def _parse_value(self, value: Selector) -> str:\n        value1 = value.get()\n        value2 = value1.strip(\" \")\n        return value2\n\n    def parse(self) -> T_UrlsMap:\n        return {\n            self._parse_key(e): self._parse_value(e)\n            for e in self._split_doc(self._doc)\n        }\n\n\nclass Books:\n    \"\"\"\n\n    [\n        {\n            \"name\": \"String\",\n            \"image_url\": \"String\",\n            \"url\": \"String\",\n            \"rating\": \"String\",\n            \"price\": \"Int\"\n        },\n        \"...\"\n    ]\"\"\"\n\n    def __init__(self, document: Union[str, SelectorList, Selector]) -> None:\n        self._doc = (\n            Selector(document) if isinstance(document, str) else document\n        )\n\n    def _split_doc(self, value: Selector) -> SelectorList:\n        value1 = value.css(\".col-lg-3\")\n        return value1\n\n    def _parse_name(self, value: Selector) -> str:\n        value1 = value.css(\".thumbnail\")\n        value2 = value1.attrib[\"alt\"]\n        return value2\n\n    def _parse_image_url(self, value: Selector) -> str:\n        value1 = value.css(\".thumbnail\")\n        value2 = value1.attrib[\"src\"]\n        value3 = \"https://{}\".format(value2) if value2 else value2\n        return value3\n\n    def _parse_url(self, value: Selector) -> str:\n        value1 = value.css(\".image_container > a\")\n        value2 = value1.attrib[\"href\"]\n        return value2\n\n    def _parse_rating(self, value: Selector) -> str:\n        value1 = value.css(\".star-rating\")\n        value2 = value1.attrib[\"class\"]\n        value3 = value2.lstrip(\"star-rating \")\n        return value3\n\n    def _parse_price(self, value: Selector) -> int:\n        value1 = value\n        with suppress(Exception):\n            value2 = value1.css(\".price_color\")\n            value3 = \"\".join(value2.css(\"::text\").getall())\n            value4 = re.search(\"(\\\\d+)\", value3)[1]\n            value5 = int(value4)\n            return value5\n        return 0\n\n    def parse(self) -> List[T_Books]:\n        return [\n            {\n                \"name\": self._parse_name(e),\n                \"image_url\": self._parse_image_url(e),\n                \"url\": self._parse_url(e),\n                \"rating\": self._parse_rating(e),\n                \"price\": self._parse_price(e),\n            }\n            for e in self._split_doc(self._doc)\n        ]\n\n\nclass CataloguePage:\n    \"\"\"books.toscrape.com catalogue page entrypoint parser\n\n    USAGE:\n\n        1. GET <catalog page> (https://books.toscrape.com/, https://books.toscrape.com/catalogue/page-2.html, ...)\n        2. add another prepare instruction how to correct cook page (if needed?)\n\n    ISSUES:\n\n        1. nope! Their love being scraped!\n\n\n    {\n        \"title\": \"String\",\n        \"urls\": [\n            \"String\",\n            \"...\"\n        ],\n        \"urls_map\": {\n            \"<K>\": \"String\",\n            \"<KN>\": \"...\"\n        },\n        \"books\": [\n            {\n                \"name\": \"String\",\n                \"image_url\": \"String\",\n                \"url\": \"String\",\n                \"rating\": \"String\",\n                \"price\": \"Int\"\n            },\n            \"...\"\n        ]\n    }\"\"\"\n\n    def __init__(self, document: Union[str, SelectorList, Selector]) -> None:\n        self._doc = (\n            Selector(document) if isinstance(document, str) else document\n        )\n\n    def _pre_validate(self, value: Union[Selector, SelectorList]) -> None:\n        value1 = value.css(\"title\")\n        value2 = \"\".join(value1.css(\"::text\").getall())\n        assert re.search(\"Books to Scrape\", value2), \"\"\n        return\n\n    def _parse_title(self, value: Selector) -> str:\n        value1 = value\n        with suppress(Exception):\n            assert value1.css(\"title\"), \"\"\n            value2 = value1\n            value3 = value2.css(\"title\")\n            value4 = \"\".join(value3.css(\"::text\").getall())\n            value5 = re.sub(\"^\\\\s+\", \"\", value4)\n            value6 = re.sub(\"\\\\s+$\", \"\", value5)\n            return value6\n        return \"test\"\n\n    def _parse_urls(self, value: Selector) -> T_Urls:\n        value1 = Urls(value).parse()\n        return value1\n\n    def _parse_urls_map(self, value: Selector) -> T_UrlsMap:\n        value1 = UrlsMap(value).parse()\n        return value1\n\n    def _parse_books(self, value: Selector) -> List[T_Books]:\n        value1 = Books(value).parse()\n        return value1\n\n    def parse(self) -> T_CataloguePage:\n        self._pre_validate(self._doc)\n        return {\n            \"title\": self._parse_title(self._doc),\n            \"urls\": self._parse_urls(self._doc),\n            \"urls_map\": self._parse_urls_map(self._doc),\n            \"books\": self._parse_books(self._doc),\n        }\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/examples/booksToScrape/python/booksToScrape.py b/examples/booksToScrape/python/booksToScrape.py
--- a/examples/booksToScrape/python/booksToScrape.py	(revision e503494828b9a03fe9f43fd1c3d229764d3da940)
+++ b/examples/booksToScrape/python/booksToScrape.py	(date 1739793762236)
@@ -12,7 +12,8 @@
 else:
     NoneType = type(None)
 
-from parsel import Selector, SelectorList
+from parsel import Selector
+from parsel.selector import _SelectorType, SelectorList  # noqa
 
 T_Urls = List[str]
 T_UrlsMap = Dict[str, str]
@@ -45,18 +46,16 @@
         "..."
     ]"""
 
-    def __init__(self, document: Union[str, SelectorList, Selector]) -> None:
+    def __init__(self, document: Union[str, _SelectorType]) -> None:
         self._doc = (
             Selector(document) if isinstance(document, str) else document
         )
 
-    def _split_doc(self, value: Selector) -> SelectorList:
-        value1 = value.css("a")
-        return value1
+    def _split_doc(self, value: _SelectorType) -> Selector:
+        return value.css("a")
 
     def _parse_item(self, value: Selector) -> str:
-        value1 = value.attrib["href"]
-        return value1
+        return value.attrib["href"]
 
     def parse(self) -> T_Urls:
         return [self._parse_item(e) for e in self._split_doc(self._doc)]
@@ -70,23 +69,20 @@
         "<KN>": "..."
     }"""
 
-    def __init__(self, document: Union[str, SelectorList, Selector]) -> None:
+    def __init__(self, document: Union[str, _SelectorType]) -> None:
         self._doc = (
             Selector(document) if isinstance(document, str) else document
         )
 
-    def _split_doc(self, value: Selector) -> SelectorList:
-        value1 = value.css("a")
-        return value1
+    def _split_doc(self, value: _SelectorType) -> Selector:
+        return value.css("a")
 
     def _parse_key(self, value: Selector) -> str:
-        value1 = value.attrib["href"]
-        return value1
+        return value.attrib["href"]
 
     def _parse_value(self, value: Selector) -> str:
         value1 = value.get()
-        value2 = value1.strip(" ")
-        return value2
+        return value1.strip(" ")
 
     def parse(self) -> T_UrlsMap:
         return {
@@ -109,25 +105,22 @@
         "..."
     ]"""
 
-    def __init__(self, document: Union[str, SelectorList, Selector]) -> None:
+    def __init__(self, document: Union[str, _SelectorType]) -> None:
         self._doc = (
             Selector(document) if isinstance(document, str) else document
         )
 
-    def _split_doc(self, value: Selector) -> SelectorList:
-        value1 = value.css(".col-lg-3")
-        return value1
+    def _split_doc(self, value: SelectorList[_SelectorType]) -> SelectorList:
+        return value.css(".col-lg-3")
 
     def _parse_name(self, value: Selector) -> str:
         value1 = value.css(".thumbnail")
-        value2 = value1.attrib["alt"]
-        return value2
+        return value1.attrib["alt"]
 
     def _parse_image_url(self, value: Selector) -> str:
         value1 = value.css(".thumbnail")
         value2 = value1.attrib["src"]
-        value3 = "https://{}".format(value2) if value2 else value2
-        return value3
+        return "https://{}".format(value2) if value2 else value2
 
     def _parse_url(self, value: Selector) -> str:
         value1 = value.css(".image_container > a")
@@ -137,8 +130,7 @@
     def _parse_rating(self, value: Selector) -> str:
         value1 = value.css(".star-rating")
         value2 = value1.attrib["class"]
-        value3 = value2.lstrip("star-rating ")
-        return value3
+        return value2.lstrip("star-rating ")
 
     def _parse_price(self, value: Selector) -> int:
         value1 = value
@@ -146,8 +138,7 @@
             value2 = value1.css(".price_color")
             value3 = "".join(value2.css("::text").getall())
             value4 = re.search("(\\d+)", value3)[1]
-            value5 = int(value4)
-            return value5
+            return int(value4)
         return 0
 
     def parse(self) -> List[T_Books]:
@@ -198,12 +189,12 @@
         ]
     }"""
 
-    def __init__(self, document: Union[str, SelectorList, Selector]) -> None:
+    def __init__(self, document: Union[str, _SelectorType]) -> None:
         self._doc = (
             Selector(document) if isinstance(document, str) else document
         )
 
-    def _pre_validate(self, value: Union[Selector, SelectorList]) -> None:
+    def _pre_validate(self, value: Union[_SelectorType]) -> None:
         value1 = value.css("title")
         value2 = "".join(value1.css("::text").getall())
         assert re.search("Books to Scrape", value2), ""
@@ -217,21 +208,17 @@
             value3 = value2.css("title")
             value4 = "".join(value3.css("::text").getall())
             value5 = re.sub("^\\s+", "", value4)
-            value6 = re.sub("\\s+$", "", value5)
-            return value6
+            return re.sub("\s+$", "", value5)
         return "test"
 
     def _parse_urls(self, value: Selector) -> T_Urls:
-        value1 = Urls(value).parse()
-        return value1
+        return Urls(value).parse()
 
     def _parse_urls_map(self, value: Selector) -> T_UrlsMap:
-        value1 = UrlsMap(value).parse()
-        return value1
+        return UrlsMap(value).parse()
 
     def _parse_books(self, value: Selector) -> List[T_Books]:
-        value1 = Books(value).parse()
-        return value1
+        return Books(value).parse()
 
     def parse(self) -> T_CataloguePage:
         self._pre_validate(self._doc)
Index: ssc_codegen/converters/py_parsel.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from .ast_utils import find_json_struct_instance\nfrom ssc_codegen.ast_ssc import (\n    HtmlAttrAllExpression,\n    HtmlAttrExpression,\n    HtmlCssAllExpression,\n    HtmlCssExpression,\n    HtmlRawAllExpression,\n    HtmlRawExpression,\n    HtmlTextAllExpression,\n    HtmlTextExpression,\n    HtmlXpathAllExpression,\n    HtmlXpathExpression,\n    IsCssExpression,\n    IsXPathExpression,\n    ModuleImports,\n    PartDocFunction,\n    PreValidateFunction,\n    StructFieldFunction,\n    StructInit,\n)\nfrom ssc_codegen.tokens import TokenType, VariableType, StructType\nfrom .py_base import BasePyCodeConverter, lr_var_names\nfrom .templates import py\nfrom .templates.template_bindings import TemplateBindings\n\n# setup converter\nBINDINGS_POST = TemplateBindings()\nBINDINGS_POST[TokenType.STRUCT_INIT] = (\n    \"self._doc=Selector(document) if isinstance(document, str) else document\"\n)\nBINDINGS_POST[TokenType.IMPORTS] = \"from parsel import Selector, SelectorList\"\n\n# extend default bindings\npy.BINDINGS[TokenType.EXPR_CSS] = \"{} = {}.css({})\"\npy.BINDINGS[TokenType.EXPR_CSS_ALL] = \"{} = {}.css({})\"\npy.BINDINGS[TokenType.EXPR_XPATH] = \"{} = {}.xpath({})\"\npy.BINDINGS[TokenType.EXPR_XPATH_ALL] = \"{} = {}.xpath({})\"\n\n# parsel get() method returns single match instead full text element scope\npy.BINDINGS[TokenType.EXPR_TEXT] = '{} = \"\".join({}.css(\"::text\").getall())'\npy.BINDINGS[TokenType.EXPR_TEXT_ALL] = '{} = {}.css(\"::text\").getall()'\npy.BINDINGS[TokenType.EXPR_RAW] = \"{} = {}.get()\"\npy.BINDINGS[TokenType.EXPR_RAW_ALL] = \"{} = {}.getall()\"\npy.BINDINGS[TokenType.EXPR_ATTR] = \"{} = {}.attrib[{}]\"\npy.BINDINGS[TokenType.EXPR_ATTR_ALL] = \"{} = [i.attrib[{}] for i in {}]\"\npy.BINDINGS[TokenType.IS_CSS] = \"assert {}.css({}), {}\"\npy.BINDINGS[TokenType.IS_XPATH] = \"assert {}.xpath({}), {}\"\n\nconverter = BasePyCodeConverter()\n\n\n@converter.pre(TokenType.STRUCT_INIT)\ndef tt_init(node: StructInit) -> str:\n    p_type = \"Union[str, SelectorList, Selector]\"\n    return py.INDENT_METHOD + py.BINDINGS[node.kind, p_type]\n\n\n@converter.post(TokenType.STRUCT_INIT)\ndef tt_init_post(node: StructInit) -> str:\n    return py.INDENT_METHOD_BODY + BINDINGS_POST[node.kind]\n\n\n@converter.post(TokenType.IMPORTS)\ndef tt_imports_post(node: ModuleImports) -> str:\n    return BINDINGS_POST[node.kind]\n\n\n@converter.pre(TokenType.STRUCT_PRE_VALIDATE)\ndef tt_pre_validate(node: PreValidateFunction) -> str:\n    name = py.MAGIC_METHODS_NAME.get(node.name)\n    p_type = \"Union[Selector, SelectorList]\"\n    return py.INDENT_METHOD + py.BINDINGS[node.kind, name, p_type]\n\n\n@converter.pre(TokenType.STRUCT_PART_DOCUMENT)\ndef tt_part_document(node: PartDocFunction) -> str:\n    p_type = \"Selector\"\n    ret_type = \"SelectorList\"\n    name = py.MAGIC_METHODS_NAME.get(node.name)\n    return py.INDENT_METHOD + py.BINDINGS[node.kind, name, p_type, ret_type]\n\n\n@converter.pre(TokenType.STRUCT_FIELD)\ndef tt_function(node: StructFieldFunction) -> str:\n    name = py.MAGIC_METHODS_NAME.get(node.name, node.name)\n    if node.ret_type == VariableType.NESTED:\n        t_def = node.find_associated_typedef()\n        ret_type = f\"T_{t_def.struct_ref.name}\"\n\n        if t_def.struct_ref.type == StructType.LIST:\n            ret_type = f\"List[{ret_type}]\"\n    elif node.ret_type == VariableType.JSON:\n        instance = find_json_struct_instance(node)  # noqa\n        ret_type = f\"J_{instance.__name__}\"\n        if instance.__IS_ARRAY__:\n            ret_type = f\"List[{ret_type}]\"\n    else:\n        ret_type = py.TYPES.get(node.ret_type)\n    p_type = \"Selector\"\n    return py.INDENT_METHOD + py.BINDINGS[node.kind, name, p_type, ret_type]\n\n\n# PARSEL API\n@converter.pre(TokenType.EXPR_CSS)\ndef tt_css(node: HtmlCssExpression) -> str:\n    indent = py.suggest_indent(node)\n\n    q = repr(node.query)\n    prv, nxt = lr_var_names(variable=node.variable)\n    code = py.BINDINGS[node.kind, nxt, prv, q]\n    return indent + code\n\n\n@converter.pre(TokenType.EXPR_CSS_ALL)\ndef tt_css_all(node: HtmlCssAllExpression) -> str:\n    indent = py.suggest_indent(node)\n\n    q = repr(node.query)\n    prv, nxt = lr_var_names(variable=node.variable)\n    code = py.BINDINGS[node.kind, nxt, prv, q]\n    return indent + code\n\n\n@converter.pre(TokenType.EXPR_XPATH)\ndef tt_xpath(node: HtmlXpathExpression) -> str:\n    indent = py.suggest_indent(node)\n\n    q = repr(node.query)\n    prv, nxt = lr_var_names(variable=node.variable)\n    code = py.BINDINGS[node.kind, nxt, prv, q]\n    return indent + code\n\n\n@converter.pre(TokenType.EXPR_XPATH_ALL)\ndef tt_xpath_all(node: HtmlXpathAllExpression) -> str:\n    indent = py.suggest_indent(node)\n    q = repr(node.query)\n    prv, nxt = lr_var_names(variable=node.variable)\n    code = py.BINDINGS[node.kind, nxt, prv, q]\n    return indent + code\n\n\n@converter.pre(TokenType.EXPR_TEXT)\ndef tt_text(node: HtmlTextExpression) -> str:\n    indent = py.suggest_indent(node)\n\n    prv, nxt = lr_var_names(variable=node.variable)\n    code = py.BINDINGS[node.kind, nxt, prv]\n    return indent + code\n\n\n@converter.pre(TokenType.EXPR_TEXT_ALL)\ndef tt_text_all(node: HtmlTextAllExpression) -> str:\n    indent = py.suggest_indent(node)\n\n    prv, nxt = lr_var_names(variable=node.variable)\n    code = py.BINDINGS[node.kind, nxt, prv]\n    return indent + code\n\n\n@converter.pre(TokenType.EXPR_RAW)\ndef tt_raw(node: HtmlRawExpression) -> str:\n    indent = py.suggest_indent(node)\n\n    prv, nxt = lr_var_names(variable=node.variable)\n    code = py.BINDINGS[node.kind, nxt, prv]\n    return indent + code\n\n\n@converter.pre(TokenType.EXPR_RAW_ALL)\ndef tt_raw_all(node: HtmlRawAllExpression) -> str:\n    indent = py.suggest_indent(node)\n\n    prv, nxt = lr_var_names(variable=node.variable)\n    code = py.BINDINGS[node.kind, nxt, prv]\n    return indent + code\n\n\n@converter.pre(TokenType.EXPR_ATTR)\ndef tt_attr(node: HtmlAttrExpression):\n    indent = py.suggest_indent(node)\n\n    n = repr(node.attr)\n    prv, nxt = lr_var_names(variable=node.variable)\n    code = py.BINDINGS[node.kind, nxt, prv, n]\n    return indent + code\n\n\n@converter.pre(TokenType.EXPR_ATTR_ALL)\ndef tt_attr_all(node: HtmlAttrAllExpression):\n    indent = py.suggest_indent(node)\n\n    n = repr(node.attr)\n    prv, nxt = lr_var_names(variable=node.variable)\n    code = py.BINDINGS[node.kind, nxt, n, prv]\n    return indent + code\n\n\n@converter.pre(TokenType.IS_CSS)\ndef tt_is_css(node: IsCssExpression):\n    indent = py.suggest_indent(node)\n\n    prv, nxt = lr_var_names(variable=node.variable)\n    q = repr(node.query)\n    msg = repr(node.msg)\n    code = py.BINDINGS[node.kind, prv, q, msg]\n    if node.next.kind == TokenType.EXPR_NO_RETURN:\n        return indent + code\n    return indent + code + \"\\n\" + indent + f\"{nxt} = {prv}\"\n\n\n@converter.pre(TokenType.IS_XPATH)\ndef tt_is_xpath(node: IsXPathExpression):\n    indent = py.suggest_indent(node)\n\n    prv, nxt = lr_var_names(variable=node.variable)\n    q = repr(node.query)\n    msg = repr(node.msg)\n    code = py.BINDINGS[node.kind, prv, q, msg]\n    if node.next.kind == TokenType.EXPR_NO_RETURN:\n        return indent + code\n    return indent + code + \"\\n\" + indent + f\"{nxt} = {prv}\"\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ssc_codegen/converters/py_parsel.py b/ssc_codegen/converters/py_parsel.py
--- a/ssc_codegen/converters/py_parsel.py	(revision e503494828b9a03fe9f43fd1c3d229764d3da940)
+++ b/ssc_codegen/converters/py_parsel.py	(date 1739793412937)
@@ -28,7 +28,7 @@
 BINDINGS_POST[TokenType.STRUCT_INIT] = (
     "self._doc=Selector(document) if isinstance(document, str) else document"
 )
-BINDINGS_POST[TokenType.IMPORTS] = "from parsel import Selector, SelectorList"
+BINDINGS_POST[TokenType.IMPORTS] = "from parsel import Selector\nfrom parsel.selector import _SelectorType  # noqa"
 
 # extend default bindings
 py.BINDINGS[TokenType.EXPR_CSS] = "{} = {}.css({})"
@@ -51,7 +51,7 @@
 
 @converter.pre(TokenType.STRUCT_INIT)
 def tt_init(node: StructInit) -> str:
-    p_type = "Union[str, SelectorList, Selector]"
+    p_type = "Union[str, _SelectorType]"
     return py.INDENT_METHOD + py.BINDINGS[node.kind, p_type]
 
 
@@ -68,14 +68,14 @@
 @converter.pre(TokenType.STRUCT_PRE_VALIDATE)
 def tt_pre_validate(node: PreValidateFunction) -> str:
     name = py.MAGIC_METHODS_NAME.get(node.name)
-    p_type = "Union[Selector, SelectorList]"
+    p_type = "Union[_SelectorType]"
     return py.INDENT_METHOD + py.BINDINGS[node.kind, name, p_type]
 
 
 @converter.pre(TokenType.STRUCT_PART_DOCUMENT)
 def tt_part_document(node: PartDocFunction) -> str:
-    p_type = "Selector"
-    ret_type = "SelectorList"
+    p_type = "_SelectorType"
+    ret_type = "Selector"
     name = py.MAGIC_METHODS_NAME.get(node.name)
     return py.INDENT_METHOD + py.BINDINGS[node.kind, name, p_type, ret_type]
 
