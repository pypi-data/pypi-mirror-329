
# Tracer Module Documentation

The `tracer` module is a core part of **TheBundle** framework, designed to provide detailed logging and tracking of function calls, asynchronous operations, and system processes. It simplifies debugging by integrating structured, contextual, and real-time log messages.

---

## ðŸ›  Features

- **Call Tracing**: Logs function entry, exit, and exception details.
- **Asynchronous Support**: Traces async operations with success and failure handling.
- **Decorators**: Simplify integration with `@decorator_call` and `@decorator_call_raise`.
- **Customizable Logging Levels**: Supports verbose, error, and debug levels.

---

## âœ¨ Example Logs

Below is a sample of logs generated by the tracer module during a command execution:

```plaintext
2024-12-15 09:40:02,119 DEBUG    bundle.core.tracer.common      TheBundle\src\bundle\core\process.py:122:_internal_call_ ðŸŸ¢  asyncio.subprocess.create_subprocess_shell(('invalidcommand',), {'stdout': -1, 'stderr': -1}) -> <Process 8836>
2024-12-15 09:40:02,125 DEBUG    bundle.core.tracer.common      TheBundle\src\bundle\core\process.py:171:_read_stream ðŸŸ¢  bundle.core.process.ProcessStream.callback_stderr(("'invalidcommand' is not recognized as an internal or external command,\r\n",), {}) -> None
2024-12-15 09:40:02,125 DEBUG    bundle.core.tracer.common      TheBundle\src\bundle\core\process.py:171:_read_stream ðŸŸ¢  bundle.core.process.ProcessStream.callback_stderr(('operable program or batch file.\r\n',), {}) -> None
2024-12-15 09:40:02,126 ERROR    bundle.core.tracer.common      TheBundle\src\bundle\core\process.py:119:__call__ ðŸ”´  bundle.core.process.ProcessStream._internal_call_(('invalidcommand', [], ["'invalidcommand' is not recognized as an internal or external command,\r\n", 'operable program or batch file.\r\n']), {}). Exception: Command failed with result command='invalidcommand' returncode=1 stdout='' stderr="'invalidcommand' is not recognized as an internal or external command,...
```

### Log Components
1. **Timestamp**: `2024-12-15 09:40:02,119` - The precise moment of the log entry.
2. **Log Level**: `DEBUG`, `ERROR` - Indicates the severity or type of log.
3. **Logger**: `bundle.core.tracer.common` - The source module of the log.
4. **File Path**: `C:\Developer\Repos\TheBundle\src\bundle\core\process.py:122:_internal_call_` - File and function location of the log.
5. **Emoji Indicator**: 
   - `ðŸŸ¢` Success
   - `ðŸ”´` Error/Failure
   - `ðŸŸ¡` Warning
6. **Context and Outcome**:
   - Function calls, arguments, and results.
   - Exception details if an error occurs.

---

## ðŸ”„ `asyn` vs. `syn`: Understanding the Difference

The `tracer` module provides two complementary submodules: `asyn` and `syn`. These are used to trace and log function calls depending on whether they are asynchronous or synchronous.

### `asyn` Module

The `asyn` module is designed for **asynchronous** function calls, typically used with Python's `async/await` syntax. It provides utilities to trace, log, and handle async functions, including support for coroutine-based workflows.

#### Features:
- Captures asynchronous call chains.
- Handles coroutine results and exceptions.
- Ensures smooth integration with event loops like `asyncio`.

#### Example Use Case:
Use the `asyn` module for:
- Functions performing I/O (e.g., HTTP requests, database queries).
- Long-running background tasks.
- Asynchronous subprocess management.

**Example:**

```python
from bundle.core.tracer.asyn import call_raise

async def run_command(command: str):
    result = await call_raise(asyncio.create_subprocess_shell, command)
    return result
```

---

### `syn` Module

The `syn` module is tailored for **synchronous** function calls, where the `async/await` syntax is not required. It provides similar tracing and logging capabilities for traditional (blocking) Python functions.

#### Features:
- Tracks synchronous function calls and results.
- Logs exceptions with contextual details.
- Simple integration without requiring an event loop.

#### Example Use Case:
Use the `syn` module for:
- Functions that execute CPU-bound operations.
- Code that does not rely on `asyncio` or asynchronous frameworks.

**Example:**

```python
from bundle.core.tracer.syn import call_raise

def calculate_sum(a: int, b: int):
    return call_raise(sum, [a, b])
```

---

### Decorator Usage

The tracer also provides decorators to simplify logging integration. Decorators automatically trace function calls, including arguments, results, and exceptions.

#### Asynchronous Decorator Example

```python
from bundle.core.tracer.asyn import decorator_call_raise

@decorator_call_raise
async def async_example(x: int, y: int) -> int:
    return x + y

# Usage
async def run():
    result = await async_example(3, 5)
    print(result)  # Outputs: 8
```

#### Synchronous Decorator Example

```python
from bundle.core.tracer.syn import decorator_call_raise

@decorator_call_raise
def sync_example(x: int, y: int) -> int:
    return x * y

# Usage
result = sync_example(4, 6)
print(result)  # Outputs: 24
```

Decorators simplify function tracing by eliminating manual calls to `call_raise`. They work seamlessly for both synchronous and asynchronous contexts.

---

### When to Use `asyn` vs. `syn`

| **Scenario**                         | **Module to Use** |
|---------------------------------------|--------------------|
| Async function using `async def`      | `asyn`             |
| Function interacting with an event loop | `asyn`             |
| Blocking or CPU-bound operations      | `syn`              |
| Standard function without `async/await` | `syn`              |

---

### Combining `asyn` and `syn`

For complex applications that mix synchronous and asynchronous functions, you can use both `asyn` and `syn` in harmony. For instance, in a function that calls both types of operations:

**Example:**

```python
from bundle.core.tracer.syn import call_raise as sync_call
from bundle.core.tracer.asyn import call_raise as async_call

def sync_operation():
    return sync_call(len, "Sync Operation")

async def async_operation():
    return await async_call(asyncio.sleep, 1)

async def combined_task():
    sync_result = sync_operation()
    async_result = await async_operation()
    return sync_result, async_result
```

By using the appropriate module for the function type, you ensure consistent and comprehensive logging across your application.

--- 

## ðŸ“œ License

The tracer module is part of **TheBundle**, licensed under the [Apache-2.0 License](LICENSE).
