from pydantic import BaseModel, Field, model_validator
from typing import Dict


class DssatLMParserResponse(BaseModel):
    farm_name: str = Field("-99", description="The name of the farm.")
    crop_name: str = Field("-99", description="The name of the crop.")
    crop_variety: str = Field("-99", description="The variety of the crop, also known as cultivar type.")
    latitude: float = Field(-99, description="The latitude of the farm.")
    longitude: float = Field(-99, description="The longitude of the farm.")
    elevation: float = Field(-99, description="The elevation of the farm.")
    planting_date: str = Field("-99", description="The planting date.")
    is_irrigation_applied: str = Field("-99", description="Indicates if irrigation is applied.")
    irrigation_application: list = Field(default_factory=list, description="List of irrigation applications with date and amount.")
    nitrogen_fertilizer_application: list = Field(default_factory=list, description="List of nitrogen fertilizer applications with date and amount.")
    question_statements: list = Field(default_factory=list, description="List of questions asked by farmers.")


class DssatLMInterpreterResponseSingle(BaseModel):
    question_statement: str = Field(
        "Missing", 
        description="The farmer's original question statement."
    )
    matched_question_found: str = Field(
        "Not Found", 
        description="The question from the bank of definitions that semantically matches the question statement the most."
    )
    retrieved_answer: str = Field(
        "Not Found", 
        description="The extracted the `key-value` pairs in the JSON object that corresponds to the matched question. In the form of `The <key> is <value>`."
    )
    answer_for_farmer: str = Field(
        "Sorry, your question cannot be answered at the moment.", 
        description="The answer generated by the model for the farmer in a farmer-friendly language."
    )

def default_questions_single() -> Dict[str, DssatLMInterpreterResponseSingle]:
    return {
        "question_1": DssatLMInterpreterResponseSingle(
            question_statement="when is the best time to plant?",
            matched_question_found="Optimal planting date?",
            retrieved_answer="The optimal planting date is April 15th.",
            answer_for_farmer="You should plant your crops around April 15th for the best yield."
        )
    }

def default_questions_missing(question_statement) -> Dict[str, DssatLMInterpreterResponseSingle]:
    return {
            "question_statement": question_statement,
            "matched_question_found":"Could not find a matching question.",
            "retrieved_answer":"Could not retrieve an appropriate answer.",
            "answer_for_farmer": "Sorry, your question cannot be answered at the moment. This is most likely due to the LM being temporarily unavailable."
    }
    
    
def create_empty_questions() -> Dict[str, DssatLMInterpreterResponseSingle]:
    return {}

class DssatLMInterpreterResponseBatch(BaseModel):
    questions: Dict[str, DssatLMInterpreterResponseSingle] = Field(
        default_factory=create_empty_questions,
        description="A dictionary where each key is a question identifier (e.g., 'question_1') and each value is a DssatLMInterpreterResponseSingle instance."
    )