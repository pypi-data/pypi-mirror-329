"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Copyright 2023 Ant Group Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

import builtins
import collections.abc
import google.protobuf.any_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _PrimitiveDataType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _PrimitiveDataTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_PrimitiveDataType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    PrimitiveDataType_UNDEFINED: _PrimitiveDataType.ValueType  # 0
    DT_FLOAT: _PrimitiveDataType.ValueType  # 1
    """Basic types.
    float
    """
    DT_UINT8: _PrimitiveDataType.ValueType  # 2
    """uint8_t"""
    DT_INT8: _PrimitiveDataType.ValueType  # 3
    """int8_t"""
    DT_UINT16: _PrimitiveDataType.ValueType  # 4
    """uint16_t"""
    DT_INT16: _PrimitiveDataType.ValueType  # 5
    """int16_t"""
    DT_INT32: _PrimitiveDataType.ValueType  # 6
    """int32_t"""
    DT_INT64: _PrimitiveDataType.ValueType  # 7
    """int64_t"""
    DT_STRING: _PrimitiveDataType.ValueType  # 8
    """string"""
    DT_BOOL: _PrimitiveDataType.ValueType  # 9
    """bool"""
    DT_FLOAT16: _PrimitiveDataType.ValueType  # 10
    """IEEE754 half-precision floating-point format (16 bits wide).
    This format has 1 sign bit, 5 exponent bits, and 10 mantissa bits.
    """
    DT_DOUBLE: _PrimitiveDataType.ValueType  # 11
    DT_UINT32: _PrimitiveDataType.ValueType  # 12
    DT_UINT64: _PrimitiveDataType.ValueType  # 13
    DT_COMPLEX64: _PrimitiveDataType.ValueType  # 14
    """complex with float32 real and imaginary components"""
    DT_COMPLEX128: _PrimitiveDataType.ValueType  # 15
    """complex with float64 real and imaginary components"""
    DT_BFLOAT16: _PrimitiveDataType.ValueType  # 16
    """Non-IEEE floating-point format based on IEEE754 single-precision
    floating-point number truncated to 16 bits.
    This format has 1 sign bit, 8 exponent bits, and 7 mantissa bits.
    """
    DT_DATETIME: _PrimitiveDataType.ValueType  # 17
    """DATETIME and TIMESTAMP
    https://dev.mysql.com/doc/refman/8.0/en/datetime.html
    """
    DT_TIMESTAMP: _PrimitiveDataType.ValueType  # 18
    """seconds since '1970-01-01 00:00:00' UTC"""

class PrimitiveDataType(_PrimitiveDataType, metaclass=_PrimitiveDataTypeEnumTypeWrapper): ...

PrimitiveDataType_UNDEFINED: PrimitiveDataType.ValueType  # 0
DT_FLOAT: PrimitiveDataType.ValueType  # 1
"""Basic types.
float
"""
DT_UINT8: PrimitiveDataType.ValueType  # 2
"""uint8_t"""
DT_INT8: PrimitiveDataType.ValueType  # 3
"""int8_t"""
DT_UINT16: PrimitiveDataType.ValueType  # 4
"""uint16_t"""
DT_INT16: PrimitiveDataType.ValueType  # 5
"""int16_t"""
DT_INT32: PrimitiveDataType.ValueType  # 6
"""int32_t"""
DT_INT64: PrimitiveDataType.ValueType  # 7
"""int64_t"""
DT_STRING: PrimitiveDataType.ValueType  # 8
"""string"""
DT_BOOL: PrimitiveDataType.ValueType  # 9
"""bool"""
DT_FLOAT16: PrimitiveDataType.ValueType  # 10
"""IEEE754 half-precision floating-point format (16 bits wide).
This format has 1 sign bit, 5 exponent bits, and 10 mantissa bits.
"""
DT_DOUBLE: PrimitiveDataType.ValueType  # 11
DT_UINT32: PrimitiveDataType.ValueType  # 12
DT_UINT64: PrimitiveDataType.ValueType  # 13
DT_COMPLEX64: PrimitiveDataType.ValueType  # 14
"""complex with float32 real and imaginary components"""
DT_COMPLEX128: PrimitiveDataType.ValueType  # 15
"""complex with float64 real and imaginary components"""
DT_BFLOAT16: PrimitiveDataType.ValueType  # 16
"""Non-IEEE floating-point format based on IEEE754 single-precision
floating-point number truncated to 16 bits.
This format has 1 sign bit, 8 exponent bits, and 7 mantissa bits.
"""
DT_DATETIME: PrimitiveDataType.ValueType  # 17
"""DATETIME and TIMESTAMP
https://dev.mysql.com/doc/refman/8.0/en/datetime.html
"""
DT_TIMESTAMP: PrimitiveDataType.ValueType  # 18
"""seconds since '1970-01-01 00:00:00' UTC"""
global___PrimitiveDataType = PrimitiveDataType

@typing.final
class Field(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    name: builtins.str
    type: global___PrimitiveDataType.ValueType
    def __init__(
        self,
        *,
        name: builtins.str = ...,
        type: global___PrimitiveDataType.ValueType = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["name", b"name", "type", b"type"]) -> None: ...

global___Field = Field

@typing.final
class Schema(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DELIMITER_FIELD_NUMBER: builtins.int
    FIELDS_FIELD_NUMBER: builtins.int
    delimiter: builtins.str
    """对于 CSV 格式的数据，需要指定分隔符"""
    @property
    def fields(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Field]: ...
    def __init__(
        self,
        *,
        delimiter: builtins.str = ...,
        fields: collections.abc.Iterable[global___Field] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["delimiter", b"delimiter", "fields", b"fields"]) -> None: ...

global___Schema = Schema

@typing.final
class UnifiedAttestationAttributes(google.protobuf.message.Message):
    """/ UnifiedAttestationAttributes collect all attributes information
    / of trusted application from UnifiedAttestationReport format report.
    / All attributes is optional when used in UnifiedAttestationPolicy.
    / The TEE implement decides which attribute is used in repport and policy.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    STR_TEE_PLATFORM_FIELD_NUMBER: builtins.int
    HEX_PLATFORM_HW_VERSION_FIELD_NUMBER: builtins.int
    HEX_PLATFORM_SW_VERSION_FIELD_NUMBER: builtins.int
    HEX_SECURE_FLAGS_FIELD_NUMBER: builtins.int
    HEX_PLATFORM_MEASUREMENT_FIELD_NUMBER: builtins.int
    HEX_BOOT_MEASUREMENT_FIELD_NUMBER: builtins.int
    STR_TEE_IDENTITY_FIELD_NUMBER: builtins.int
    HEX_TA_MEASUREMENT_FIELD_NUMBER: builtins.int
    HEX_TA_DYN_MEASUREMENT_FIELD_NUMBER: builtins.int
    HEX_SIGNER_FIELD_NUMBER: builtins.int
    HEX_PROD_ID_FIELD_NUMBER: builtins.int
    STR_MIN_ISVSVN_FIELD_NUMBER: builtins.int
    BOOL_DEBUG_DISABLED_FIELD_NUMBER: builtins.int
    HEX_USER_DATA_FIELD_NUMBER: builtins.int
    HEX_HASH_OR_PEM_PUBKEY_FIELD_NUMBER: builtins.int
    HEX_NONCE_FIELD_NUMBER: builtins.int
    HEX_SPID_FIELD_NUMBER: builtins.int
    str_tee_platform: builtins.str
    """The TEE platform, in case some verifier need to verify this."""
    hex_platform_hw_version: builtins.str
    """The TEE platform hardware related identity or version"""
    hex_platform_sw_version: builtins.str
    """The TEE platform TCB software related version"""
    hex_secure_flags: builtins.str
    """The TEE platform security related attribte or flags"""
    hex_platform_measurement: builtins.str
    """The measurement of TEE implement internal stuffs"""
    hex_boot_measurement: builtins.str
    """The measurement of TEE instance boot time stuffs"""
    str_tee_identity: builtins.str
    """The TEE instance or trust application identity when generate the reprot"""
    hex_ta_measurement: builtins.str
    """The static measurement of trust application when load the code"""
    hex_ta_dyn_measurement: builtins.str
    """The dynamical measurement of trust application code,
    for example, the real-time measurement of code in secure memory
    after the trust application is already run.
    """
    hex_signer: builtins.str
    """The measurement or other identity of the trust application signer"""
    hex_prod_id: builtins.str
    """The product ID of the TEE instance or trust application"""
    str_min_isvsvn: builtins.str
    """The minimal ISV SVN of the TEE instance or trust application"""
    bool_debug_disabled: builtins.str
    """The bool string "0" for debugable, "1" for not debugable"""
    hex_user_data: builtins.str
    """The user special data for generating attestation report"""
    hex_hash_or_pem_pubkey: builtins.str
    """hex string hash or original pem public key"""
    hex_nonce: builtins.str
    """The idenpendent freshness value beside what in user data"""
    hex_spid: builtins.str
    """The service provider id, e.g. use in sgx1, 64 bytes hex string"""
    def __init__(
        self,
        *,
        str_tee_platform: builtins.str = ...,
        hex_platform_hw_version: builtins.str = ...,
        hex_platform_sw_version: builtins.str = ...,
        hex_secure_flags: builtins.str = ...,
        hex_platform_measurement: builtins.str = ...,
        hex_boot_measurement: builtins.str = ...,
        str_tee_identity: builtins.str = ...,
        hex_ta_measurement: builtins.str = ...,
        hex_ta_dyn_measurement: builtins.str = ...,
        hex_signer: builtins.str = ...,
        hex_prod_id: builtins.str = ...,
        str_min_isvsvn: builtins.str = ...,
        bool_debug_disabled: builtins.str = ...,
        hex_user_data: builtins.str = ...,
        hex_hash_or_pem_pubkey: builtins.str = ...,
        hex_nonce: builtins.str = ...,
        hex_spid: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["bool_debug_disabled", b"bool_debug_disabled", "hex_boot_measurement", b"hex_boot_measurement", "hex_hash_or_pem_pubkey", b"hex_hash_or_pem_pubkey", "hex_nonce", b"hex_nonce", "hex_platform_hw_version", b"hex_platform_hw_version", "hex_platform_measurement", b"hex_platform_measurement", "hex_platform_sw_version", b"hex_platform_sw_version", "hex_prod_id", b"hex_prod_id", "hex_secure_flags", b"hex_secure_flags", "hex_signer", b"hex_signer", "hex_spid", b"hex_spid", "hex_ta_dyn_measurement", b"hex_ta_dyn_measurement", "hex_ta_measurement", b"hex_ta_measurement", "hex_user_data", b"hex_user_data", "str_min_isvsvn", b"str_min_isvsvn", "str_tee_identity", b"str_tee_identity", "str_tee_platform", b"str_tee_platform"]) -> None: ...

global___UnifiedAttestationAttributes = UnifiedAttestationAttributes

@typing.final
class UnifiedAttestationPolicy(google.protobuf.message.Message):
    """/ UnifiedAttestationPolicy is used when verify the attestation report.
    / Both main or nested submodule attester support multi-version of instances.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PEM_PUBLIC_KEY_FIELD_NUMBER: builtins.int
    MAIN_ATTRIBUTES_FIELD_NUMBER: builtins.int
    NESTED_POLICIES_FIELD_NUMBER: builtins.int
    pem_public_key: builtins.str
    """Assume one public key is bound to one report, specify it here.
    We can also specify the public key or its hash in main or submodule
    UnifiedAttestationAttributes. Public key verification will happen
    in both two places.
    NOTE: if there is submodule attester, we must specify the public key
    here to verify the signature of submode attestation result.
    """
    @property
    def main_attributes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___UnifiedAttestationAttributes]:
        """For main attester"""

    @property
    def nested_policies(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___UnifiedAttestationNestedPolicy]:
        """For submodule attesters"""

    def __init__(
        self,
        *,
        pem_public_key: builtins.str = ...,
        main_attributes: collections.abc.Iterable[global___UnifiedAttestationAttributes] | None = ...,
        nested_policies: collections.abc.Iterable[global___UnifiedAttestationNestedPolicy] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["main_attributes", b"main_attributes", "nested_policies", b"nested_policies", "pem_public_key", b"pem_public_key"]) -> None: ...

global___UnifiedAttestationPolicy = UnifiedAttestationPolicy

@typing.final
class UnifiedAttestationNestedPolicy(google.protobuf.message.Message):
    """/ Match rulse for nested report verification"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SUB_ATTRIBUTES_FIELD_NUMBER: builtins.int
    @property
    def sub_attributes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___UnifiedAttestationAttributes]: ...
    def __init__(
        self,
        *,
        sub_attributes: collections.abc.Iterable[global___UnifiedAttestationAttributes] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["sub_attributes", b"sub_attributes"]) -> None: ...

global___UnifiedAttestationNestedPolicy = UnifiedAttestationNestedPolicy

@typing.final
class UnifiedAttestationReportParams(google.protobuf.message.Message):
    """/ Special Parameters for different TEE platforms, keep consistent with kubetee
    / attestation.proto
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    STR_REPORT_IDENTITY_FIELD_NUMBER: builtins.int
    HEX_USER_DATA_FIELD_NUMBER: builtins.int
    JSON_NESTED_REPORTS_FIELD_NUMBER: builtins.int
    HEX_SPID_FIELD_NUMBER: builtins.int
    str_report_identity: builtins.str
    """The identity string for report instance which is cached inside TEE.
    It's optional and usually used in Asynchronous processes.
    """
    hex_user_data: builtins.str
    """The user data in some TEE platforms, Max to 64 Bytes of HEX string.
    Users need to convert binary value data to HEX string themselves.
    """
    json_nested_reports: builtins.str
    """The JSON serialized string of UnifiedAttestationNestedReports"""
    hex_spid: builtins.str
    """Service Provider ID for SGX1 only"""
    def __init__(
        self,
        *,
        str_report_identity: builtins.str = ...,
        hex_user_data: builtins.str = ...,
        json_nested_reports: builtins.str = ...,
        hex_spid: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["hex_spid", b"hex_spid", "hex_user_data", b"hex_user_data", "json_nested_reports", b"json_nested_reports", "str_report_identity", b"str_report_identity"]) -> None: ...

global___UnifiedAttestationReportParams = UnifiedAttestationReportParams

@typing.final
class UnifiedAttestationReport(google.protobuf.message.Message):
    """/ Unified Attestation Report, keep consistent with kubetee attestation.proto"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    STR_REPORT_VERSION_FIELD_NUMBER: builtins.int
    STR_REPORT_TYPE_FIELD_NUMBER: builtins.int
    STR_TEE_PLATFORM_FIELD_NUMBER: builtins.int
    JSON_REPORT_FIELD_NUMBER: builtins.int
    JSON_NESTED_REPORTS_FIELD_NUMBER: builtins.int
    str_report_version: builtins.str
    """For compatibility and udpate later, current is version "1.0" """
    str_report_type: builtins.str
    """Valid type string: "BackgroundCheck"|"Passport"|"Uas" """
    str_tee_platform: builtins.str
    """The TEE platform name"""
    json_report: builtins.str
    """Different JSON serialized string for each TEE platform
    The TEE platforms are in charge of parsing it in their own way.
    """
    json_nested_reports: builtins.str
    """The JSON serialized string of UnifiedAttestationNestedReports"""
    def __init__(
        self,
        *,
        str_report_version: builtins.str = ...,
        str_report_type: builtins.str = ...,
        str_tee_platform: builtins.str = ...,
        json_report: builtins.str = ...,
        json_nested_reports: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["json_nested_reports", b"json_nested_reports", "json_report", b"json_report", "str_report_type", b"str_report_type", "str_report_version", b"str_report_version", "str_tee_platform", b"str_tee_platform"]) -> None: ...

global___UnifiedAttestationReport = UnifiedAttestationReport

@typing.final
class Ancestor(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    OWNER_ID_FIELD_NUMBER: builtins.int
    DATA_UUID_FIELD_NUMBER: builtins.int
    owner_id: builtins.str
    """数据 owner 公钥的哈希

    公钥格式见 RFC5280 中 `SubjectPublicKeyInfo` 结构, 公钥哈希计算如下：
    使用 SHA256 对公钥 DER 格式进行哈希，SHA256(DER(pk))
    """
    data_uuid: builtins.str
    def __init__(
        self,
        *,
        owner_id: builtins.str = ...,
        data_uuid: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["data_uuid", b"data_uuid", "owner_id", b"owner_id"]) -> None: ...

global___Ancestor = Ancestor

@typing.final
class SegmentDataMeta(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SEGMENT_ID_FIELD_NUMBER: builtins.int
    SECRET_SHARD_ID_FIELD_NUMBER: builtins.int
    ENCRYPTED_DATA_KEY_FIELD_NUMBER: builtins.int
    MAC_FIELD_NUMBER: builtins.int
    SIGNATURE_FIELD_NUMBER: builtins.int
    segment_id: builtins.int
    """分段 ID"""
    secret_shard_id: builtins.int
    """分量 ID"""
    encrypted_data_key: builtins.bytes
    """加密数据的密钥
    上传数据：使用 Auth Manager 的公钥加密
    下载数据：使用数据请求者的公钥加密
    """
    mac: builtins.bytes
    """HMAC(data key, data_uuid || partition_id  ||
    segment_id || secret_shard_id || raw data)
    int类型转为小端字节序的字节进行拼接
    CreateDataInfo时可为空，在Finish时再写入DB
    """
    signature: builtins.bytes
    """数据 owner 签名
    SIG(data_uuid || partition_id  ||
    segment_id || secret_shard_id || data key)
    """
    def __init__(
        self,
        *,
        segment_id: builtins.int = ...,
        secret_shard_id: builtins.int = ...,
        encrypted_data_key: builtins.bytes = ...,
        mac: builtins.bytes = ...,
        signature: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["encrypted_data_key", b"encrypted_data_key", "mac", b"mac", "secret_shard_id", b"secret_shard_id", "segment_id", b"segment_id", "signature", b"signature"]) -> None: ...

global___SegmentDataMeta = SegmentDataMeta

@typing.final
class PartitionDataMeta(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARTITION_ID_FIELD_NUMBER: builtins.int
    SEGMENT_NUM_FIELD_NUMBER: builtins.int
    SEGMENT_DATA_FIELD_NUMBER: builtins.int
    partition_id: builtins.str
    """分区 ID"""
    segment_num: builtins.int
    """分段总数，对于大数据，需要拆分成小的分段进行处理"""
    @property
    def segment_data(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SegmentDataMeta]:
        """分段数据"""

    def __init__(
        self,
        *,
        partition_id: builtins.str = ...,
        segment_num: builtins.int = ...,
        segment_data: collections.abc.Iterable[global___SegmentDataMeta] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["partition_id", b"partition_id", "segment_data", b"segment_data", "segment_num", b"segment_num"]) -> None: ...

global___PartitionDataMeta = PartitionDataMeta

@typing.final
class DataMeta(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DATA_UUID_FIELD_NUMBER: builtins.int
    OWNER_ID_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    DATA_TYPE_FIELD_NUMBER: builtins.int
    SOURCE_TYPE_FIELD_NUMBER: builtins.int
    TASK_ID_FIELD_NUMBER: builtins.int
    TASK_TYPE_FIELD_NUMBER: builtins.int
    DATA_FORMAT_FIELD_NUMBER: builtins.int
    PARTITION_NUM_FIELD_NUMBER: builtins.int
    SECRET_SHARD_NUM_FIELD_NUMBER: builtins.int
    VERSION_FIELD_NUMBER: builtins.int
    PARTITION_DATA_FIELD_NUMBER: builtins.int
    ANCESTORS_FIELD_NUMBER: builtins.int
    ALL_ANCESTORS_FIELD_NUMBER: builtins.int
    SCHEMA_FIELD_NUMBER: builtins.int
    MAC_FIELD_NUMBER: builtins.int
    data_uuid: builtins.str
    """数据 uuid 采用 RFC4122(https://www.ietf.org/rfc/rfc4122.txt)
    中基于伪随机数的生成方式 伪随机数算法采用 Mersenne Twister 生成算法
    """
    owner_id: builtins.str
    """数据 owner 公钥的哈希

    公钥格式见 RFC5280 中 `SubjectPublicKeyInfo` 结构, 公钥哈希计算如下：
    使用 SHA256 对公钥 DER 格式进行哈希，SHA256(DER(pk))
    """
    name: builtins.str
    """数据名称"""
    description: builtins.str
    """数据描述"""
    data_type: builtins.str
    """数据类型
    NONE: not an MPC data
    ASS: arithmetic secret shared data
    """
    source_type: builtins.str
    """数据来源
    USER: 来自机构的数据
    TEE: 来自TEE worker的数据
    """
    task_id: builtins.str
    """任务号
    如果是来自用户的原始数据，为空
    当数据来源是TEE时，标识生成这个数据的task_id
    """
    task_type: builtins.str
    """任务类型
    如果是原始数据，为空
    当数据来源是TEE时，表示生成这个数据的任务类型
    """
    data_format: builtins.str
    """CSV
    OBJ 非结构化数据
    """
    partition_num: builtins.int
    """分区总数"""
    secret_shard_num: builtins.int
    """分量总数, 目前只有两个值 1 or 2
    1 - 表示数据没有拆分量
    2 - TECC中的数据拆了分量
    """
    version: builtins.int
    """数据 Schema 版本"""
    mac: builtins.str
    """如果是原始数据，它为空
    如果是中间数据，mac的内容:= HmacSHA256(data_uuid | data_source || ancestor
    || all_ancestor)
    mac密钥使用data_uuid对应的MAC密钥(记录在数据MAC密钥密文表中）
    """
    @property
    def partition_data(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___PartitionDataMeta]:
        """分区数据"""

    @property
    def ancestors(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Ancestor]:
        """数据的直接祖先
        如果是原始数据，它为空
        如果是中间数据，它是数据集的直接祖先
        """

    @property
    def all_ancestors(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Ancestor]:
        """数据的所有祖先
        如果是原始数据，它为空
        如果是中间数据，它是数据集的所有祖先
        """

    @property
    def schema(self) -> global___Schema: ...
    def __init__(
        self,
        *,
        data_uuid: builtins.str = ...,
        owner_id: builtins.str = ...,
        name: builtins.str = ...,
        description: builtins.str = ...,
        data_type: builtins.str = ...,
        source_type: builtins.str = ...,
        task_id: builtins.str = ...,
        task_type: builtins.str = ...,
        data_format: builtins.str = ...,
        partition_num: builtins.int = ...,
        secret_shard_num: builtins.int = ...,
        version: builtins.int = ...,
        partition_data: collections.abc.Iterable[global___PartitionDataMeta] | None = ...,
        ancestors: collections.abc.Iterable[global___Ancestor] | None = ...,
        all_ancestors: collections.abc.Iterable[global___Ancestor] | None = ...,
        schema: global___Schema | None = ...,
        mac: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["optional_schema", b"optional_schema", "schema", b"schema"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["all_ancestors", b"all_ancestors", "ancestors", b"ancestors", "data_format", b"data_format", "data_type", b"data_type", "data_uuid", b"data_uuid", "description", b"description", "mac", b"mac", "name", b"name", "optional_schema", b"optional_schema", "owner_id", b"owner_id", "partition_data", b"partition_data", "partition_num", b"partition_num", "schema", b"schema", "secret_shard_num", b"secret_shard_num", "source_type", b"source_type", "task_id", b"task_id", "task_type", b"task_type", "version", b"version"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["optional_schema", b"optional_schema"]) -> typing.Literal["schema"] | None: ...

global___DataMeta = DataMeta

@typing.final
class SegmentDataUri(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SEGMENT_ID_FIELD_NUMBER: builtins.int
    SECRET_SHARD_ID_FIELD_NUMBER: builtins.int
    DATA_URI_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    MAC_FIELD_NUMBER: builtins.int
    SEGMENT_DATA_META_FIELD_NUMBER: builtins.int
    DATA_KEY_FIELD_NUMBER: builtins.int
    segment_id: builtins.int
    """分段 ID"""
    secret_shard_id: builtins.int
    """分量 ID"""
    data_uri: builtins.str
    """数据存储路径"""
    status: builtins.str
    """数据状态
    CREATED/UPLOADED/FAILED
    """
    mac: builtins.bytes
    """HMAC(data key, data_uuid || partition_id  ||
    segment_id || secret_shard_id || raw data)
    int类型转为小端字节序的字节进行拼接
    在FinishDataUpload这一步写入DB
    该字段仅在FinishDataUpload这一步有意义,查询时mac在optional_seg中
    """
    data_key: builtins.bytes
    """明文 data key
    TEE/TECC worker 在请求计算参数时需要安全获取 data key, 存储在
    `authmanager.ComputeMeta`, 整个结构会使用数字信封保证安全安全通信
    """
    @property
    def segment_data_meta(self) -> global___SegmentDataMeta: ...
    def __init__(
        self,
        *,
        segment_id: builtins.int = ...,
        secret_shard_id: builtins.int = ...,
        data_uri: builtins.str = ...,
        status: builtins.str = ...,
        mac: builtins.bytes = ...,
        segment_data_meta: global___SegmentDataMeta | None = ...,
        data_key: builtins.bytes = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["data_key", b"data_key", "optional_seg", b"optional_seg", "segment_data_meta", b"segment_data_meta"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["data_key", b"data_key", "data_uri", b"data_uri", "mac", b"mac", "optional_seg", b"optional_seg", "secret_shard_id", b"secret_shard_id", "segment_data_meta", b"segment_data_meta", "segment_id", b"segment_id", "status", b"status"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["optional_seg", b"optional_seg"]) -> typing.Literal["segment_data_meta", "data_key"] | None: ...

global___SegmentDataUri = SegmentDataUri

@typing.final
class PartitionDataUri(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARTITION_ID_FIELD_NUMBER: builtins.int
    SEG_DATA_URIS_FIELD_NUMBER: builtins.int
    partition_id: builtins.str
    """分区 ID"""
    @property
    def seg_data_uris(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SegmentDataUri]:
        """分段数据存储位置"""

    def __init__(
        self,
        *,
        partition_id: builtins.str = ...,
        seg_data_uris: collections.abc.Iterable[global___SegmentDataUri] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["partition_id", b"partition_id", "seg_data_uris", b"seg_data_uris"]) -> None: ...

global___PartitionDataUri = PartitionDataUri

@typing.final
class DataUri(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DATA_UUID_FIELD_NUMBER: builtins.int
    PART_DATA_URIS_FIELD_NUMBER: builtins.int
    data_uuid: builtins.str
    """数据 UUID"""
    @property
    def part_data_uris(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___PartitionDataUri]:
        """分区数据存储位置"""

    def __init__(
        self,
        *,
        data_uuid: builtins.str = ...,
        part_data_uris: collections.abc.Iterable[global___PartitionDataUri] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["data_uuid", b"data_uuid", "part_data_uris", b"part_data_uris"]) -> None: ...

global___DataUri = DataUri

@typing.final
class EnclaveInfo(google.protobuf.message.Message):
    """/ 应用授权策略
     不同种类任务（如 XGB,LR 等）由不同种类的 Enclave 执行, 授权时用户可指定
     数据可被哪些 Enclave 执行.

     以下字段与 Intel SGX Enclave Identities 对应.
     验证过程中以下字段是 AND 的关系, 如果某个字段内容为空，则表示不验证
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    HEX_MRENCLAVE_FIELD_NUMBER: builtins.int
    HEX_MRSIGNER_FIELD_NUMBER: builtins.int
    HEX_PROD_ID_FIELD_NUMBER: builtins.int
    MIN_SVN_FIELD_NUMBER: builtins.int
    hex_mrenclave: builtins.str
    hex_mrsigner: builtins.str
    hex_prod_id: builtins.str
    min_svn: builtins.int
    def __init__(
        self,
        *,
        hex_mrenclave: builtins.str = ...,
        hex_mrsigner: builtins.str = ...,
        hex_prod_id: builtins.str = ...,
        min_svn: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["hex_mrenclave", b"hex_mrenclave", "hex_mrsigner", b"hex_mrsigner", "hex_prod_id", b"hex_prod_id", "min_svn", b"min_svn"]) -> None: ...

global___EnclaveInfo = EnclaveInfo

@typing.final
class DataAuth(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DATA_UUID_FIELD_NUMBER: builtins.int
    DATA_OWNER_ID_FIELD_NUMBER: builtins.int
    ALLOWED_INS_IDS_FIELD_NUMBER: builtins.int
    ALLOWED_APPS_FIELD_NUMBER: builtins.int
    OPERATORS_FIELD_NUMBER: builtins.int
    EXTRA_LIMITS_FIELD_NUMBER: builtins.int
    SIGNATURE_FIELD_NUMBER: builtins.int
    SCHEMA_FIELD_NUMBER: builtins.int
    data_uuid: builtins.str
    data_owner_id: builtins.str
    """数据提供者的公钥哈希"""
    extra_limits: builtins.str
    """内部服务: reserve field
    开源tee device:
    {
      "limit_functions":
      [
         {
            "func": base64(sha256(serialized(func)))
         }
      ]
    }
    """
    signature: builtins.bytes
    """数据 owner 签名
    SIG(data_uuid||allowed_ins_ids||allowed_apps||operators||extra_limits||optional_schema)
    """
    @property
    def allowed_ins_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """被授权使用数据的机构公钥哈希"""

    @property
    def allowed_apps(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___EnclaveInfo]:
        """被授权使用的应用信息"""

    @property
    def operators(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """XGB/LR"""

    @property
    def schema(self) -> global___Schema: ...
    def __init__(
        self,
        *,
        data_uuid: builtins.str = ...,
        data_owner_id: builtins.str = ...,
        allowed_ins_ids: collections.abc.Iterable[builtins.str] | None = ...,
        allowed_apps: collections.abc.Iterable[global___EnclaveInfo] | None = ...,
        operators: collections.abc.Iterable[builtins.str] | None = ...,
        extra_limits: builtins.str = ...,
        signature: builtins.bytes = ...,
        schema: global___Schema | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["optional_schema", b"optional_schema", "schema", b"schema"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["allowed_apps", b"allowed_apps", "allowed_ins_ids", b"allowed_ins_ids", "data_owner_id", b"data_owner_id", "data_uuid", b"data_uuid", "extra_limits", b"extra_limits", "operators", b"operators", "optional_schema", b"optional_schema", "schema", b"schema", "signature", b"signature"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["optional_schema", b"optional_schema"]) -> typing.Literal["schema"] | None: ...

global___DataAuth = DataAuth

@typing.final
class ExportAuth(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DATA_UUID_FIELD_NUMBER: builtins.int
    GRANTER_INS_ID_FIELD_NUMBER: builtins.int
    ALLOWED_INS_IDS_FIELD_NUMBER: builtins.int
    SIGNATURE_FIELD_NUMBER: builtins.int
    data_uuid: builtins.str
    granter_ins_id: builtins.str
    signature: builtins.bytes
    """granter_ins签名
    SIG(data_uuid || granter_inst_id || allowed_ins_ids)
    """
    @property
    def allowed_ins_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]: ...
    def __init__(
        self,
        *,
        data_uuid: builtins.str = ...,
        granter_ins_id: builtins.str = ...,
        allowed_ins_ids: collections.abc.Iterable[builtins.str] | None = ...,
        signature: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["allowed_ins_ids", b"allowed_ins_ids", "data_uuid", b"data_uuid", "granter_ins_id", b"granter_ins_id", "signature", b"signature"]) -> None: ...

global___ExportAuth = ExportAuth

@typing.final
class DataAccessToken(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    STORAGE_TYPE_FIELD_NUMBER: builtins.int
    ACCESS_INFO_FIELD_NUMBER: builtins.int
    EXPIRATION_FIELD_NUMBER: builtins.int
    storage_type: builtins.str
    """目前支持 `oss`"""
    expiration: builtins.str
    """time format
    yyyy-MM-dd'T'HH:mm:ss.SSSZ
    ex. 2022-09-22T22:02:59.360UTC+08:00
    """
    @property
    def access_info(self) -> google.protobuf.any_pb2.Any:
        """上传数据所需要的鉴权信息：
          oss: 见 `OssInfo`
        """

    def __init__(
        self,
        *,
        storage_type: builtins.str = ...,
        access_info: google.protobuf.any_pb2.Any | None = ...,
        expiration: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["access_info", b"access_info"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["access_info", b"access_info", "expiration", b"expiration", "storage_type", b"storage_type"]) -> None: ...

global___DataAccessToken = DataAccessToken

@typing.final
class OssInfo(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ENDPOINT_FIELD_NUMBER: builtins.int
    BUCKET_FIELD_NUMBER: builtins.int
    STS_ACCESS_KEY_ID_FIELD_NUMBER: builtins.int
    STS_ACCESS_KEY_SECRET_FIELD_NUMBER: builtins.int
    STS_SECURITY_TOKEN_FIELD_NUMBER: builtins.int
    endpoint: builtins.str
    bucket: builtins.str
    sts_access_key_id: builtins.str
    """temporary credential for accessing oss"""
    sts_access_key_secret: builtins.str
    sts_security_token: builtins.str
    def __init__(
        self,
        *,
        endpoint: builtins.str = ...,
        bucket: builtins.str = ...,
        sts_access_key_id: builtins.str = ...,
        sts_access_key_secret: builtins.str = ...,
        sts_security_token: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["bucket", b"bucket", "endpoint", b"endpoint", "sts_access_key_id", b"sts_access_key_id", "sts_access_key_secret", b"sts_access_key_secret", "sts_security_token", b"sts_security_token"]) -> None: ...

global___OssInfo = OssInfo
