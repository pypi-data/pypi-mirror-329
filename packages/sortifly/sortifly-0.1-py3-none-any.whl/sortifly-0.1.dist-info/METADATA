Metadata-Version: 2.1
Name: sortifly
Version: 0.1
Summary: A collection of sorting algorithms in Python
Home-page: https://github.com/sidge4real/sortipy
Author: Lukas Van der Spiegel
Author-email: 
Classifier: Programming Language :: Python :: 3
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Requires-Python: >=3.6
Description-Content-Type: text/markdown
License-File: license
Requires-Dist: matplotlib
Requires-Dist: numpy

# Sortify: A Python Package for Sorting Algorithms
Sortify is a Python package that includes a variety of sorting algorithms, implemented for educational and practical use. The package makes it easy to experiment with different sorting algorithms and compare their performances.

## Included Algorithms:
- Bubble Sort
- Insertion Sort
- Selection Sort
- Merge Sort
- Quick Sort
- Heap Sort
- Counting Sort
- Radix Sort
- Bucket Sort
- TimSort (Built-in in Python)
- Shell Sort
- Cocktail Shaker Sort
- Pigeonhole Sort
- Gnome Sort
- Bitonic Sort
- Pancake Sort
- Flashsort

Each algorithm is implemented as a separate function and can be used to sort a list of elements.

## Installation
To install sortify, use the following pip command:

pip install sortify

## Usage
Once the package is installed, you can use the sorting algorithms like this:

```Python
from sortify import bubble_sort, insertion_sort, selection_sort
```
### Sample list to be sorted
```Python
arr = [64, 34, 25, 12, 22, 11, 90]

# Use any sorting algorithm
sorted_arr_bubble = bubble_sort(arr)
print("Bubble Sort:", sorted_arr_bubble)

sorted_arr_insertion = insertion_sort(arr)
print("Insertion Sort:", sorted_arr_insertion)

sorted_arr_selection = selection_sort(arr)
print("Selection Sort:", sorted_arr_selection)
```

You can replace bubble_sort, insertion_sort, and selection_sort with any of the other sorting algorithms available in sortify.

### Available Sorting Algorithms
- **Bubble Sort:** A simple comparison-based algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if needed.
Insertion Sort: Sorts the list by building a sorted portion one item at a time.

- **Selection Sort:** Repeatedly selects the smallest element from the unsorted part and swaps it to the sorted portion.

- **Merge Sort:** A divide-and-conquer algorithm that splits the list and merges the sorted sublists.

- **Quick Sort:** A divide-and-conquer algorithm that picks a pivot and sorts elements around it.

- **Heap Sort:** Uses a binary heap data structure to sort the elements.
Counting Sort: A non-comparison-based sorting algorithm that counts occurrences of each element.

- **Radix Sort:** Sorts elements by processing their digits or bits.
Bucket Sort: Distributes the elements into different buckets, sorts each bucket, and combines them.

- **TimSort:** Python's built-in sorting algorithm (used internally by the sorted() function).

- **Shell Sort:** An improvement of insertion sort, allowing the exchange of elements far apart.

- **Cocktail Shaker Sort:** A bidirectional variation of bubble sort.
- **Pigeonhole Sort:** A counting sort algorithm based on the pigeonhole principle.
- **Gnome Sort:** A comparison-based algorithm similar to insertion sort.
- **Bitonic Sort:** A parallel algorithm that sorts by dividing the list into bitonic sequences.
- **Pancake Sort:** A sorting algorithm where the only operation allowed is flipping subarrays.
- **Flashsort:** A distribution-based sorting algorithm that performs faster for uniformly distributed data.

```Python
from sortify import flash_sort

arr = [3, 1, 2, 5, 4]
sorted_arr_flash = flash_sort(arr)
print("Flash Sort:", sorted_arr_flash)
```

### Time and Space Complexity
Each algorithm has its own time and space complexity. Some common examples include:
- Bubble Sort: Worst case time complexity is O(nÂ²) and space complexity is O(1).
- Quick Sort: Average case time complexity is O(n log n) and worst-case is O(nÂ²).

For each algorithm, you can refer to the individual functions for a detailed explanation of time and space complexities.

## Contributers
- Lukas Van der Spiegel

## License
This project is licensed under the MIT License - see the LICENSE file for details. Wich means everyone can use this for free, without any conditions.

I made it originaly from code I've been writing for my own educational purpose. I made it quickly an acceable package for everyone. Why wasting code that becoming dusty on my pc or github profile?ðŸ˜œ

Yes, I used AI to write & code faster. Why not? ðŸ™ƒ
