# flake8: noqa
# fmt: off
# mypy: disable-error-code="no-any-return, no-untyped-call, misc, type-arg"
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^1.2.0
import base64
import dataclasses
import decimal
import typing
from abc import ABC, abstractmethod

import algokit_utils
import algosdk
from algosdk.v2client import models
from algosdk.atomic_transaction_composer import (
    AtomicTransactionComposer,
    AtomicTransactionResponse,
    SimulateAtomicTransactionResponse,
    TransactionSigner,
    TransactionWithSigner
)

_APP_SPEC_JSON = r"""{
    "hints": {
        "contract_create(address,address,uint64)uint64": {
            "call_config": {
                "no_op": "CREATE"
            }
        },
        "contract_setup(byte[32],(uint64,uint64,uint64,uint64,address,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,(uint64,uint64)[2]),uint64)void": {
            "structs": {
                "delegation_terms_general": {
                    "name": "DelegationTermsGeneral",
                    "elements": [
                        [
                            "commission",
                            "uint64"
                        ],
                        [
                            "fee_round",
                            "uint64"
                        ],
                        [
                            "fee_setup",
                            "uint64"
                        ],
                        [
                            "fee_asset_id",
                            "uint64"
                        ],
                        [
                            "partner_address",
                            "address"
                        ],
                        [
                            "fee_round_partner",
                            "uint64"
                        ],
                        [
                            "fee_setup_partner",
                            "uint64"
                        ],
                        [
                            "rounds_setup",
                            "uint64"
                        ],
                        [
                            "rounds_confirm",
                            "uint64"
                        ]
                    ]
                },
                "delegation_terms_balance": {
                    "name": "DelegationTermsBalance",
                    "elements": [
                        [
                            "stake_max",
                            "uint64"
                        ],
                        [
                            "cnt_breach_del_max",
                            "uint64"
                        ],
                        [
                            "rounds_breach",
                            "uint64"
                        ],
                        [
                            "gating_asa_list",
                            "(uint64,uint64)[2]"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "contract_pay(txn)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "keys_confirm(address)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "keys_not_confirmed()(address,byte[100])": {
            "structs": {
                "output": {
                    "name": "Message",
                    "elements": [
                        [
                            "del_manager",
                            "address"
                        ],
                        [
                            "msg",
                            "byte[100]"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "keys_not_submitted()(address,byte[100])": {
            "structs": {
                "output": {
                    "name": "Message",
                    "elements": [
                        [
                            "del_manager",
                            "address"
                        ],
                        [
                            "msg",
                            "byte[100]"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "keys_submit((uint64,uint64,uint64,byte[32],byte[32],byte[64],address))((uint64,uint64,uint64),address,byte[100])": {
            "structs": {
                "key_reg_txn_info": {
                    "name": "KeyRegTxnInfo",
                    "elements": [
                        [
                            "vote_first",
                            "uint64"
                        ],
                        [
                            "vote_last",
                            "uint64"
                        ],
                        [
                            "vote_key_dilution",
                            "uint64"
                        ],
                        [
                            "vote_pk",
                            "byte[32]"
                        ],
                        [
                            "selection_pk",
                            "byte[32]"
                        ],
                        [
                            "state_proof_pk",
                            "byte[64]"
                        ],
                        [
                            "sender",
                            "address"
                        ]
                    ]
                },
                "output": {
                    "name": "EarningsDistributionAndMessage",
                    "elements": [
                        [
                            "earnings_distribution",
                            "(uint64,uint64,uint64)"
                        ],
                        [
                            "del_manager",
                            "address"
                        ],
                        [
                            "msg",
                            "byte[100]"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "breach_limits()(bool,(uint64,uint64,uint64),address,byte[100])": {
            "structs": {
                "output": {
                    "name": "BreachLimitsReturn",
                    "elements": [
                        [
                            "max_breach_reached",
                            "bool"
                        ],
                        [
                            "earnings_distribution",
                            "(uint64,uint64,uint64)"
                        ],
                        [
                            "del_manager",
                            "address"
                        ],
                        [
                            "msg",
                            "byte[100]"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "breach_pay()(address,byte[100])": {
            "structs": {
                "output": {
                    "name": "Message",
                    "elements": [
                        [
                            "del_manager",
                            "address"
                        ],
                        [
                            "msg",
                            "byte[100]"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "breach_suspended()((uint64,uint64,uint64),address,byte[100])": {
            "structs": {
                "output": {
                    "name": "EarningsDistributionAndMessage",
                    "elements": [
                        [
                            "earnings_distribution",
                            "(uint64,uint64,uint64)"
                        ],
                        [
                            "del_manager",
                            "address"
                        ],
                        [
                            "msg",
                            "byte[100]"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "contract_claim()(uint64,uint64,uint64)": {
            "structs": {
                "output": {
                    "name": "EarningsDistribution",
                    "elements": [
                        [
                            "user",
                            "uint64"
                        ],
                        [
                            "platform",
                            "uint64"
                        ],
                        [
                            "asset_id",
                            "uint64"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "contract_expired()((uint64,uint64,uint64),address,byte[100])": {
            "structs": {
                "output": {
                    "name": "EarningsDistributionAndMessage",
                    "elements": [
                        [
                            "earnings_distribution",
                            "(uint64,uint64,uint64)"
                        ],
                        [
                            "del_manager",
                            "address"
                        ],
                        [
                            "msg",
                            "byte[100]"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "contract_withdraw(address)(uint64,uint64,uint64)": {
            "structs": {
                "output": {
                    "name": "EarningsDistribution",
                    "elements": [
                        [
                            "user",
                            "uint64"
                        ],
                        [
                            "platform",
                            "uint64"
                        ],
                        [
                            "asset_id",
                            "uint64"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "contract_delete(address)(uint64,uint64)": {
            "structs": {
                "output": {
                    "name": "ContractDeleteReturn",
                    "elements": [
                        [
                            "remaining_balance",
                            "uint64"
                        ],
                        [
                            "asset_id",
                            "uint64"
                        ]
                    ]
                }
            },
            "call_config": {
                "delete_application": "CALL"
            }
        },
        "contract_report_expiry_soon(uint64,uint64)(address,byte[100])": {
            "structs": {
                "output": {
                    "name": "Message",
                    "elements": [
                        [
                            "del_manager",
                            "address"
                        ],
                        [
                            "msg",
                            "byte[100]"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        }
    },
    "source": {
        "approval": "I3ByYWdtYSB2ZXJzaW9uIDExCgpzbWFydF9jb250cmFjdHMuZGVsZWdhdG9yX2NvbnRyYWN0LmNvbnRyYWN0LkRlbGVnYXRvckNvbnRyYWN0LmFwcHJvdmFsX3Byb2dyYW06CiAgICBpbnRjYmxvY2sgMCAxIDQgMTYKICAgIGJ5dGVjYmxvY2sgIkciICJzdGF0ZSIgImRlbF9tYW5hZ2VyIiAicm91bmRfZW5kIiAweDE1MWY3Yzc1ICJyb3VuZF9zdGFydCIgMHgwNSAiZGVsX2JlbmVmaWNpYXJ5IiAicm91bmRfZW5kZWQiICJyb3VuZF9jbGFpbV9sYXN0IiAiZmVlX29wZXJhdGlvbmFsIiAiZmVlX29wZXJhdGlvbmFsX3BhcnRuZXIiICJCIiAiY250X2JyZWFjaF9kZWwiIDB4MDMgMHgwNCAicm91bmRfYnJlYWNoX2xhc3QiICJub3RpY2Vib2FyZF9hcHBfaWQiICJ2YWxpZGF0b3JfYWRfYXBwX2lkIiAweDAwICJyb3VuZF9leHBpcnlfc29vbl9sYXN0IiAweDEwICJ2b3RlX2tleV9kaWx1dGlvbiIgInNlbF9rZXkiICJ2b3RlX2tleSIgInN0YXRlX3Byb29mX2tleSIgInRjX3NoYTI1NiIKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBibnogbWFpbl9hZnRlcl9pZl9lbHNlQDIKICAgIGNhbGxzdWIgX19pbml0X18KCm1haW5fYWZ0ZXJfaWZfZWxzZUAyOgogICAgY2FsbHN1YiBfX3B1eWFfYXJjNF9yb3V0ZXJfXwogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmRlbGVnYXRvcl9jb250cmFjdC5jb250cmFjdC5EZWxlZ2F0b3JDb250cmFjdC5fX2luaXRfXygpIC0+IHZvaWQ6Cl9faW5pdF9fOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyNzgKICAgIC8vIGRlZiBfX2luaXRfXyhzZWxmKSAtPiBOb25lOgogICAgcHJvdG8gMCAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjI4MwogICAgLy8gc2VsZi5ub3RpY2Vib2FyZF9hcHBfaWQgPSBVSW50NjQoMCkKICAgIGJ5dGVjIDE3IC8vICJub3RpY2Vib2FyZF9hcHBfaWQiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6Mjg0CiAgICAvLyBzZWxmLnZhbGlkYXRvcl9hZF9hcHBfaWQgPSBVSW50NjQoMCkKICAgIGJ5dGVjIDE4IC8vICJ2YWxpZGF0b3JfYWRfYXBwX2lkIgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjI4NwogICAgLy8gRGVsZWdhdGlvblRlcm1zR2VuZXJhbC5mcm9tX2J5dGVzKG9wLmJ6ZXJvKDk2KSksCiAgICBwdXNoaW50IDk2IC8vIDk2CiAgICBiemVybwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyODgKICAgIC8vIGtleT0iRyIsCiAgICBieXRlY18wIC8vICJHIgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyODYtMjkwCiAgICAvLyBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbCA9IEdsb2JhbFN0YXRlKAogICAgLy8gICAgIERlbGVnYXRpb25UZXJtc0dlbmVyYWwuZnJvbV9ieXRlcyhvcC5iemVybyg5NikpLAogICAgLy8gICAgIGtleT0iRyIsCiAgICAvLyAgICAgZGVzY3JpcHRpb249IkdlbmVyYWwgZGVsZWdhdGlvbiB0ZXJtcy4iCiAgICAvLyApCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyOTEKICAgIC8vIHNlbGYuZmVlX29wZXJhdGlvbmFsID0gVUludDY0KDApCiAgICBieXRlYyAxMCAvLyAiZmVlX29wZXJhdGlvbmFsIgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjI5MgogICAgLy8gc2VsZi5mZWVfb3BlcmF0aW9uYWxfcGFydG5lciA9IFVJbnQ2NCgwKQogICAgYnl0ZWMgMTEgLy8gImZlZV9vcGVyYXRpb25hbF9wYXJ0bmVyIgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjI5NAogICAgLy8gRGVsZWdhdGlvblRlcm1zQmFsYW5jZS5mcm9tX2J5dGVzKG9wLmJ6ZXJvKDU2KSksCiAgICBwdXNoaW50IDU2IC8vIDU2CiAgICBiemVybwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyOTUKICAgIC8vIGtleT0iQiIsCiAgICBieXRlYyAxMiAvLyAiQiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MjkzLTI5NwogICAgLy8gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2JhbGFuY2UgPSBHbG9iYWxTdGF0ZSgKICAgIC8vICAgICBEZWxlZ2F0aW9uVGVybXNCYWxhbmNlLmZyb21fYnl0ZXMob3AuYnplcm8oNTYpKSwKICAgIC8vICAgICBrZXk9IkIiLAogICAgLy8gICAgIGRlc2NyaXB0aW9uPSJCYWxhbmNlIHJlbGF0ZWQgZGVsZWdhdGlvbiB0ZXJtcy4iCiAgICAvLyApCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyOTkKICAgIC8vIHNlbGYuZGVsX21hbmFnZXIgPSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICBieXRlY18yIC8vICJkZWxfbWFuYWdlciIKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MzAwCiAgICAvLyBzZWxmLmRlbF9iZW5lZmljaWFyeSA9IEdsb2JhbC56ZXJvX2FkZHJlc3MKICAgIGJ5dGVjIDcgLy8gImRlbF9iZW5lZmljaWFyeSIKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MzAyCiAgICAvLyBzZWxmLnJvdW5kX3N0YXJ0ID0gVUludDY0KDApCiAgICBieXRlYyA1IC8vICJyb3VuZF9zdGFydCIKICAgIGludGNfMCAvLyAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTozMDMKICAgIC8vIHNlbGYucm91bmRfZW5kID0gVUludDY0KDApCiAgICBieXRlY18zIC8vICJyb3VuZF9lbmQiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MzA0CiAgICAvLyBzZWxmLnJvdW5kX2VuZGVkID0gVUludDY0KDApCiAgICBieXRlYyA4IC8vICJyb3VuZF9lbmRlZCIKICAgIGludGNfMCAvLyAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTozMDYKICAgIC8vIHNlbGYudm90ZV9rZXlfZGlsdXRpb24gPSBVSW50NjQoMCkKICAgIGJ5dGVjIDIyIC8vICJ2b3RlX2tleV9kaWx1dGlvbiIKICAgIGludGNfMCAvLyAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTozMDcKICAgIC8vIHNlbGYuc2VsX2tleSA9IFNlbFBrLmZyb21fYnl0ZXMob3AuYnplcm8oMzIpKQogICAgcHVzaGludCAzMiAvLyAzMgogICAgYnplcm8KICAgIGJ5dGVjIDIzIC8vICJzZWxfa2V5IgogICAgZGlnIDEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjMwOAogICAgLy8gc2VsZi52b3RlX2tleSA9IFZvdGVQay5mcm9tX2J5dGVzKG9wLmJ6ZXJvKDMyKSkKICAgIGJ5dGVjIDI0IC8vICJ2b3RlX2tleSIKICAgIGRpZyAxCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTozMDkKICAgIC8vIHNlbGYuc3RhdGVfcHJvb2Zfa2V5ID0gU3RhdGVQcm9vZlBrLmZyb21fYnl0ZXMob3AuYnplcm8oNjQpKQogICAgcHVzaGludCA2NCAvLyA2NAogICAgYnplcm8KICAgIGJ5dGVjIDI1IC8vICJzdGF0ZV9wcm9vZl9rZXkiCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTozMTEKICAgIC8vIHNlbGYuc3RhdGUgPSBCeXRlcyhTVEFURV9OT05FKQogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBieXRlYyAxOSAvLyAweDAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTozMTMKICAgIC8vIHNlbGYudGNfc2hhMjU2ID0gU2hhMjU2LmZyb21fYnl0ZXMob3AuYnplcm8oMzIpKQogICAgYnl0ZWMgMjYgLy8gInRjX3NoYTI1NiIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjMxNQogICAgLy8gc2VsZi5jbnRfYnJlYWNoX2RlbCA9IFVJbnQ2NCgwKQogICAgYnl0ZWMgMTMgLy8gImNudF9icmVhY2hfZGVsIgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjMxNgogICAgLy8gc2VsZi5yb3VuZF9icmVhY2hfbGFzdCA9IFVJbnQ2NCgwKQogICAgYnl0ZWMgMTYgLy8gInJvdW5kX2JyZWFjaF9sYXN0IgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjMxOAogICAgLy8gc2VsZi5yb3VuZF9jbGFpbV9sYXN0ID0gVUludDY0KDApCiAgICBieXRlYyA5IC8vICJyb3VuZF9jbGFpbV9sYXN0IgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjMyMAogICAgLy8gc2VsZi5yb3VuZF9leHBpcnlfc29vbl9sYXN0ID0gVUludDY0KDApCiAgICBieXRlYyAyMCAvLyAicm91bmRfZXhwaXJ5X3Nvb25fbGFzdCIKICAgIGludGNfMCAvLyAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmRlbGVnYXRvcl9jb250cmFjdC5jb250cmFjdC5EZWxlZ2F0b3JDb250cmFjdC5fX3B1eWFfYXJjNF9yb3V0ZXJfXygpIC0+IHVpbnQ2NDoKX19wdXlhX2FyYzRfcm91dGVyX186CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwNC0xMDUKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBEZWxlZ2F0b3JDb250cmFjdChBUkM0Q29udHJhY3QsIGF2bV92ZXJzaW9uPTExKToKICAgIHByb3RvIDAgMQogICAgdHhuIE51bUFwcEFyZ3MKICAgIGJ6IF9fcHV5YV9hcmM0X3JvdXRlcl9fX2FmdGVyX2lmX2Vsc2VAMjAKICAgIHB1c2hieXRlc3MgMHhkMWJlY2NjZSAweDdkM2RiNDc0IDB4YjQ3ZWY5ZWIgMHhjYWViMWE3YiAweDI2MWJkMTk5IDB4ZmU4MTFhZTcgMHgxZjMzOTlhOCAweGMxNzczZWUwIDB4OTUxNjI0NWUgMHg5MDQ0ZTIxZiAweDI2ZjU5YTQ2IDB4Yjg4MzIyYmIgMHhmNTNiOTVjZCAweGYyZTY3OTM0IDB4ZWFmYTFlMTUgLy8gbWV0aG9kICJjb250cmFjdF9jcmVhdGUoYWRkcmVzcyxhZGRyZXNzLHVpbnQ2NCl1aW50NjQiLCBtZXRob2QgImNvbnRyYWN0X3NldHVwKGJ5dGVbMzJdLCh1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpLCh1aW50NjQsdWludDY0LHVpbnQ2NCwodWludDY0LHVpbnQ2NClbMl0pLHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJjb250cmFjdF9wYXkodHhuKXZvaWQiLCBtZXRob2QgImtleXNfY29uZmlybShhZGRyZXNzKXZvaWQiLCBtZXRob2QgImtleXNfbm90X2NvbmZpcm1lZCgpKGFkZHJlc3MsYnl0ZVsxMDBdKSIsIG1ldGhvZCAia2V5c19ub3Rfc3VibWl0dGVkKCkoYWRkcmVzcyxieXRlWzEwMF0pIiwgbWV0aG9kICJrZXlzX3N1Ym1pdCgodWludDY0LHVpbnQ2NCx1aW50NjQsYnl0ZVszMl0sYnl0ZVszMl0sYnl0ZVs2NF0sYWRkcmVzcykpKCh1aW50NjQsdWludDY0LHVpbnQ2NCksYWRkcmVzcyxieXRlWzEwMF0pIiwgbWV0aG9kICJicmVhY2hfbGltaXRzKCkoYm9vbCwodWludDY0LHVpbnQ2NCx1aW50NjQpLGFkZHJlc3MsYnl0ZVsxMDBdKSIsIG1ldGhvZCAiYnJlYWNoX3BheSgpKGFkZHJlc3MsYnl0ZVsxMDBdKSIsIG1ldGhvZCAiYnJlYWNoX3N1c3BlbmRlZCgpKCh1aW50NjQsdWludDY0LHVpbnQ2NCksYWRkcmVzcyxieXRlWzEwMF0pIiwgbWV0aG9kICJjb250cmFjdF9jbGFpbSgpKHVpbnQ2NCx1aW50NjQsdWludDY0KSIsIG1ldGhvZCAiY29udHJhY3RfZXhwaXJlZCgpKCh1aW50NjQsdWludDY0LHVpbnQ2NCksYWRkcmVzcyxieXRlWzEwMF0pIiwgbWV0aG9kICJjb250cmFjdF93aXRoZHJhdyhhZGRyZXNzKSh1aW50NjQsdWludDY0LHVpbnQ2NCkiLCBtZXRob2QgImNvbnRyYWN0X2RlbGV0ZShhZGRyZXNzKSh1aW50NjQsdWludDY0KSIsIG1ldGhvZCAiY29udHJhY3RfcmVwb3J0X2V4cGlyeV9zb29uKHVpbnQ2NCx1aW50NjQpKGFkZHJlc3MsYnl0ZVsxMDBdKSIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIF9fcHV5YV9hcmM0X3JvdXRlcl9fX2NvbnRyYWN0X2NyZWF0ZV9yb3V0ZUAyIF9fcHV5YV9hcmM0X3JvdXRlcl9fX2NvbnRyYWN0X3NldHVwX3JvdXRlQDMgX19wdXlhX2FyYzRfcm91dGVyX19fY29udHJhY3RfcGF5X3JvdXRlQDQgX19wdXlhX2FyYzRfcm91dGVyX19fa2V5c19jb25maXJtX3JvdXRlQDUgX19wdXlhX2FyYzRfcm91dGVyX19fa2V5c19ub3RfY29uZmlybWVkX3JvdXRlQDYgX19wdXlhX2FyYzRfcm91dGVyX19fa2V5c19ub3Rfc3VibWl0dGVkX3JvdXRlQDcgX19wdXlhX2FyYzRfcm91dGVyX19fa2V5c19zdWJtaXRfcm91dGVAOCBfX3B1eWFfYXJjNF9yb3V0ZXJfX19icmVhY2hfbGltaXRzX3JvdXRlQDkgX19wdXlhX2FyYzRfcm91dGVyX19fYnJlYWNoX3BheV9yb3V0ZUAxMCBfX3B1eWFfYXJjNF9yb3V0ZXJfX19icmVhY2hfc3VzcGVuZGVkX3JvdXRlQDExIF9fcHV5YV9hcmM0X3JvdXRlcl9fX2NvbnRyYWN0X2NsYWltX3JvdXRlQDEyIF9fcHV5YV9hcmM0X3JvdXRlcl9fX2NvbnRyYWN0X2V4cGlyZWRfcm91dGVAMTMgX19wdXlhX2FyYzRfcm91dGVyX19fY29udHJhY3Rfd2l0aGRyYXdfcm91dGVAMTQgX19wdXlhX2FyYzRfcm91dGVyX19fY29udHJhY3RfZGVsZXRlX3JvdXRlQDE1IF9fcHV5YV9hcmM0X3JvdXRlcl9fX2NvbnRyYWN0X3JlcG9ydF9leHBpcnlfc29vbl9yb3V0ZUAxNgogICAgaW50Y18wIC8vIDAKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fY29udHJhY3RfY3JlYXRlX3JvdXRlQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjMyMgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKGNyZWF0ZT0icmVxdWlyZSIpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgIQogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDQtMTA1CiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgRGVsZWdhdG9yQ29udHJhY3QoQVJDNENvbnRyYWN0LCBhdm1fdmVyc2lvbj0xMSk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjMyMgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKGNyZWF0ZT0icmVxdWlyZSIpCiAgICBjYWxsc3ViIGNvbnRyYWN0X2NyZWF0ZQogICAgYnl0ZWMgNCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fY29udHJhY3Rfc2V0dXBfcm91dGVAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MzYxCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwNC0xMDUKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBEZWxlZ2F0b3JDb250cmFjdChBUkM0Q29udHJhY3QsIGF2bV92ZXJzaW9uPTExKToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MzYxCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiBjb250cmFjdF9zZXR1cAogICAgaW50Y18xIC8vIDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fY29udHJhY3RfcGF5X3JvdXRlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQyNQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDQtMTA1CiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgRGVsZWdhdG9yQ29udHJhY3QoQVJDNENvbnRyYWN0LCBhdm1fdmVyc2lvbj0xMSk6CiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDI1CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiBjb250cmFjdF9wYXkKICAgIGludGNfMSAvLyAxCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX2tleXNfY29uZmlybV9yb3V0ZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo0NjcKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTA0LTEwNQogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIERlbGVnYXRvckNvbnRyYWN0KEFSQzRDb250cmFjdCwgYXZtX3ZlcnNpb249MTEpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo0NjcKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGtleXNfY29uZmlybQogICAgaW50Y18xIC8vIDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fa2V5c19ub3RfY29uZmlybWVkX3JvdXRlQDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjUwOQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiBrZXlzX25vdF9jb25maXJtZWQKICAgIGJ5dGVjIDQgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX2tleXNfbm90X3N1Ym1pdHRlZF9yb3V0ZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1NTQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIga2V5c19ub3Rfc3VibWl0dGVkCiAgICBieXRlYyA0IC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0c3ViCgpfX3B1eWFfYXJjNF9yb3V0ZXJfX19rZXlzX3N1Ym1pdF9yb3V0ZUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2MDAKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTA0LTEwNQogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIERlbGVnYXRvckNvbnRyYWN0KEFSQzRDb250cmFjdCwgYXZtX3ZlcnNpb249MTEpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2MDAKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGtleXNfc3VibWl0CiAgICBieXRlYyA0IC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0c3ViCgpfX3B1eWFfYXJjNF9yb3V0ZXJfX19icmVhY2hfbGltaXRzX3JvdXRlQDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjY2MQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiBicmVhY2hfbGltaXRzCiAgICBieXRlYyA0IC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0c3ViCgpfX3B1eWFfYXJjNF9yb3V0ZXJfX19icmVhY2hfcGF5X3JvdXRlQDEwOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3MTcKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIgYnJlYWNoX3BheQogICAgYnl0ZWMgNCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fYnJlYWNoX3N1c3BlbmRlZF9yb3V0ZUAxMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6Nzg3CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICBjYWxsc3ViIGJyZWFjaF9zdXNwZW5kZWQKICAgIGJ5dGVjIDQgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX2NvbnRyYWN0X2NsYWltX3JvdXRlQDEyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo4MzAKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIgY29udHJhY3RfY2xhaW0KICAgIGJ5dGVjIDQgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX2NvbnRyYWN0X2V4cGlyZWRfcm91dGVAMTM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojk4MAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiBjb250cmFjdF9leHBpcmVkCiAgICBieXRlYyA0IC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0c3ViCgpfX3B1eWFfYXJjNF9yb3V0ZXJfX19jb250cmFjdF93aXRoZHJhd19yb3V0ZUAxNDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTAxOAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDQtMTA1CiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgRGVsZWdhdG9yQ29udHJhY3QoQVJDNENvbnRyYWN0LCBhdm1fdmVyc2lvbj0xMSk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwMTgKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGNvbnRyYWN0X3dpdGhkcmF3CiAgICBieXRlYyA0IC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0c3ViCgpfX3B1eWFfYXJjNF9yb3V0ZXJfX19jb250cmFjdF9kZWxldGVfcm91dGVAMTU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwNTYKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChhbGxvd19hY3Rpb25zPVsiRGVsZXRlQXBwbGljYXRpb24iXSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgIHB1c2hpbnQgNSAvLyBEZWxldGVBcHBsaWNhdGlvbgogICAgPT0KICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IERlbGV0ZUFwcGxpY2F0aW9uCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTA0LTEwNQogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIERlbGVnYXRvckNvbnRyYWN0KEFSQzRDb250cmFjdCwgYXZtX3ZlcnNpb249MTEpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDU2CiAgICAvLyBAYXJjNC5hYmltZXRob2QoYWxsb3dfYWN0aW9ucz1bIkRlbGV0ZUFwcGxpY2F0aW9uIl0pCiAgICBjYWxsc3ViIGNvbnRyYWN0X2RlbGV0ZQogICAgYnl0ZWMgNCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fY29udHJhY3RfcmVwb3J0X2V4cGlyeV9zb29uX3JvdXRlQDE2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTE2CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwNC0xMDUKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBEZWxlZ2F0b3JDb250cmFjdChBUkM0Q29udHJhY3QsIGF2bV92ZXJzaW9uPTExKToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTExNgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgY29udHJhY3RfcmVwb3J0X2V4cGlyeV9zb29uCiAgICBieXRlYyA0IC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0c3ViCgpfX3B1eWFfYXJjNF9yb3V0ZXJfX19hZnRlcl9pZl9lbHNlQDIwOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDQtMTA1CiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgRGVsZWdhdG9yQ29udHJhY3QoQVJDNENvbnRyYWN0LCBhdm1fdmVyc2lvbj0xMSk6CiAgICBpbnRjXzAgLy8gMAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmRlbGVnYXRvcl9jb250cmFjdC5jb250cmFjdC5EZWxlZ2F0b3JDb250cmFjdC5jb250cmFjdF9jcmVhdGUoZGVsX21hbmFnZXI6IGJ5dGVzLCBkZWxfYmVuZWZpY2lhcnk6IGJ5dGVzLCBub3RpY2Vib2FyZF9hcHBfaWQ6IHVpbnQ2NCkgLT4gYnl0ZXM6CmNvbnRyYWN0X2NyZWF0ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MzIyLTMyOAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKGNyZWF0ZT0icmVxdWlyZSIpCiAgICAvLyBkZWYgY29udHJhY3RfY3JlYXRlKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZGVsX21hbmFnZXI6IGFyYzQuQWRkcmVzcywKICAgIC8vICAgICBkZWxfYmVuZWZpY2lhcnk6IGFyYzQuQWRkcmVzcywKICAgIC8vICAgICBub3RpY2Vib2FyZF9hcHBfaWQ6IFVJbnQ2NCwKICAgIC8vICkgLT4gYXJjNC5VSW50NjQ6CiAgICBwcm90byAzIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MzQ5LTM1MAogICAgLy8gIyBTZXQgZ2xvYmFsIHZhcmlhYmxlcwogICAgLy8gc2VsZi5ub3RpY2Vib2FyZF9hcHBfaWQgPSBub3RpY2Vib2FyZF9hcHBfaWQKICAgIGJ5dGVjIDE3IC8vICJub3RpY2Vib2FyZF9hcHBfaWQiCiAgICBmcmFtZV9kaWcgLTEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjM1MQogICAgLy8gc2VsZi52YWxpZGF0b3JfYWRfYXBwX2lkID0gR2xvYmFsLmNhbGxlcl9hcHBsaWNhdGlvbl9pZAogICAgYnl0ZWMgMTggLy8gInZhbGlkYXRvcl9hZF9hcHBfaWQiCiAgICBnbG9iYWwgQ2FsbGVyQXBwbGljYXRpb25JRAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MzUzCiAgICAvLyBzZWxmLmRlbF9tYW5hZ2VyID0gZGVsX21hbmFnZXIubmF0aXZlCiAgICBieXRlY18yIC8vICJkZWxfbWFuYWdlciIKICAgIGZyYW1lX2RpZyAtMwogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MzU0CiAgICAvLyBzZWxmLmRlbF9iZW5lZmljaWFyeSA9IGRlbF9iZW5lZmljaWFyeS5uYXRpdmUKICAgIGJ5dGVjIDcgLy8gImRlbF9iZW5lZmljaWFyeSIKICAgIGZyYW1lX2RpZyAtMgogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MzU2LTM1NwogICAgLy8gIyBDaGFuZ2Ugc3RhdGUgdG8gQ1JFQVRFRAogICAgLy8gc2VsZi5zdGF0ZSA9IEJ5dGVzKFNUQVRFX0NSRUFURUQpCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIHB1c2hieXRlcyAweDAxCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTozNTkKICAgIC8vIHJldHVybiBhcmM0LlVJbnQ2NChHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9pZC5pZCkKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25JRAogICAgaXRvYgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmRlbGVnYXRvcl9jb250cmFjdC5jb250cmFjdC5EZWxlZ2F0b3JDb250cmFjdC5jb250cmFjdF9zZXR1cCh0Y19zaGEyNTY6IGJ5dGVzLCBkZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWw6IGJ5dGVzLCBkZWxlZ2F0aW9uX3Rlcm1zX2JhbGFuY2U6IGJ5dGVzLCByb3VuZHNfZHVyYXRpb246IHVpbnQ2NCkgLT4gdm9pZDoKY29udHJhY3Rfc2V0dXA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjM2MS0zNjgKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgY29udHJhY3Rfc2V0dXAoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICB0Y19zaGEyNTY6IFNoYTI1NiwKICAgIC8vICAgICBkZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWw6IERlbGVnYXRpb25UZXJtc0dlbmVyYWwsCiAgICAvLyAgICAgZGVsZWdhdGlvbl90ZXJtc19iYWxhbmNlOiBEZWxlZ2F0aW9uVGVybXNCYWxhbmNlLAogICAgLy8gICAgIHJvdW5kc19kdXJhdGlvbjogVUludDY0LAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gNCAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjM4OAogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgRVJST1JfQ0FMTEVEX0JZX05PVF9DUkVBVE9SCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHNtYXJ0IGNvbnRyYWN0IGNyZWF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjM4OQogICAgLy8gYXNzZXJ0IHNlbGYuc3RhdGUgPT0gQnl0ZXMoU1RBVEVfQ1JFQVRFRCksIEVSUk9SX05PVF9TVEFURV9DUkVBVEVECiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdGUgZXhpc3RzCiAgICBwdXNoYnl0ZXMgMHgwMQogICAgPT0KICAgIGFzc2VydCAvLyBDYW5ub3QgYmUgY2FsbGVkIGZyb20gb3RoZXIgc3RhdGUgdGhhbiBDUkVBVEVELgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTozOTEKICAgIC8vIHNlbGYudGNfc2hhMjU2ID0gdGNfc2hhMjU2LmNvcHkoKQogICAgYnl0ZWMgMjYgLy8gInRjX3NoYTI1NiIKICAgIGZyYW1lX2RpZyAtNAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MzkyCiAgICAvLyBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZSA9IGRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC5jb3B5KCkKICAgIGJ5dGVjXzAgLy8gIkciCiAgICBmcmFtZV9kaWcgLTMKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjM5MwogICAgLy8gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2JhbGFuY2UudmFsdWUgPSBkZWxlZ2F0aW9uX3Rlcm1zX2JhbGFuY2UuY29weSgpCiAgICBieXRlYyAxMiAvLyAiQiIKICAgIGZyYW1lX2RpZyAtMgogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6Mzk1CiAgICAvLyBzZWxmLnJvdW5kX3N0YXJ0ID0gR2xvYmFsLnJvdW5kCiAgICBieXRlYyA1IC8vICJyb3VuZF9zdGFydCIKICAgIGdsb2JhbCBSb3VuZAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6Mzk2CiAgICAvLyBzZWxmLnJvdW5kX2VuZCA9IHNlbGYucm91bmRfc3RhcnQgKyByb3VuZHNfZHVyYXRpb24KICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA1IC8vICJyb3VuZF9zdGFydCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5yb3VuZF9zdGFydCBleGlzdHMKICAgIGZyYW1lX2RpZyAtMQogICAgKwogICAgYnl0ZWNfMyAvLyAicm91bmRfZW5kIgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6Mzk3CiAgICAvLyBzZWxmLnJvdW5kX2NsYWltX2xhc3QgPSBzZWxmLnJvdW5kX3N0YXJ0CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNSAvLyAicm91bmRfc3RhcnQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfc3RhcnQgZXhpc3RzCiAgICBieXRlYyA5IC8vICJyb3VuZF9jbGFpbV9sYXN0IgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDAxCiAgICAvLyBmZWVfcm91bmQ9c2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUuZmVlX3JvdW5kLm5hdGl2ZSwKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJHIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbCBleGlzdHMKICAgIGV4dHJhY3QgOCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo0MDIKICAgIC8vIHJvdW5kX2VuZD1zZWxmLnJvdW5kX2VuZCwKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18zIC8vICJyb3VuZF9lbmQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfZW5kIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo0MDMKICAgIC8vIHJvdW5kX3N0YXJ0PXNlbGYucm91bmRfc3RhcnQsCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNSAvLyAicm91bmRfc3RhcnQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfc3RhcnQgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjM5OS00MDQKICAgIC8vICMgQ2FsY3VsYXRlIG9wZXJhdGlvbmFsIGZlZQogICAgLy8gc2VsZi5mZWVfb3BlcmF0aW9uYWwgPSBjYWxjX2ZlZV9vcGVyYXRpb25hbCgKICAgIC8vICAgICBmZWVfcm91bmQ9c2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUuZmVlX3JvdW5kLm5hdGl2ZSwKICAgIC8vICAgICByb3VuZF9lbmQ9c2VsZi5yb3VuZF9lbmQsCiAgICAvLyAgICAgcm91bmRfc3RhcnQ9c2VsZi5yb3VuZF9zdGFydCwKICAgIC8vICkKICAgIGNhbGxzdWIgY2FsY19mZWVfb3BlcmF0aW9uYWwKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6Mzk5LTQwMAogICAgLy8gIyBDYWxjdWxhdGUgb3BlcmF0aW9uYWwgZmVlCiAgICAvLyBzZWxmLmZlZV9vcGVyYXRpb25hbCA9IGNhbGNfZmVlX29wZXJhdGlvbmFsKAogICAgYnl0ZWMgMTAgLy8gImZlZV9vcGVyYXRpb25hbCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6Mzk5LTQwNAogICAgLy8gIyBDYWxjdWxhdGUgb3BlcmF0aW9uYWwgZmVlCiAgICAvLyBzZWxmLmZlZV9vcGVyYXRpb25hbCA9IGNhbGNfZmVlX29wZXJhdGlvbmFsKAogICAgLy8gICAgIGZlZV9yb3VuZD1zZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5mZWVfcm91bmQubmF0aXZlLAogICAgLy8gICAgIHJvdW5kX2VuZD1zZWxmLnJvdW5kX2VuZCwKICAgIC8vICAgICByb3VuZF9zdGFydD1zZWxmLnJvdW5kX3N0YXJ0LAogICAgLy8gKQogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDA3CiAgICAvLyBmZWVfcm91bmQ9c2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUuZmVlX3JvdW5kX3BhcnRuZXIubmF0aXZlLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gIkciCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsIGV4aXN0cwogICAgZXh0cmFjdCA2NCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo0MDgKICAgIC8vIHJvdW5kX2VuZD1zZWxmLnJvdW5kX2VuZCwKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18zIC8vICJyb3VuZF9lbmQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfZW5kIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo0MDkKICAgIC8vIHJvdW5kX3N0YXJ0PXNlbGYucm91bmRfc3RhcnQsCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNSAvLyAicm91bmRfc3RhcnQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfc3RhcnQgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQwNS00MTAKICAgIC8vICMgQ2FsY3VsYXRlIHRoZSBwYXJ0bmVyIGNvbnZlbmllbmNlIG9wZXJhdGlvbmFsIGZlZQogICAgLy8gc2VsZi5mZWVfb3BlcmF0aW9uYWxfcGFydG5lciA9IGNhbGNfZmVlX29wZXJhdGlvbmFsKAogICAgLy8gICAgIGZlZV9yb3VuZD1zZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5mZWVfcm91bmRfcGFydG5lci5uYXRpdmUsCiAgICAvLyAgICAgcm91bmRfZW5kPXNlbGYucm91bmRfZW5kLAogICAgLy8gICAgIHJvdW5kX3N0YXJ0PXNlbGYucm91bmRfc3RhcnQsCiAgICAvLyApCiAgICBjYWxsc3ViIGNhbGNfZmVlX29wZXJhdGlvbmFsCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQwNS00MDYKICAgIC8vICMgQ2FsY3VsYXRlIHRoZSBwYXJ0bmVyIGNvbnZlbmllbmNlIG9wZXJhdGlvbmFsIGZlZQogICAgLy8gc2VsZi5mZWVfb3BlcmF0aW9uYWxfcGFydG5lciA9IGNhbGNfZmVlX29wZXJhdGlvbmFsKAogICAgYnl0ZWMgMTEgLy8gImZlZV9vcGVyYXRpb25hbF9wYXJ0bmVyIgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo0MDUtNDEwCiAgICAvLyAjIENhbGN1bGF0ZSB0aGUgcGFydG5lciBjb252ZW5pZW5jZSBvcGVyYXRpb25hbCBmZWUKICAgIC8vIHNlbGYuZmVlX29wZXJhdGlvbmFsX3BhcnRuZXIgPSBjYWxjX2ZlZV9vcGVyYXRpb25hbCgKICAgIC8vICAgICBmZWVfcm91bmQ9c2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUuZmVlX3JvdW5kX3BhcnRuZXIubmF0aXZlLAogICAgLy8gICAgIHJvdW5kX2VuZD1zZWxmLnJvdW5kX2VuZCwKICAgIC8vICAgICByb3VuZF9zdGFydD1zZWxmLnJvdW5kX3N0YXJ0LAogICAgLy8gKQogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDEyCiAgICAvLyBpZiBkZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwuZmVlX2Fzc2V0X2lkICE9IFVJbnQ2NChBTEdPX0FTQV9JRCk6CiAgICBmcmFtZV9kaWcgLTMKICAgIGV4dHJhY3QgMjQgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGl0b2IKICAgIGIhPQogICAgYnogY29udHJhY3Rfc2V0dXBfYWZ0ZXJfaWZfZWxzZUAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQxMy00MTgKICAgIC8vICMgT3B0IGluIHRvIHRoZSBhc3NldAogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgLy8gICAgIHhmZXJfYXNzZXQ9ZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsLmZlZV9hc3NldF9pZC5uYXRpdmUsCiAgICAvLyAgICAgYXNzZXRfcmVjZWl2ZXI9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIC8vICAgICBhc3NldF9hbW91bnQ9MCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDE1CiAgICAvLyB4ZmVyX2Fzc2V0PWRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC5mZWVfYXNzZXRfaWQubmF0aXZlLAogICAgZnJhbWVfZGlnIDAKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDE2CiAgICAvLyBhc3NldF9yZWNlaXZlcj1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDE3CiAgICAvLyBhc3NldF9hbW91bnQ9MCwKICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQxMy00MTQKICAgIC8vICMgT3B0IGluIHRvIHRoZSBhc3NldAogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgaW50Y18yIC8vIGF4ZmVyCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDEzLTQxOAogICAgLy8gIyBPcHQgaW4gdG8gdGhlIGFzc2V0CiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgeGZlcl9hc3NldD1kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwuZmVlX2Fzc2V0X2lkLm5hdGl2ZSwKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD0wLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKCmNvbnRyYWN0X3NldHVwX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDIwLTQyMQogICAgLy8gIyBDaGFuZ2Ugc3RhdGUgdG8gU0VUCiAgICAvLyBzZWxmLnN0YXRlID0gQnl0ZXMoU1RBVEVfU0VUKQogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBwdXNoYnl0ZXMgMHgwMgogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDIzCiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5oZWxwZXJzLmNvbW1vbi5jYWxjX2ZlZV9vcGVyYXRpb25hbChmZWVfcm91bmQ6IHVpbnQ2NCwgcm91bmRfZW5kOiB1aW50NjQsIHJvdW5kX3N0YXJ0OiB1aW50NjQpIC0+IHVpbnQ2NDoKY2FsY19mZWVfb3BlcmF0aW9uYWw6CiAgICAvLyBzbWFydF9jb250cmFjdHMvaGVscGVycy9jb21tb24ucHk6NjgwLTY4NgogICAgLy8gIyAtLS0tLS0tIEZ1bmN0aW9ucyAtLS0tLS0tCiAgICAvLyBAc3Vicm91dGluZQogICAgLy8gZGVmIGNhbGNfZmVlX29wZXJhdGlvbmFsKAogICAgLy8gICAgIGZlZV9yb3VuZDogVUludDY0LAogICAgLy8gICAgIHJvdW5kX2VuZDogVUludDY0LAogICAgLy8gICAgIHJvdW5kX3N0YXJ0OiBVSW50NjQsCiAgICAvLyApIC0+IFVJbnQ2NDoKICAgIHByb3RvIDMgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5OjcwNgogICAgLy8gcmV0dXJuIChmZWVfcm91bmQgKiAocm91bmRfZW5kIC0gcm91bmRfc3RhcnQpKSAvLyBVSW50NjQoRlJPTV9CQVNFX1RPX01JTExJX01VTFRJUExJRVIpCiAgICBmcmFtZV9kaWcgLTIKICAgIGZyYW1lX2RpZyAtMQogICAgLQogICAgZnJhbWVfZGlnIC0zCiAgICAqCiAgICBwdXNoaW50IDEwMDAgLy8gMTAwMAogICAgLwogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmRlbGVnYXRvcl9jb250cmFjdC5jb250cmFjdC5EZWxlZ2F0b3JDb250cmFjdC5jb250cmFjdF9wYXkodHhuOiB1aW50NjQpIC0+IHZvaWQ6CmNvbnRyYWN0X3BheToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDI1LTQyOQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBjb250cmFjdF9wYXkoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICB0eG46IGd0eG4uVHJhbnNhY3Rpb24sCiAgICAvLyApIC0+IE5vbmU6CiAgICBwcm90byAxIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDM5CiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCBFUlJPUl9DQUxMRURfQllfTk9UX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDQwCiAgICAvLyBhc3NlcnQgc2VsZi5zdGF0ZSA9PSBCeXRlcyhTVEFURV9TRVQpLCBFUlJPUl9OT1RfU1RBVEVfU0VUCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdGUgZXhpc3RzCiAgICBwdXNoYnl0ZXMgMHgwMgogICAgPT0KICAgIGFzc2VydCAvLyBDYW5ub3QgYmUgY2FsbGVkIGZyb20gb3RoZXIgc3RhdGUgdGhhbiBTRVQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ0Mi00NDMKICAgIC8vICMgQ2hlY2sgcGF5bWVudAogICAgLy8gYmFzZV9mZWUgPSBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5mZWVfc2V0dXAubmF0aXZlICsgc2VsZi5mZWVfb3BlcmF0aW9uYWwKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJHIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbCBleGlzdHMKICAgIGV4dHJhY3QgMTYgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMCAvLyAiZmVlX29wZXJhdGlvbmFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmZlZV9vcGVyYXRpb25hbCBleGlzdHMKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDQ0CiAgICAvLyBwYXJ0bmVyX2ZlZSA9IHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsLnZhbHVlLmZlZV9zZXR1cF9wYXJ0bmVyLm5hdGl2ZSArIHNlbGYuZmVlX29wZXJhdGlvbmFsX3BhcnRuZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJHIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbCBleGlzdHMKICAgIGV4dHJhY3QgNzIgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMSAvLyAiZmVlX29wZXJhdGlvbmFsX3BhcnRuZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZmVlX29wZXJhdGlvbmFsX3BhcnRuZXIgZXhpc3RzCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ0NQogICAgLy8gYW10X2V4cGVjdGVkID0gYmFzZV9mZWUgKyBwYXJ0bmVyX2ZlZQogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo0NDYKICAgIC8vIGlmIHR4bi50eXBlID09IFRyYW5zYWN0aW9uVHlwZS5QYXltZW50OgogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBUeXBlRW51bQogICAgZHVwCiAgICBjb3ZlciAyCiAgICBpbnRjXzEgLy8gcGF5CiAgICA9PQogICAgYnogY29udHJhY3RfcGF5X2Vsc2VfYm9keUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ0NwogICAgLy8gYXNzZXJ0IHR4bi5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLCBFUlJPUl9SRUNFSVZFUgogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBSZWNlaXZlcgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gVHJhbnNhY3Rpb24gbXVzdCBiZSB0byB0aGlzIGNvbnRyYWN0LgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo0NDkKICAgIC8vIGFzc2VydCBVSW50NjQoQUxHT19BU0FfSUQpID09IHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsLnZhbHVlLmZlZV9hc3NldF9pZCwgRVJST1JfQVNTRVRfSUQKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJHIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbCBleGlzdHMKICAgIGV4dHJhY3QgMjQgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGludGNfMCAvLyAwCiAgICBpdG9iCiAgICBiPT0KICAgIGFzc2VydCAvLyBTZW50IGFzc2V0IGRvZXNuJ3QgbWF0Y2ggdGhlIGFncmVlZCBvbmUuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ1MAogICAgLy8gYXNzZXJ0IHR4bi5hbW91bnQgPT0gYW10X2V4cGVjdGVkLCBFUlJPUl9BTU9VTlQKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgQW1vdW50CiAgICA9PQogICAgYXNzZXJ0IC8vIFNlbnQgYW1vdW50IGRvZXNuJ3QgbWF0Y2ggdGhlIGFncmVlZCBvbmUuCiAgICBiIGNvbnRyYWN0X3BheV9hZnRlcl9pZl9lbHNlQDYKCmNvbnRyYWN0X3BheV9lbHNlX2JvZHlAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDUxCiAgICAvLyBlbGlmIHR4bi50eXBlID09IFRyYW5zYWN0aW9uVHlwZS5Bc3NldFRyYW5zZmVyOgogICAgZnJhbWVfZGlnIDAKICAgIGludGNfMiAvLyBheGZlcgogICAgPT0KICAgIGFzc2VydCAvLyBUcmFuc2FjdGlvbiB0eXBlIG11c3QgYmUgZWl0aGVyIFBheW1lbnQgb3IgQXNzZXRUcmFuc2Zlci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDUyCiAgICAvLyBhc3NlcnQgdHhuLmFzc2V0X3JlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsIEVSUk9SX1JFQ0VJVkVSCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFzc2V0UmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIG11c3QgYmUgdG8gdGhpcyBjb250cmFjdC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDU0CiAgICAvLyBhc3NlcnQgdHhuLnhmZXJfYXNzZXQuaWQgPT0gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUuZmVlX2Fzc2V0X2lkLCBFUlJPUl9BU1NFVF9JRAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gIkciCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsIGV4aXN0cwogICAgZXh0cmFjdCAyNCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBYZmVyQXNzZXQKICAgIGl0b2IKICAgIGI9PQogICAgYXNzZXJ0IC8vIFNlbnQgYXNzZXQgZG9lc24ndCBtYXRjaCB0aGUgYWdyZWVkIG9uZS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDU1CiAgICAvLyBhc3NlcnQgdHhuLmFzc2V0X2Ftb3VudCA9PSBhbXRfZXhwZWN0ZWQsIEVSUk9SX0FNT1VOVAogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBBc3NldEFtb3VudAogICAgPT0KICAgIGFzc2VydCAvLyBTZW50IGFtb3VudCBkb2Vzbid0IG1hdGNoIHRoZSBhZ3JlZWQgb25lLgoKY29udHJhY3RfcGF5X2FmdGVyX2lmX2Vsc2VANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDU5LTQ2MAogICAgLy8gIyBDaGVjayBpZiBkZWxfYmVuZWZpY2lhcnkgaXMgZWxpZ2libGUgYWNjb3JkaW5nIHRvIHRoZSBhZ3JlZWQgdGVybXMKICAgIC8vIGFzc2VydCBzZWxmLl9pc19lbGlnaWJsZSgpLm5hdGl2ZSwgRVJST1JfTk9UX0VMSUdJQkxFCiAgICBjYWxsc3ViIF9pc19lbGlnaWJsZQogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgYXNzZXJ0IC8vIERlbGVnYXRvciBiZW5lZmljaWFyeSBpcyBub3QgZWxpZ2libGUgYWNjb3JkaW5nIHRvIHRoZSBhZ3JlZWQgbGltaXRzLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo0NjItNDYzCiAgICAvLyAjIENoYW5nZSBzdGF0ZSB0byBSRUFEWQogICAgLy8gc2VsZi5zdGF0ZSA9IEJ5dGVzKFNUQVRFX1JFQURZKQogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBieXRlYyAxNCAvLyAweDAzCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo0NjUKICAgIC8vIHJldHVybgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmRlbGVnYXRvcl9jb250cmFjdC5jb250cmFjdC5EZWxlZ2F0b3JDb250cmFjdC5faXNfZWxpZ2libGUoKSAtPiBieXRlczoKX2lzX2VsaWdpYmxlOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTU3LTExNjMKICAgIC8vICMgLS0tLS0gLS0tLS0gLS0tLS0gLS0tLS0tLS0tLS0tLS0tLS0tIC0tLS0tIC0tLS0tIC0tLS0tCiAgICAvLyAjIC0tLS0tIC0tLS0tIC0tLS0tIEludGVybmFsIGZ1bmN0aW9ucyAtLS0tLSAtLS0tLSAtLS0tLQogICAgLy8gIyAtLS0tLSAtLS0tLSAtLS0tLSAtLS0tLS0tLS0tLS0tLS0tLS0gLS0tLS0gLS0tLS0gLS0tLS0KICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgX2lzX2VsaWdpYmxlKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyApIC0+IGFyYzQuQm9vbDoKICAgIHByb3RvIDAgMQogICAgaW50Y18wIC8vIDAKICAgIGR1cAogICAgcHVzaGJ5dGVzICIiCiAgICBkdXBuIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTE3NS0xMTc2CiAgICAvLyAjIENoZWNrIEFMR08gbGltaXQKICAgIC8vIGFsZ29fYmFsID0gc2VsZi5kZWxfYmVuZWZpY2lhcnkuYmFsYW5jZQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDcgLy8gImRlbF9iZW5lZmljaWFyeSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxfYmVuZWZpY2lhcnkgZXhpc3RzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdEJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTc3CiAgICAvLyBpc19lbGlnaWJsZSA9IGlzX2VsaWdpYmxlIGFuZCAoYWxnb19iYWwgPD0gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2JhbGFuY2UudmFsdWUuc3Rha2VfbWF4KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDEyIC8vICJCIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbGVnYXRpb25fdGVybXNfYmFsYW5jZSBleGlzdHMKICAgIGV4dHJhY3QgMCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgc3dhcAogICAgaXRvYgogICAgYj49CiAgICBieiBfaXNfZWxpZ2libGVfYm9vbF9mYWxzZUAzCiAgICBpbnRjXzEgLy8gMQogICAgZnJhbWVfYnVyeSA1CiAgICBiIF9pc19lbGlnaWJsZV9ib29sX21lcmdlQDQKCl9pc19lbGlnaWJsZV9ib29sX2ZhbHNlQDM6CiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfYnVyeSA1CgpfaXNfZWxpZ2libGVfYm9vbF9tZXJnZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTc5LTExODAKICAgIC8vICMgQ2hlY2sgQVNBIGxpbWl0cwogICAgLy8gYXNhX2lkX2xpc3QgPSBzZWxmLmRlbGVnYXRpb25fdGVybXNfYmFsYW5jZS52YWx1ZS5nYXRpbmdfYXNhX2xpc3QuY29weSgpCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTIgLy8gIkIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19iYWxhbmNlIGV4aXN0cwogICAgZXh0cmFjdCAyNCAzMiAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGZyYW1lX2J1cnkgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTgxCiAgICAvLyBmb3IgaWR4IGluIHVyYW5nZShhc2FfaWRfbGlzdC5sZW5ndGgpOgogICAgaW50Y18wIC8vIDAKICAgIGZyYW1lX2J1cnkgNAoKX2lzX2VsaWdpYmxlX2Zvcl9oZWFkZXJANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTE4MQogICAgLy8gZm9yIGlkeCBpbiB1cmFuZ2UoYXNhX2lkX2xpc3QubGVuZ3RoKToKICAgIGZyYW1lX2RpZyA0CiAgICBwdXNoaW50IDIgLy8gMgogICAgPAogICAgYnogX2lzX2VsaWdpYmxlX2FmdGVyX2ZvckAxNwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTgyCiAgICAvLyBhc3NldF9pZCA9IGFzYV9pZF9saXN0W2lkeF0uaWQubmF0aXZlCiAgICBmcmFtZV9kaWcgNAogICAgaW50Y18zIC8vIDE2CiAgICAqCiAgICBmcmFtZV9kaWcgMAogICAgc3dhcAogICAgaW50Y18zIC8vIDE2CiAgICBleHRyYWN0MyAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGR1cAogICAgZnJhbWVfYnVyeSAxCiAgICBleHRyYWN0IDAgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGR1cAogICAgZnJhbWVfYnVyeSAzCiAgICBmcmFtZV9kaWcgNQogICAgZnJhbWVfYnVyeSA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjExODMKICAgIC8vIGlmIGFzc2V0X2lkICE9IEFMR09fQVNBX0lEOgogICAgYnogX2lzX2VsaWdpYmxlX2FmdGVyX2lmX2Vsc2VAMTUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTE4NQogICAgLy8gaWYgc2VsZi5kZWxfYmVuZWZpY2lhcnkuaXNfb3B0ZWRfaW4oYXNzZXQpOgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDcgLy8gImRlbF9iZW5lZmljaWFyeSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxfYmVuZWZpY2lhcnkgZXhpc3RzCiAgICBmcmFtZV9kaWcgMwogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCiAgICBidXJ5IDEKICAgIGJ6IF9pc19lbGlnaWJsZV9lbHNlX2JvZHlAOQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTg2CiAgICAvLyBhc2FfYmFsID0gYXNzZXQuYmFsYW5jZShzZWxmLmRlbF9iZW5lZmljaWFyeSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA3IC8vICJkZWxfYmVuZWZpY2lhcnkiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsX2JlbmVmaWNpYXJ5IGV4aXN0cwogICAgZnJhbWVfZGlnIDMKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgc3dhcAogICAgZnJhbWVfYnVyeSAyCiAgICBhc3NlcnQgLy8gYWNjb3VudCBvcHRlZCBpbnRvIGFzc2V0CiAgICBiIF9pc19lbGlnaWJsZV9hZnRlcl9pZl9lbHNlQDEwCgpfaXNfZWxpZ2libGVfZWxzZV9ib2R5QDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjExODgKICAgIC8vIGFzYV9iYWwgPSBVSW50NjQoMCkKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDIKCl9pc19lbGlnaWJsZV9hZnRlcl9pZl9lbHNlQDEwOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTg5CiAgICAvLyBpc19lbGlnaWJsZSA9IGlzX2VsaWdpYmxlIGFuZCAoYXNhX2JhbCA+PSBhc2FfaWRfbGlzdFtpZHhdLm1pbi5uYXRpdmUpCiAgICBmcmFtZV9kaWcgNQogICAgYnogX2lzX2VsaWdpYmxlX2Jvb2xfZmFsc2VAMTMKICAgIGZyYW1lX2RpZyAxCiAgICBleHRyYWN0IDggOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGZyYW1lX2RpZyAyCiAgICA8PQogICAgYnogX2lzX2VsaWdpYmxlX2Jvb2xfZmFsc2VAMTMKICAgIGludGNfMSAvLyAxCiAgICBmcmFtZV9idXJ5IDUKICAgIGIgX2lzX2VsaWdpYmxlX2Jvb2xfbWVyZ2VAMTQKCl9pc19lbGlnaWJsZV9ib29sX2ZhbHNlQDEzOgogICAgaW50Y18wIC8vIDAKICAgIGZyYW1lX2J1cnkgNQoKX2lzX2VsaWdpYmxlX2Jvb2xfbWVyZ2VAMTQ6CiAgICBmcmFtZV9kaWcgNQogICAgZnJhbWVfYnVyeSA2CgpfaXNfZWxpZ2libGVfYWZ0ZXJfaWZfZWxzZUAxNToKICAgIGZyYW1lX2RpZyA2CiAgICBmcmFtZV9idXJ5IDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTE4MQogICAgLy8gZm9yIGlkeCBpbiB1cmFuZ2UoYXNhX2lkX2xpc3QubGVuZ3RoKToKICAgIGZyYW1lX2RpZyA0CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgZnJhbWVfYnVyeSA0CiAgICBiIF9pc19lbGlnaWJsZV9mb3JfaGVhZGVyQDUKCl9pc19lbGlnaWJsZV9hZnRlcl9mb3JAMTc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjExOTEKICAgIC8vIHJldHVybiBhcmM0LkJvb2woaXNfZWxpZ2libGUpCiAgICBieXRlYyAxOSAvLyAweDAwCiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfZGlnIDUKICAgIHNldGJpdAogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuZGVsZWdhdG9yX2NvbnRyYWN0LmNvbnRyYWN0LkRlbGVnYXRvckNvbnRyYWN0LmtleXNfY29uZmlybShkZWxfbWFuYWdlcjogYnl0ZXMpIC0+IHZvaWQ6CmtleXNfY29uZmlybToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDY3LTQ3MQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBrZXlzX2NvbmZpcm0oCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBkZWxfbWFuYWdlcjogYXJjNC5BZGRyZXNzLAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ4MQogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgRVJST1JfQ0FMTEVEX0JZX05PVF9DUkVBVE9SCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHNtYXJ0IGNvbnRyYWN0IGNyZWF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ4MgogICAgLy8gYXNzZXJ0IHNlbGYuc3RhdGUgPT0gQnl0ZXMoU1RBVEVfU1VCTUlUVEVEKSwgRVJST1JfTk9UX1NUQVRFX1NVQk1JVFRFRAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gInN0YXRlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXRlIGV4aXN0cwogICAgYnl0ZWMgMTUgLy8gMHgwNAogICAgPT0KICAgIGFzc2VydCAvLyBDYW5ub3QgYmUgY2FsbGVkIGZyb20gb3RoZXIgc3RhdGUgdGhhbiBTVUJNSVRURUQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ4NAogICAgLy8gYXNzZXJ0IGRlbF9tYW5hZ2VyID09IHNlbGYuZGVsX21hbmFnZXIsIEVSUk9SX05PVF9NQU5BR0VSCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAiZGVsX21hbmFnZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsX21hbmFnZXIgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTEKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgYXBwcm92ZWQgYnkgZGVsZWdhdG9yIG1hbmFnZXIuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ4Ni00ODcKICAgIC8vICMgQ2hlY2sgaWYgY29uZmlybWF0aW9uIHdhcyBkb25lIGluIHRpbWUKICAgIC8vIGFzc2VydCBHbG9iYWwucm91bmQgPD0gKAogICAgZ2xvYmFsIFJvdW5kCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ4OAogICAgLy8gc2VsZi5yb3VuZF9zdGFydCArCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNSAvLyAicm91bmRfc3RhcnQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfc3RhcnQgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ4OQogICAgLy8gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUucm91bmRzX3NldHVwLm5hdGl2ZSArCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiRyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwgZXhpc3RzCiAgICBleHRyYWN0IDgwIDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ4OC00ODkKICAgIC8vIHNlbGYucm91bmRfc3RhcnQgKwogICAgLy8gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUucm91bmRzX3NldHVwLm5hdGl2ZSArCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ5MAogICAgLy8gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUucm91bmRzX2NvbmZpcm0ubmF0aXZlCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiRyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwgZXhpc3RzCiAgICBleHRyYWN0IDg4IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ4OC00OTAKICAgIC8vIHNlbGYucm91bmRfc3RhcnQgKwogICAgLy8gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUucm91bmRzX3NldHVwLm5hdGl2ZSArCiAgICAvLyBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5yb3VuZHNfY29uZmlybS5uYXRpdmUKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDg2LTQ5MAogICAgLy8gIyBDaGVjayBpZiBjb25maXJtYXRpb24gd2FzIGRvbmUgaW4gdGltZQogICAgLy8gYXNzZXJ0IEdsb2JhbC5yb3VuZCA8PSAoCiAgICAvLyAgICAgc2VsZi5yb3VuZF9zdGFydCArCiAgICAvLyAgICAgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUucm91bmRzX3NldHVwLm5hdGl2ZSArCiAgICAvLyAgICAgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUucm91bmRzX2NvbmZpcm0ubmF0aXZlCiAgICA8PQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo0ODYtNDkxCiAgICAvLyAjIENoZWNrIGlmIGNvbmZpcm1hdGlvbiB3YXMgZG9uZSBpbiB0aW1lCiAgICAvLyBhc3NlcnQgR2xvYmFsLnJvdW5kIDw9ICgKICAgIC8vICAgICBzZWxmLnJvdW5kX3N0YXJ0ICsKICAgIC8vICAgICBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5yb3VuZHNfc2V0dXAubmF0aXZlICsKICAgIC8vICAgICBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5yb3VuZHNfY29uZmlybS5uYXRpdmUKICAgIC8vICksIEVSUk9SX0tFWV9DT05GSVJNX1RPT19MQVRFCiAgICBhc3NlcnQgLy8gS2V5IGNvbmZpcm1hdGlvbiB3YXMgZG9uZSB0b28gbGF0ZS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDkzLTQ5NQogICAgLy8gIyBDaGVjayB0aGF0IGJlbmVmaWNpYXJ5IGFjY291bnQgaGFzIGBBY2N0SW5jZW50aXZlRWxpZ2libGVgIGZsYWcgc2V0IHRvIHRydWUgYmVjYXVzZSBvdGhlcndpc2UKICAgIC8vICMgdGhlIGRlbGVnYXRvcidzIGNvbnRyYWN0IHdvdWxkIHJlcG9ydCBicmVhY2hfc3VzcGVuc2lvbiByaWdodCBhd2F5LgogICAgLy8gYWNjdF9pbmNlbnRpdmVfZWxpZ2libGVfcmF3ID0gb3AuQWNjdFBhcmFtc0dldC5hY2N0X2luY2VudGl2ZV9lbGlnaWJsZShzZWxmLmRlbF9iZW5lZmljaWFyeSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA3IC8vICJkZWxfYmVuZWZpY2lhcnkiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsX2JlbmVmaWNpYXJ5IGV4aXN0cwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RJbmNlbnRpdmVFbGlnaWJsZQogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ5NwogICAgLy8gYXNzZXJ0IGFjY3RfaW5jZW50aXZlX2VsaWdpYmxlLCBFUlJPUl9BQ0NPVU5UX0hBU19OT1RfUkVHSVNURVJFRF9GT1JfU1VTUEVOU0lPTl9UUkFDS0lORwogICAgYXNzZXJ0IC8vIE11c3Qgb3B0LWluIHRvIGNvbnNlbnN1cyBzdXNwZW5zaW9uIHRyYWNraW5nLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo0OTktNTAwCiAgICAvLyAjIFNldCB0aGUgbGFzdCBicmVhY2ggcm91bmQgdG8gY3VycmVudCBvbmUKICAgIC8vIHNlbGYucm91bmRfYnJlYWNoX2xhc3QgPSBHbG9iYWwucm91bmQKICAgIGJ5dGVjIDE2IC8vICJyb3VuZF9icmVhY2hfbGFzdCIKICAgIGdsb2JhbCBSb3VuZAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NTAxLTUwMgogICAgLy8gIyBSZXNldCB0aGUgbnVtYmVyIG9mIGJyZWFjaGVzCiAgICAvLyBzZWxmLmNudF9icmVhY2hfZGVsID0gVUludDY0KDApCiAgICBieXRlYyAxMyAvLyAiY250X2JyZWFjaF9kZWwiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NTA0LTUwNQogICAgLy8gIyBDaGFuZ2Ugc3RhdGUgdG8gTElWRQogICAgLy8gc2VsZi5zdGF0ZSA9IEJ5dGVzKFNUQVRFX0xJVkUpCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIGJ5dGVjIDYgLy8gMHgwNQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NTA3CiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5kZWxlZ2F0b3JfY29udHJhY3QuY29udHJhY3QuRGVsZWdhdG9yQ29udHJhY3Qua2V5c19ub3RfY29uZmlybWVkKCkgLT4gYnl0ZXM6CmtleXNfbm90X2NvbmZpcm1lZDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NTA5LTUxMgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBrZXlzX25vdF9jb25maXJtZWQoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICkgLT4gTWVzc2FnZToKICAgIHByb3RvIDAgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1MjQKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IEdsb2JhbC5jcmVhdG9yX2FkZHJlc3MsIEVSUk9SX0NBTExFRF9CWV9OT1RfQ1JFQVRPUgogICAgdHhuIFNlbmRlcgogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSBzbWFydCBjb250cmFjdCBjcmVhdG9yLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1MjUKICAgIC8vIGFzc2VydCBzZWxmLnN0YXRlID09IEJ5dGVzKFNUQVRFX1NVQk1JVFRFRCksIEVSUk9SX05PVF9TVEFURV9TVUJNSVRURUQKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0ZSBleGlzdHMKICAgIGJ5dGVjIDE1IC8vIDB4MDQKICAgID09CiAgICBhc3NlcnQgLy8gQ2Fubm90IGJlIGNhbGxlZCBmcm9tIG90aGVyIHN0YXRlIHRoYW4gU1VCTUlUVEVELgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1MjctNTI4CiAgICAvLyAjIENoZWNrIGlmIHRpbWUgZm9yIGNvbmZpcm1hdGlvbiBoYXMgcGFzc2VkCiAgICAvLyBhc3NlcnQgR2xvYmFsLnJvdW5kID4gKAogICAgZ2xvYmFsIFJvdW5kCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjUyOQogICAgLy8gc2VsZi5yb3VuZF9zdGFydCArCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNSAvLyAicm91bmRfc3RhcnQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfc3RhcnQgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjUzMAogICAgLy8gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUucm91bmRzX3NldHVwLm5hdGl2ZSArCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiRyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwgZXhpc3RzCiAgICBleHRyYWN0IDgwIDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjUyOS01MzAKICAgIC8vIHNlbGYucm91bmRfc3RhcnQgKwogICAgLy8gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUucm91bmRzX3NldHVwLm5hdGl2ZSArCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjUzMQogICAgLy8gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUucm91bmRzX2NvbmZpcm0ubmF0aXZlCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiRyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwgZXhpc3RzCiAgICBleHRyYWN0IDg4IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjUyOS01MzEKICAgIC8vIHNlbGYucm91bmRfc3RhcnQgKwogICAgLy8gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUucm91bmRzX3NldHVwLm5hdGl2ZSArCiAgICAvLyBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5yb3VuZHNfY29uZmlybS5uYXRpdmUKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NTI3LTUzMQogICAgLy8gIyBDaGVjayBpZiB0aW1lIGZvciBjb25maXJtYXRpb24gaGFzIHBhc3NlZAogICAgLy8gYXNzZXJ0IEdsb2JhbC5yb3VuZCA+ICgKICAgIC8vICAgICBzZWxmLnJvdW5kX3N0YXJ0ICsKICAgIC8vICAgICBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5yb3VuZHNfc2V0dXAubmF0aXZlICsKICAgIC8vICAgICBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5yb3VuZHNfY29uZmlybS5uYXRpdmUKICAgID4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NTI3LTUzMgogICAgLy8gIyBDaGVjayBpZiB0aW1lIGZvciBjb25maXJtYXRpb24gaGFzIHBhc3NlZAogICAgLy8gYXNzZXJ0IEdsb2JhbC5yb3VuZCA+ICgKICAgIC8vICAgICBzZWxmLnJvdW5kX3N0YXJ0ICsKICAgIC8vICAgICBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5yb3VuZHNfc2V0dXAubmF0aXZlICsKICAgIC8vICAgICBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5yb3VuZHNfY29uZmlybS5uYXRpdmUKICAgIC8vICksIEVSUk9SX1JFUE9SVF9OT1RfQ09ORklSTUVEX1RPT19FQVJMWQogICAgYXNzZXJ0IC8vIFJlcG9ydCBrZXlzIGFzIG5vdCBjb25maXJtZWQgY2FuIGJlIGRvbmUgb25seSBhZnRlciBlbm91Z2ggcm91bmRzIGhhdmUgcGFzc2VkLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1MzQtNTM1CiAgICAvLyAjIElmIHBvc3NpYmxlLCByZXR1cm4gdGhlIG9wZXJhdGlvbmFsIGZlZXMgdG8gdGhlIGRlbGVnYXRvciBtYW5hZ2VyCiAgICAvLyBmZWVfYXNzZXQgPSBBc3NldChzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5mZWVfYXNzZXRfaWQubmF0aXZlKQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gIkciCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsIGV4aXN0cwogICAgZXh0cmFjdCAyNCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1MzYKICAgIC8vIGFtdF9yZXR1cm4gPSBzZWxmLmZlZV9vcGVyYXRpb25hbCArIHNlbGYuZmVlX29wZXJhdGlvbmFsX3BhcnRuZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMCAvLyAiZmVlX29wZXJhdGlvbmFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmZlZV9vcGVyYXRpb25hbCBleGlzdHMKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMSAvLyAiZmVlX29wZXJhdGlvbmFsX3BhcnRuZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZmVlX29wZXJhdGlvbmFsX3BhcnRuZXIgZXhpc3RzCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjUzNy01NDAKICAgIC8vIHNlbGYuX3RyeV9yZXR1cm5fZmVlKAogICAgLy8gICAgIGZlZV9hc3NldD1mZWVfYXNzZXQsCiAgICAvLyAgICAgYW10X3JldHVybj1hbXRfcmV0dXJuLAogICAgLy8gKQogICAgY2FsbHN1YiBfdHJ5X3JldHVybl9mZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NTQyLTU0MwogICAgLy8gIyBDaGFuZ2Ugc3RhdGUgdG8gRU5ERURfTk9UX0NPTkZJUk1FRAogICAgLy8gc2VsZi5zdGF0ZSA9IEJ5dGVzKFNUQVRFX0VOREVEX05PVF9DT05GSVJNRUQpCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIHB1c2hieXRlcyAweDExCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1NDUtNTQ2CiAgICAvLyAjIE1hcmsgZW5kIG9mIGNvbnRyYWN0CiAgICAvLyBzZWxmLnJvdW5kX2VuZGVkID0gR2xvYmFsLnJvdW5kCiAgICBieXRlYyA4IC8vICJyb3VuZF9lbmRlZCIKICAgIGdsb2JhbCBSb3VuZAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NTUwCiAgICAvLyBkZWxfbWFuYWdlcj1hcmM0LkFkZHJlc3Moc2VsZi5kZWxfbWFuYWdlciksCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAiZGVsX21hbmFnZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsX21hbmFnZXIgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjU0OAogICAgLy8gbXNnID0gTm90aWZpY2F0aW9uTWVzc2FnZS5mcm9tX2J5dGVzKE1TR19DT1JFX0tFWVNfTk9UX0NPTkZJUk1FRCkKICAgIHB1c2hieXRlcyAweDRkNjU3MzczNjE2NzY1MjA2NjcyNmY2ZDIwNTY2MTZjNjE3MjNhMjA1OTZmNzUyMDY4NjE3NjY1MjA2ZTZmNzQyMDYzNmY2ZTY2Njk3MjZkNjU2NDIwNzQ2ODY1MjA2ZTZmNjQ2NTIwNzQ2ODYxNzQyMDc3NjE3MzIwNzA3MjY1NzA2MTcyNjU2NDIwNjY2ZjcyMjA3OTZmNzUyZTIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjU0OS01NTIKICAgIC8vIHJldHVybiBNZXNzYWdlKAogICAgLy8gICAgIGRlbF9tYW5hZ2VyPWFyYzQuQWRkcmVzcyhzZWxmLmRlbF9tYW5hZ2VyKSwKICAgIC8vICAgICBtc2c9bXNnLmNvcHkoKSwKICAgIC8vICkKICAgIGNvbmNhdAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmRlbGVnYXRvcl9jb250cmFjdC5jb250cmFjdC5EZWxlZ2F0b3JDb250cmFjdC5fdHJ5X3JldHVybl9mZWUoZmVlX2Fzc2V0OiB1aW50NjQsIGFtdF9yZXR1cm46IHVpbnQ2NCkgLT4gdm9pZDoKX3RyeV9yZXR1cm5fZmVlOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTkzLTExOTgKICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgX3RyeV9yZXR1cm5fZmVlKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZmVlX2Fzc2V0OiBBc3NldCwKICAgIC8vICAgICBhbXRfcmV0dXJuOiBVSW50NjQsCiAgICAvLyApIC0+IE5vbmU6CiAgICBwcm90byAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTIxMQogICAgLy8gaWYgZmVlX2Fzc2V0LmlkICE9IFVJbnQ2NChBTEdPX0FTQV9JRCk6CiAgICBmcmFtZV9kaWcgLTIKICAgIGJ6IF90cnlfcmV0dXJuX2ZlZV9lbHNlX2JvZHlAOQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMjEyCiAgICAvLyBpZiBzZWxmLmRlbF9tYW5hZ2VyLmlzX29wdGVkX2luKGZlZV9hc3NldCk6CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAiZGVsX21hbmFnZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsX21hbmFnZXIgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTIKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYnVyeSAxCiAgICBieiBfdHJ5X3JldHVybl9mZWVfYWZ0ZXJfaWZfZWxzZUAxMwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMjEzCiAgICAvLyBpZiBub3QgZmVlX2Fzc2V0LmZyb3plbihzZWxmLmRlbF9tYW5hZ2VyKToKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJkZWxfbWFuYWdlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxfbWFuYWdlciBleGlzdHMKICAgIGZyYW1lX2RpZyAtMgogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRGcm96ZW4KICAgIGFzc2VydCAvLyBhY2NvdW50IG9wdGVkIGludG8gYXNzZXQKICAgIGJueiBfdHJ5X3JldHVybl9mZWVfYWZ0ZXJfaWZfZWxzZUAxMwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMjE0CiAgICAvLyBhc3NldF9iYWxhbmNlID0gZmVlX2Fzc2V0LmJhbGFuY2Uoc2VsZi5kZWxfbWFuYWdlcikKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJkZWxfbWFuYWdlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxfbWFuYWdlciBleGlzdHMKICAgIGZyYW1lX2RpZyAtMgogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBvcHRlZCBpbnRvIGFzc2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEyMTUKICAgIC8vIGlmIGFzc2V0X2JhbGFuY2UgPj0gYW10X3JldHVybjoKICAgIGZyYW1lX2RpZyAtMQogICAgPj0KICAgIGJ6IF90cnlfcmV0dXJuX2ZlZV9hZnRlcl9pZl9lbHNlQDEzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEyMTYtMTIyMAogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgLy8gICAgIHhmZXJfYXNzZXQ9ZmVlX2Fzc2V0LAogICAgLy8gICAgIGFzc2V0X3JlY2VpdmVyPXNlbGYuZGVsX21hbmFnZXIsCiAgICAvLyAgICAgYXNzZXRfYW1vdW50PWFtdF9yZXR1cm4sCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEyMTgKICAgIC8vIGFzc2V0X3JlY2VpdmVyPXNlbGYuZGVsX21hbmFnZXIsCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAiZGVsX21hbmFnZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsX21hbmFnZXIgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgZnJhbWVfZGlnIC0yCiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMjE2CiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICBpbnRjXzIgLy8gYXhmZXIKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMjE2LTEyMjAKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIC8vICAgICB4ZmVyX2Fzc2V0PWZlZV9hc3NldCwKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj1zZWxmLmRlbF9tYW5hZ2VyLAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD1hbXRfcmV0dXJuLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIGIgX3RyeV9yZXR1cm5fZmVlX2FmdGVyX2lmX2Vsc2VAMTMKCl90cnlfcmV0dXJuX2ZlZV9lbHNlX2JvZHlAOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTIyMgogICAgLy8gaWYgb3AuYmFsYW5jZShzZWxmLmRlbF9tYW5hZ2VyKSA+PSBHbG9iYWwubWluX2JhbGFuY2U6CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAiZGVsX21hbmFnZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsX21hbmFnZXIgZXhpc3RzCiAgICBiYWxhbmNlCiAgICBnbG9iYWwgTWluQmFsYW5jZQogICAgPj0KICAgIGJ6IF90cnlfcmV0dXJuX2ZlZV9hZnRlcl9pZl9lbHNlQDEzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEyMjMtMTIyNgogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXNlbGYuZGVsX21hbmFnZXIsCiAgICAvLyAgICAgYW1vdW50PWFtdF9yZXR1cm4sCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEyMjQKICAgIC8vIHJlY2VpdmVyPXNlbGYuZGVsX21hbmFnZXIsCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAiZGVsX21hbmFnZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsX21hbmFnZXIgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEyMjMKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIGludGNfMSAvLyBwYXkKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMjIzLTEyMjYKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1zZWxmLmRlbF9tYW5hZ2VyLAogICAgLy8gICAgIGFtb3VudD1hbXRfcmV0dXJuLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKCl90cnlfcmV0dXJuX2ZlZV9hZnRlcl9pZl9lbHNlQDEzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMjI4CiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5kZWxlZ2F0b3JfY29udHJhY3QuY29udHJhY3QuRGVsZWdhdG9yQ29udHJhY3Qua2V5c19ub3Rfc3VibWl0dGVkKCkgLT4gYnl0ZXM6CmtleXNfbm90X3N1Ym1pdHRlZDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NTU0LTU1NwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBrZXlzX25vdF9zdWJtaXR0ZWQoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICkgLT4gTWVzc2FnZToKICAgIHByb3RvIDAgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1NjkKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IEdsb2JhbC5jcmVhdG9yX2FkZHJlc3MsIEVSUk9SX0NBTExFRF9CWV9OT1RfQ1JFQVRPUgogICAgdHhuIFNlbmRlcgogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSBzbWFydCBjb250cmFjdCBjcmVhdG9yLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1NzAKICAgIC8vIGFzc2VydCBzZWxmLnN0YXRlID09IEJ5dGVzKFNUQVRFX1JFQURZKSwgRVJST1JfTk9UX1NUQVRFX1JFQURZCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdGUgZXhpc3RzCiAgICBieXRlYyAxNCAvLyAweDAzCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbm5vdCBiZSBjYWxsZWQgZnJvbSBvdGhlciBzdGF0ZSB0aGFuIFJFQURZLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1NzItNTczCiAgICAvLyAjIENoZWNrIGlmIHRpbWUgZm9yIHN1Ym1pc3Npb24gaGFzIHBhc3NlZAogICAgLy8gYXNzZXJ0IEdsb2JhbC5yb3VuZCA+ICgKICAgIGdsb2JhbCBSb3VuZAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1NzQKICAgIC8vIHNlbGYucm91bmRfc3RhcnQgKwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDUgLy8gInJvdW5kX3N0YXJ0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnJvdW5kX3N0YXJ0IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1NzUKICAgIC8vIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsLnZhbHVlLnJvdW5kc19zZXR1cC5uYXRpdmUKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJHIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbCBleGlzdHMKICAgIGV4dHJhY3QgODAgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NTc0LTU3NQogICAgLy8gc2VsZi5yb3VuZF9zdGFydCArCiAgICAvLyBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5yb3VuZHNfc2V0dXAubmF0aXZlCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjU3Mi01NzUKICAgIC8vICMgQ2hlY2sgaWYgdGltZSBmb3Igc3VibWlzc2lvbiBoYXMgcGFzc2VkCiAgICAvLyBhc3NlcnQgR2xvYmFsLnJvdW5kID4gKAogICAgLy8gICAgIHNlbGYucm91bmRfc3RhcnQgKwogICAgLy8gICAgIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsLnZhbHVlLnJvdW5kc19zZXR1cC5uYXRpdmUKICAgID4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NTcyLTU3NgogICAgLy8gIyBDaGVjayBpZiB0aW1lIGZvciBzdWJtaXNzaW9uIGhhcyBwYXNzZWQKICAgIC8vIGFzc2VydCBHbG9iYWwucm91bmQgPiAoCiAgICAvLyAgICAgc2VsZi5yb3VuZF9zdGFydCArCiAgICAvLyAgICAgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUucm91bmRzX3NldHVwLm5hdGl2ZQogICAgLy8gKSwgRVJST1JfUkVQT1JUX05PVF9TVUJNSVRURURfVE9PX0VBUkxZCiAgICBhc3NlcnQgLy8gUmVwb3J0IGtleXMgYXMgbm90IHN1Ym1pdHRlZCBjYW4gYmUgZG9uZSBvbmx5IGFmdGVyIGVub3VnaCByb3VuZHMgaGF2ZSBwYXNzZWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjU3OC01NzkKICAgIC8vICMgSWYgcG9zc2libGUsIHJldHVybiB0aGUgc3VtIG9mIHRoZSBzZXR1cCBhbmQgb3BlcmF0aW9uYWwgZmVlcyB0byB0aGUgZGVsZWdhdG9yIG1hbmFnZXIKICAgIC8vIGZlZV9hc3NldCA9IEFzc2V0KHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsLnZhbHVlLmZlZV9hc3NldF9pZC5uYXRpdmUpCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiRyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwgZXhpc3RzCiAgICBleHRyYWN0IDI0IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjU4MAogICAgLy8gYmFzZV9mZWUgPSBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5mZWVfc2V0dXAubmF0aXZlICsgc2VsZi5mZWVfb3BlcmF0aW9uYWwKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJHIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbCBleGlzdHMKICAgIGV4dHJhY3QgMTYgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMCAvLyAiZmVlX29wZXJhdGlvbmFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmZlZV9vcGVyYXRpb25hbCBleGlzdHMKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NTgxCiAgICAvLyBwYXJ0bmVyX2ZlZSA9IHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsLnZhbHVlLmZlZV9zZXR1cF9wYXJ0bmVyLm5hdGl2ZSArIHNlbGYuZmVlX29wZXJhdGlvbmFsX3BhcnRuZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJHIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbCBleGlzdHMKICAgIGV4dHJhY3QgNzIgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMSAvLyAiZmVlX29wZXJhdGlvbmFsX3BhcnRuZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZmVlX29wZXJhdGlvbmFsX3BhcnRuZXIgZXhpc3RzCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjU4MgogICAgLy8gYW10X3JldHVybiA9IGJhc2VfZmVlICsgcGFydG5lcl9mZWUKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NTgzLTU4NgogICAgLy8gc2VsZi5fdHJ5X3JldHVybl9mZWUoCiAgICAvLyAgICAgZmVlX2Fzc2V0PWZlZV9hc3NldCwKICAgIC8vICAgICBhbXRfcmV0dXJuPWFtdF9yZXR1cm4sCiAgICAvLyApCiAgICBjYWxsc3ViIF90cnlfcmV0dXJuX2ZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1ODgtNTg5CiAgICAvLyAjIENoYW5nZSBzdGF0ZSB0byBFTkRFRF9OT1RfU1VCTUlUVEVECiAgICAvLyBzZWxmLnN0YXRlID0gQnl0ZXMoU1RBVEVfRU5ERURfTk9UX1NVQk1JVFRFRCkKICAgIGJ5dGVjXzEgLy8gInN0YXRlIgogICAgYnl0ZWMgMjEgLy8gMHgxMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NTkxLTU5MgogICAgLy8gIyBNYXJrIGVuZCBvZiBjb250cmFjdAogICAgLy8gc2VsZi5yb3VuZF9lbmRlZCA9IEdsb2JhbC5yb3VuZAogICAgYnl0ZWMgOCAvLyAicm91bmRfZW5kZWQiCiAgICBnbG9iYWwgUm91bmQKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjU5NgogICAgLy8gZGVsX21hbmFnZXI9YXJjNC5BZGRyZXNzKHNlbGYuZGVsX21hbmFnZXIpLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gImRlbF9tYW5hZ2VyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbF9tYW5hZ2VyIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1OTQKICAgIC8vIG1zZyA9IE5vdGlmaWNhdGlvbk1lc3NhZ2UuZnJvbV9ieXRlcyhNU0dfQ09SRV9LRVlTX05PVF9TVUJNSVRURUQpCiAgICBwdXNoYnl0ZXMgMHg0ZDY1NzM3MzYxNjc2NTIwNjY3MjZmNmQyMDU2NjE2YzYxNzIzYTIwNGU2ZjY0NjUyMDcyNzU2ZTZlNjU3MjIwNjg2MTczMjA3NTZlNjY2ZjcyNzQ3NTZlNjE3NDY1NmM3OTIwNmU2Zjc0MjA3MDcyNjU3MDYxNzI2NTY0MjA2MTIwNmU2ZjY0NjUyMDY2NmY3MjIwNzk2Zjc1MmUyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1OTUtNTk4CiAgICAvLyByZXR1cm4gTWVzc2FnZSgKICAgIC8vICAgICBkZWxfbWFuYWdlcj1hcmM0LkFkZHJlc3Moc2VsZi5kZWxfbWFuYWdlciksCiAgICAvLyAgICAgbXNnPW1zZy5jb3B5KCksCiAgICAvLyApCiAgICBjb25jYXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5kZWxlZ2F0b3JfY29udHJhY3QuY29udHJhY3QuRGVsZWdhdG9yQ29udHJhY3Qua2V5c19zdWJtaXQoa2V5X3JlZ190eG5faW5mbzogYnl0ZXMpIC0+IGJ5dGVzOgprZXlzX3N1Ym1pdDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NjAwLTYwNAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBrZXlzX3N1Ym1pdCgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGtleV9yZWdfdHhuX2luZm8gOiBLZXlSZWdUeG5JbmZvLAogICAgLy8gKSAtPiBFYXJuaW5nc0Rpc3RyaWJ1dGlvbkFuZE1lc3NhZ2U6CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NjI1CiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCBFUlJPUl9DQUxMRURfQllfTk9UX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NjI2CiAgICAvLyBhc3NlcnQgc2VsZi5zdGF0ZSA9PSBCeXRlcyhTVEFURV9SRUFEWSksIEVSUk9SX05PVF9TVEFURV9SRUFEWQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gInN0YXRlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXRlIGV4aXN0cwogICAgYnl0ZWMgMTQgLy8gMHgwMwogICAgPT0KICAgIGFzc2VydCAvLyBDYW5ub3QgYmUgY2FsbGVkIGZyb20gb3RoZXIgc3RhdGUgdGhhbiBSRUFEWS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NjI4LTYyOQogICAgLy8gIyBTYW5pdHkgY2hlY2sgb24gc3VibWl0dGVkIGtleSBpbmZvcm1hdGlvbgogICAgLy8gYXNzZXJ0IHNlbGYuZGVsX2JlbmVmaWNpYXJ5ID09IGtleV9yZWdfdHhuX2luZm8uc2VuZGVyLCBFUlJPUl9LRVlfQkVORUZJQ0lBUllfTUlTTUFUQ0gKICAgIGZyYW1lX2RpZyAtMQogICAgZXh0cmFjdCAxNTIgMzIgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNyAvLyAiZGVsX2JlbmVmaWNpYXJ5IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbF9iZW5lZmljaWFyeSBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gS2V5IGJlbmVmaWNpYXJ5IGRvZXMgbm90IG1hdGNoLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2MzAKICAgIC8vIGFzc2VydCBzZWxmLnJvdW5kX3N0YXJ0ID09IGtleV9yZWdfdHhuX2luZm8udm90ZV9maXJzdCwgRVJST1JfVk9URV9GSVJTVF9ST1VORF9NSVNNQVRDSAogICAgZnJhbWVfZGlnIC0xCiAgICBleHRyYWN0IDAgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA1IC8vICJyb3VuZF9zdGFydCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5yb3VuZF9zdGFydCBleGlzdHMKICAgIGl0b2IKICAgIGI9PQogICAgYXNzZXJ0IC8vIFZvdGUgZmlyc3Qgcm91bmQgZG9lcyBub3QgbWF0Y2ggY29udHJhY3Qgc3RhcnQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjYzMQogICAgLy8gYXNzZXJ0IHNlbGYucm91bmRfZW5kID09IGtleV9yZWdfdHhuX2luZm8udm90ZV9sYXN0LCBFUlJPUl9WT1RFX0xBU1RfUk9VTkRfTUlTTUFUQ0gKICAgIGZyYW1lX2RpZyAtMQogICAgZXh0cmFjdCA4IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMyAvLyAicm91bmRfZW5kIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnJvdW5kX2VuZCBleGlzdHMKICAgIGl0b2IKICAgIGI9PQogICAgYXNzZXJ0IC8vIFZvdGUgbGFzdCByb3VuZCBkb2VzIG5vdCBtYXRjaCBjb250cmFjdCBlbmQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjYzMy02MzQKICAgIC8vICMgU3RvcmUgc3VibWl0dGVkIGtleSBpbmZvcm1hdGlvbgogICAgLy8gc2VsZi52b3RlX2tleV9kaWx1dGlvbiA9IGtleV9yZWdfdHhuX2luZm8udm90ZV9rZXlfZGlsdXRpb24ubmF0aXZlCiAgICBmcmFtZV9kaWcgLTEKICAgIGV4dHJhY3QgMTYgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGJ5dGVjIDIyIC8vICJ2b3RlX2tleV9kaWx1dGlvbiIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjYzNQogICAgLy8gc2VsZi52b3RlX2tleSA9IGtleV9yZWdfdHhuX2luZm8udm90ZV9way5jb3B5KCkKICAgIGZyYW1lX2RpZyAtMQogICAgZXh0cmFjdCAyNCAzMiAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ5dGVjIDI0IC8vICJ2b3RlX2tleSIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjYzNgogICAgLy8gc2VsZi5zZWxfa2V5ID0ga2V5X3JlZ190eG5faW5mby5zZWxlY3Rpb25fcGsuY29weSgpCiAgICBmcmFtZV9kaWcgLTEKICAgIGV4dHJhY3QgNTYgMzIgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBieXRlYyAyMyAvLyAic2VsX2tleSIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjYzNwogICAgLy8gc2VsZi5zdGF0ZV9wcm9vZl9rZXkgPSBrZXlfcmVnX3R4bl9pbmZvLnN0YXRlX3Byb29mX3BrLmNvcHkoKQogICAgZnJhbWVfZGlnIC0xCiAgICBleHRyYWN0IDg4IDY0IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnl0ZWMgMjUgLy8gInN0YXRlX3Byb29mX2tleSIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjYzOS02NDAKICAgIC8vICMgQ2hlY2sgaWYgc3VibWlzc2lvbiB3YXMgZG9uZSBpbiB0aW1lCiAgICAvLyBhc3NlcnQgR2xvYmFsLnJvdW5kIDw9ICgKICAgIGdsb2JhbCBSb3VuZAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2NDEKICAgIC8vIHNlbGYucm91bmRfc3RhcnQgKwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDUgLy8gInJvdW5kX3N0YXJ0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnJvdW5kX3N0YXJ0IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2NDIKICAgIC8vIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsLnZhbHVlLnJvdW5kc19zZXR1cC5uYXRpdmUKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJHIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbCBleGlzdHMKICAgIGV4dHJhY3QgODAgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NjQxLTY0MgogICAgLy8gc2VsZi5yb3VuZF9zdGFydCArCiAgICAvLyBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5yb3VuZHNfc2V0dXAubmF0aXZlCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjYzOS02NDIKICAgIC8vICMgQ2hlY2sgaWYgc3VibWlzc2lvbiB3YXMgZG9uZSBpbiB0aW1lCiAgICAvLyBhc3NlcnQgR2xvYmFsLnJvdW5kIDw9ICgKICAgIC8vICAgICBzZWxmLnJvdW5kX3N0YXJ0ICsKICAgIC8vICAgICBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5yb3VuZHNfc2V0dXAubmF0aXZlCiAgICA8PQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2MzktNjQzCiAgICAvLyAjIENoZWNrIGlmIHN1Ym1pc3Npb24gd2FzIGRvbmUgaW4gdGltZQogICAgLy8gYXNzZXJ0IEdsb2JhbC5yb3VuZCA8PSAoCiAgICAvLyAgICAgc2VsZi5yb3VuZF9zdGFydCArCiAgICAvLyAgICAgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUucm91bmRzX3NldHVwLm5hdGl2ZQogICAgLy8gKSwgRVJST1JfS0VZX1NVQk1JVF9UT09fTEFURQogICAgYXNzZXJ0IC8vIEtleSBzdWJtaXNzaW9uIHdhcyBkb25lIHRvbyBsYXRlLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2NDcKICAgIC8vIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsLnZhbHVlLmZlZV9zZXR1cC5uYXRpdmUsCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiRyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwgZXhpc3RzCiAgICBleHRyYWN0IDE2IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjY0OAogICAgLy8gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUuZmVlX3NldHVwX3BhcnRuZXIubmF0aXZlLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gIkciCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsIGV4aXN0cwogICAgZXh0cmFjdCA3MiA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2NDUtNjQ5CiAgICAvLyAjIERpc3RyaWJ1dGUgZWFybmluZ3MgZnJvbSB0aGUgc2V0dXAgZmVlCiAgICAvLyBlYXJuaW5nc19kaXN0cmlidXRpb24gPSBzZWxmLl9kaXN0cmlidXRlX2Vhcm5pbmdzKAogICAgLy8gICAgIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsLnZhbHVlLmZlZV9zZXR1cC5uYXRpdmUsCiAgICAvLyAgICAgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUuZmVlX3NldHVwX3BhcnRuZXIubmF0aXZlLAogICAgLy8gKQogICAgY2FsbHN1YiBfZGlzdHJpYnV0ZV9lYXJuaW5ncwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2NTEtNjUyCiAgICAvLyAjIENoYW5nZSBzdGF0ZSB0byBMSVZFCiAgICAvLyBzZWxmLnN0YXRlID0gQnl0ZXMoU1RBVEVfU1VCTUlUVEVEKQogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBieXRlYyAxNSAvLyAweDA0CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2NTcKICAgIC8vIGRlbF9tYW5hZ2VyPWFyYzQuQWRkcmVzcyhzZWxmLmRlbF9tYW5hZ2VyKSwKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJkZWxfbWFuYWdlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxfbWFuYWdlciBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NjU1LTY1OQogICAgLy8gcmV0dXJuIEVhcm5pbmdzRGlzdHJpYnV0aW9uQW5kTWVzc2FnZSgKICAgIC8vICAgICBlYXJuaW5nc19kaXN0cmlidXRpb24gPSBlYXJuaW5nc19kaXN0cmlidXRpb24uY29weSgpLAogICAgLy8gICAgIGRlbF9tYW5hZ2VyPWFyYzQuQWRkcmVzcyhzZWxmLmRlbF9tYW5hZ2VyKSwKICAgIC8vICAgICBtc2c9bXNnLmNvcHkoKSwKICAgIC8vICkKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2NTQKICAgIC8vIG1zZyA9IE5vdGlmaWNhdGlvbk1lc3NhZ2UuZnJvbV9ieXRlcyhNU0dfQ09SRV9LRVlTX1NVQk1JVCkKICAgIHB1c2hieXRlcyAweDRkNjU3MzczNjE2NzY1MjA2NjcyNmY2ZDIwNTY2MTZjNjE3MjNhMjA0ZTZmNjQ2NTIwNjg2MTczMjA2MjY1NjU2ZTIwNzA3MjY1NzA2MTcyNjU2NDIwNjY2ZjcyMjA3OTZmNzUyMDc0NmYyMDczNzQ2MTZiNjUyZTIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjY1NS02NTkKICAgIC8vIHJldHVybiBFYXJuaW5nc0Rpc3RyaWJ1dGlvbkFuZE1lc3NhZ2UoCiAgICAvLyAgICAgZWFybmluZ3NfZGlzdHJpYnV0aW9uID0gZWFybmluZ3NfZGlzdHJpYnV0aW9uLmNvcHkoKSwKICAgIC8vICAgICBkZWxfbWFuYWdlcj1hcmM0LkFkZHJlc3Moc2VsZi5kZWxfbWFuYWdlciksCiAgICAvLyAgICAgbXNnPW1zZy5jb3B5KCksCiAgICAvLyApCiAgICBjb25jYXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5kZWxlZ2F0b3JfY29udHJhY3QuY29udHJhY3QuRGVsZWdhdG9yQ29udHJhY3QuX2Rpc3RyaWJ1dGVfZWFybmluZ3MoYW1vdW50OiB1aW50NjQsIGFtb3VudF9wYXJ0bmVyOiB1aW50NjQpIC0+IGJ5dGVzOgpfZGlzdHJpYnV0ZV9lYXJuaW5nczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6ODc2LTg4MQogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBfZGlzdHJpYnV0ZV9lYXJuaW5ncygKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGFtb3VudDogVUludDY0LAogICAgLy8gICAgIGFtb3VudF9wYXJ0bmVyOiBVSW50NjQsCiAgICAvLyApIC0+IEVhcm5pbmdzRGlzdHJpYnV0aW9uOgogICAgcHJvdG8gMiAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjkwMQogICAgLy8gYXNzZXQgPSBBc3NldChzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5mZWVfYXNzZXRfaWQubmF0aXZlKQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gIkciCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsIGV4aXN0cwogICAgZXh0cmFjdCAyNCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnRvaQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjkwMgogICAgLy8gdmFsX2FwcCA9IEFwcGxpY2F0aW9uKHNlbGYudmFsaWRhdG9yX2FkX2FwcF9pZCkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxOCAvLyAidmFsaWRhdG9yX2FkX2FwcF9pZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBzd2FwCiAgICBjb3ZlciAyCiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi52YWxpZGF0b3JfYWRfYXBwX2lkIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo5MDMKICAgIC8vIHBsYV9hcHAgPSBBcHBsaWNhdGlvbihzZWxmLm5vdGljZWJvYXJkX2FwcF9pZCkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxNyAvLyAibm90aWNlYm9hcmRfYXBwX2lkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHN3YXAKICAgIGNvdmVyIDIKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLm5vdGljZWJvYXJkX2FwcF9pZCBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTA1CiAgICAvLyBwYXJ0bmVyID0gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUucGFydG5lcl9hZGRyZXNzLm5hdGl2ZQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gIkciCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsIGV4aXN0cwogICAgZXh0cmFjdCAzMiAzMiAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTEwCiAgICAvLyBjb21taXNzaW9uPXNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsLnZhbHVlLmNvbW1pc3Npb24ubmF0aXZlLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gIkciCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsIGV4aXN0cwogICAgZXh0cmFjdCAwIDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjkwNy05MTIKICAgIC8vICMgQ2FsY3VsYXRlIGVhcm5pbmdzCiAgICAvLyBlYXJuaW5nc19kaXN0cmlidXRpb24gPSBjYWxjX2Vhcm5pbmdzKAogICAgLy8gICAgIGFtb3VudD1hbW91bnQsCiAgICAvLyAgICAgY29tbWlzc2lvbj1zZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5jb21taXNzaW9uLm5hdGl2ZSwKICAgIC8vICAgICBhc3NldF9pZD1hc3NldC5pZCwKICAgIC8vICkKICAgIGZyYW1lX2RpZyAtMgogICAgc3dhcAogICAgZGlnIDIKICAgIGNhbGxzdWIgY2FsY19lYXJuaW5ncwogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo5MTQKICAgIC8vIGlmIGFzc2V0LmlkICE9IFVJbnQ2NChBTEdPX0FTQV9JRCk6CiAgICBieiBfZGlzdHJpYnV0ZV9lYXJuaW5nc19lbHNlX2JvZHlAMTkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTE1CiAgICAvLyBhc3NlcnQgYXNzZXQuYmFsYW5jZShHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzKSA+PSBhbW91bnQgKyBhbW91bnRfcGFydG5lciwgXAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGZyYW1lX2RpZyAwCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgb3B0ZWQgaW50byBhc3NldAogICAgZnJhbWVfZGlnIC0yCiAgICBmcmFtZV9kaWcgLTEKICAgICsKICAgID49CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjkxNS05MTYKICAgIC8vIGFzc2VydCBhc3NldC5iYWxhbmNlKEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MpID49IGFtb3VudCArIGFtb3VudF9wYXJ0bmVyLCBcCiAgICAvLyAgICAgRVJST1JfSU5TVUZGSUNJRU5UX0JBTEFOQ0UKICAgIGFzc2VydCAvLyBFYXJuaW5ncyBjYW5ub3QgYmUgcGFpZCBiZWNhdXNlIERlbGVnYXRvckNvbnRyYWN0IGhhcyBpbnN1ZmZpY2llbnQgYW1vdW50LgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo5MTgKICAgIC8vIGFzc2VydCBub3QgYXNzZXQuZnJvemVuKEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MpLCBcCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgZGlnIDEKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0RnJvemVuCiAgICBhc3NlcnQgLy8gYWNjb3VudCBvcHRlZCBpbnRvIGFzc2V0CiAgICAhCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjkxOC05MTkKICAgIC8vIGFzc2VydCBub3QgYXNzZXQuZnJvemVuKEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MpLCBcCiAgICAvLyAgICAgRVJST1JfQkFMQU5DRV9GUk9aRU4KICAgIGFzc2VydCAvLyBFYXJuaW5ncyBjYW5ub3QgYmUgcGFpZCBiZWNhdXNlIERlbGVnYXRvckNvbnRyYWN0IGhhcyB0aGUgYXNzZXQgZnJvemVuLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo5MjEtOTIyCiAgICAvLyAjIFNlbmQgdmFsaWRhdG9yIGVhcm5pbmdzIHRvIFZhbGlkYXRvckFkIGlmIGl0IGNhbiBhY2NlcHQgdGhlbQogICAgLy8gaWYgdmFsX2FwcC5hZGRyZXNzLmlzX29wdGVkX2luKGFzc2V0KToKICAgIGZyYW1lX2RpZyAxCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBzd2FwCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGJ1cnkgMQogICAgYnogX2Rpc3RyaWJ1dGVfZWFybmluZ3NfYWZ0ZXJfaWZfZWxzZUA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjkyMwogICAgLy8gaWYgbm90IGFzc2V0LmZyb3plbih2YWxfYXBwLmFkZHJlc3MpOgogICAgZnJhbWVfZGlnIDEKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIGZyYW1lX2RpZyAwCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEZyb3plbgogICAgYXNzZXJ0IC8vIGFjY291bnQgb3B0ZWQgaW50byBhc3NldAogICAgYm56IF9kaXN0cmlidXRlX2Vhcm5pbmdzX2FmdGVyX2lmX2Vsc2VANgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo5MjQtOTI4CiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgeGZlcl9hc3NldD1hc3NldCwKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj12YWxfYXBwLmFkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRfYW1vdW50PWVhcm5pbmdzX2Rpc3RyaWJ1dGlvbi51c2VyLm5hdGl2ZSwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTI2CiAgICAvLyBhc3NldF9yZWNlaXZlcj12YWxfYXBwLmFkZHJlc3MsCiAgICBmcmFtZV9kaWcgMQogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo5MjcKICAgIC8vIGFzc2V0X2Ftb3VudD1lYXJuaW5nc19kaXN0cmlidXRpb24udXNlci5uYXRpdmUsCiAgICBmcmFtZV9kaWcgNAogICAgZXh0cmFjdCAwIDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIGZyYW1lX2RpZyAwCiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo5MjQKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIGludGNfMiAvLyBheGZlcgogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjkyNC05MjgKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIC8vICAgICB4ZmVyX2Fzc2V0PWFzc2V0LAogICAgLy8gICAgIGFzc2V0X3JlY2VpdmVyPXZhbF9hcHAuYWRkcmVzcywKICAgIC8vICAgICBhc3NldF9hbW91bnQ9ZWFybmluZ3NfZGlzdHJpYnV0aW9uLnVzZXIubmF0aXZlLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKCl9kaXN0cmlidXRlX2Vhcm5pbmdzX2FmdGVyX2lmX2Vsc2VANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTMwLTkzMQogICAgLy8gIyBTZW5kIHBsYXRmb3JtIGVhcm5pbmdzIHRvIE5vdGljZWJvYXJkIGlmIGl0IGNhbiBhY2NlcHQgdGhlbQogICAgLy8gaWYgcGxhX2FwcC5hZGRyZXNzLmlzX29wdGVkX2luKGFzc2V0KToKICAgIGZyYW1lX2RpZyAyCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBmcmFtZV9kaWcgMAogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCiAgICBidXJ5IDEKICAgIGJ6IF9kaXN0cmlidXRlX2Vhcm5pbmdzX2FmdGVyX2lmX2Vsc2VAMTEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTMyCiAgICAvLyBpZiBub3QgYXNzZXQuZnJvemVuKHBsYV9hcHAuYWRkcmVzcyk6CiAgICBmcmFtZV9kaWcgMgogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgZnJhbWVfZGlnIDAKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0RnJvemVuCiAgICBhc3NlcnQgLy8gYWNjb3VudCBvcHRlZCBpbnRvIGFzc2V0CiAgICBibnogX2Rpc3RyaWJ1dGVfZWFybmluZ3NfYWZ0ZXJfaWZfZWxzZUAxMQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo5MzMtOTM3CiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgeGZlcl9hc3NldD1hc3NldCwKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj1wbGFfYXBwLmFkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRfYW1vdW50PWVhcm5pbmdzX2Rpc3RyaWJ1dGlvbi5wbGF0Zm9ybS5uYXRpdmUsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjkzNQogICAgLy8gYXNzZXRfcmVjZWl2ZXI9cGxhX2FwcC5hZGRyZXNzLAogICAgZnJhbWVfZGlnIDIKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTM2CiAgICAvLyBhc3NldF9hbW91bnQ9ZWFybmluZ3NfZGlzdHJpYnV0aW9uLnBsYXRmb3JtLm5hdGl2ZSwKICAgIGZyYW1lX2RpZyA0CiAgICBleHRyYWN0IDggOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgZnJhbWVfZGlnIDAKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjkzMwogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgaW50Y18yIC8vIGF4ZmVyCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTMzLTkzNwogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgLy8gICAgIHhmZXJfYXNzZXQ9YXNzZXQsCiAgICAvLyAgICAgYXNzZXRfcmVjZWl2ZXI9cGxhX2FwcC5hZGRyZXNzLAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD1lYXJuaW5nc19kaXN0cmlidXRpb24ucGxhdGZvcm0ubmF0aXZlLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKCl9kaXN0cmlidXRlX2Vhcm5pbmdzX2FmdGVyX2lmX2Vsc2VAMTE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjkzOS05NDAKICAgIC8vICMgU2VuZCBwYXJ0bmVyIGVhcm5pbmdzIHRvIHBhcnRuZXJfYWRkcmVzcyBpZiBpdCBpcyBub24temVybwogICAgLy8gaWYgcGFydG5lciAhPSBHbG9iYWwuemVyb19hZGRyZXNzOgogICAgZnJhbWVfZGlnIDMKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgIT0KICAgIGJ6IF9kaXN0cmlidXRlX2Vhcm5pbmdzX2FmdGVyX2lmX2Vsc2VAMjcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTQxLTk0MgogICAgLy8gIyBTZW5kIHRoZSBlYXJuaW5ncyBpZiB0aGUgcGFydG5lcl9hZGRyZXNzIGNhbiBhY2NlcHQgdGhlbQogICAgLy8gaWYgcGFydG5lci5pc19vcHRlZF9pbihhc3NldCk6CiAgICBmcmFtZV9kaWcgMwogICAgZnJhbWVfZGlnIDAKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYnVyeSAxCiAgICBieiBfZGlzdHJpYnV0ZV9lYXJuaW5nc19hZnRlcl9pZl9lbHNlQDI3CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojk0MwogICAgLy8gaWYgbm90IGFzc2V0LmZyb3plbihwYXJ0bmVyKToKICAgIGZyYW1lX2RpZyAzCiAgICBmcmFtZV9kaWcgMAogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRGcm96ZW4KICAgIGFzc2VydCAvLyBhY2NvdW50IG9wdGVkIGludG8gYXNzZXQKICAgIGJueiBfZGlzdHJpYnV0ZV9lYXJuaW5nc19hZnRlcl9pZl9lbHNlQDI3CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojk0NC05NDgKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIC8vICAgICB4ZmVyX2Fzc2V0PWFzc2V0LAogICAgLy8gICAgIGFzc2V0X3JlY2VpdmVyPXBhcnRuZXIsCiAgICAvLyAgICAgYXNzZXRfYW1vdW50PWFtb3VudF9wYXJ0bmVyLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBmcmFtZV9kaWcgMwogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICBmcmFtZV9kaWcgMAogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTQ0CiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICBpbnRjXzIgLy8gYXhmZXIKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo5NDQtOTQ4CiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgeGZlcl9hc3NldD1hc3NldCwKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj1wYXJ0bmVyLAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD1hbW91bnRfcGFydG5lciwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICBiIF9kaXN0cmlidXRlX2Vhcm5pbmdzX2FmdGVyX2lmX2Vsc2VAMjcKCl9kaXN0cmlidXRlX2Vhcm5pbmdzX2Vsc2VfYm9keUAxOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTUxCiAgICAvLyBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLmJhbGFuY2UgLQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0QmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojk1MgogICAgLy8gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5taW5fYmFsYW5jZQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojk1MS05NTIKICAgIC8vIEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MuYmFsYW5jZSAtCiAgICAvLyBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlCiAgICAtCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojk1MwogICAgLy8gKSA+PSBhbW91bnQgKyBhbW91bnRfcGFydG5lciwgXAogICAgZnJhbWVfZGlnIC0yCiAgICBmcmFtZV9kaWcgLTEKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTUxLTk1MwogICAgLy8gICAgIEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MuYmFsYW5jZSAtCiAgICAvLyAgICAgR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5taW5fYmFsYW5jZQogICAgLy8gKSA+PSBhbW91bnQgKyBhbW91bnRfcGFydG5lciwgXAogICAgPj0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTUwLTk1NAogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLmJhbGFuY2UgLQogICAgLy8gICAgIEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MubWluX2JhbGFuY2UKICAgIC8vICkgPj0gYW1vdW50ICsgYW1vdW50X3BhcnRuZXIsIFwKICAgIC8vICAgICBFUlJPUl9JTlNVRkZJQ0lFTlRfQUxHTwogICAgYXNzZXJ0IC8vIEVhcm5pbmdzIGNhbm5vdCBiZSBwYWlkIGJlY2F1c2UgRGVsZWdhdG9yQ29udHJhY3QgaGFzIGluc3VmZmljaWVudCBBTEdPLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo5NTctOTYxCiAgICAvLyAjIFNlbmQgdmFsaWRhdG9yIGVhcm5pbmdzIHRvIFZhbGlkYXRvckFkCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgcmVjZWl2ZXI9dmFsX2FwcC5hZGRyZXNzLAogICAgLy8gICAgIGFtb3VudD1lYXJuaW5nc19kaXN0cmlidXRpb24udXNlci5uYXRpdmUsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojk1OQogICAgLy8gcmVjZWl2ZXI9dmFsX2FwcC5hZGRyZXNzLAogICAgZnJhbWVfZGlnIDEKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTYwCiAgICAvLyBhbW91bnQ9ZWFybmluZ3NfZGlzdHJpYnV0aW9uLnVzZXIubmF0aXZlLAogICAgZnJhbWVfZGlnIDQKICAgIGR1cAogICAgY292ZXIgMgogICAgZXh0cmFjdCAwIDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo5NTctOTU4CiAgICAvLyAjIFNlbmQgdmFsaWRhdG9yIGVhcm5pbmdzIHRvIFZhbGlkYXRvckFkCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICBpbnRjXzEgLy8gcGF5CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTU3LTk2MQogICAgLy8gIyBTZW5kIHZhbGlkYXRvciBlYXJuaW5ncyB0byBWYWxpZGF0b3JBZAogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXZhbF9hcHAuYWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ9ZWFybmluZ3NfZGlzdHJpYnV0aW9uLnVzZXIubmF0aXZlLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTYzLTk2NwogICAgLy8gIyBTZW5kIHBsYXRmb3JtIGVhcm5pbmdzIHRvIE5vdGljZWJvYXJkCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgcmVjZWl2ZXI9cGxhX2FwcC5hZGRyZXNzLAogICAgLy8gICAgIGFtb3VudD1lYXJuaW5nc19kaXN0cmlidXRpb24ucGxhdGZvcm0ubmF0aXZlLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo5NjUKICAgIC8vIHJlY2VpdmVyPXBsYV9hcHAuYWRkcmVzcywKICAgIGZyYW1lX2RpZyAyCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojk2NgogICAgLy8gYW1vdW50PWVhcm5pbmdzX2Rpc3RyaWJ1dGlvbi5wbGF0Zm9ybS5uYXRpdmUsCiAgICBzd2FwCiAgICBleHRyYWN0IDggOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojk2My05NjQKICAgIC8vICMgU2VuZCBwbGF0Zm9ybSBlYXJuaW5ncyB0byBOb3RpY2Vib2FyZAogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50Y18xIC8vIHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojk2My05NjcKICAgIC8vICMgU2VuZCBwbGF0Zm9ybSBlYXJuaW5ncyB0byBOb3RpY2Vib2FyZAogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXBsYV9hcHAuYWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ9ZWFybmluZ3NfZGlzdHJpYnV0aW9uLnBsYXRmb3JtLm5hdGl2ZSwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojk2OS05NzAKICAgIC8vICMgU2VuZCBwYXJ0bmVyIGVhcm5pbmdzIHRvIHBhcnRuZXJfYWRkcmVzcyBpZiBpdCBpcyBub24temVybwogICAgLy8gaWYgcGFydG5lciAhPSBHbG9iYWwuemVyb19hZGRyZXNzOgogICAgZnJhbWVfZGlnIDMKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgIT0KICAgIGJ6IF9kaXN0cmlidXRlX2Vhcm5pbmdzX2FmdGVyX2lmX2Vsc2VAMjcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTcxLTk3MgogICAgLy8gIyBUcnkgc2VuZGluZyBwYXJ0bmVyIGVhcm5pbmdzIHRvIHBhcnRuZXJfYWRkcmVzcwogICAgLy8gaWYgb3AuYmFsYW5jZShwYXJ0bmVyKSA+PSBHbG9iYWwubWluX2JhbGFuY2U6CiAgICBmcmFtZV9kaWcgMwogICAgYmFsYW5jZQogICAgZ2xvYmFsIE1pbkJhbGFuY2UKICAgID49CiAgICBieiBfZGlzdHJpYnV0ZV9lYXJuaW5nc19hZnRlcl9pZl9lbHNlQDI3CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojk3My05NzYKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1wYXJ0bmVyLAogICAgLy8gICAgIGFtb3VudD1hbW91bnRfcGFydG5lciwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIGZyYW1lX2RpZyAtMQogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGZyYW1lX2RpZyAzCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojk3MwogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50Y18xIC8vIHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojk3My05NzYKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1wYXJ0bmVyLAogICAgLy8gICAgIGFtb3VudD1hbW91bnRfcGFydG5lciwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CgpfZGlzdHJpYnV0ZV9lYXJuaW5nc19hZnRlcl9pZl9lbHNlQDI3OgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo5NzgKICAgIC8vIHJldHVybiBlYXJuaW5nc19kaXN0cmlidXRpb24uY29weSgpCiAgICBmcmFtZV9kaWcgNAogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuaGVscGVycy5jb21tb24uY2FsY19lYXJuaW5ncyhhbW91bnQ6IHVpbnQ2NCwgY29tbWlzc2lvbjogdWludDY0LCBhc3NldF9pZDogdWludDY0KSAtPiBieXRlczoKY2FsY19lYXJuaW5nczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9oZWxwZXJzL2NvbW1vbi5weTo3MzQtNzM5CiAgICAvLyBAc3Vicm91dGluZQogICAgLy8gZGVmIGNhbGNfZWFybmluZ3MoCiAgICAvLyAgICAgYW1vdW50OiBVSW50NjQsCiAgICAvLyAgICAgY29tbWlzc2lvbjogVUludDY0LAogICAgLy8gICAgIGFzc2V0X2lkOiBVSW50NjQsCiAgICAvLyApIC0+IEVhcm5pbmdzRGlzdHJpYnV0aW9uOgogICAgcHJvdG8gMyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvaGVscGVycy9jb21tb24ucHk6NzU5CiAgICAvLyB0bXAgPSBvcC5tdWx3KGFtb3VudCwgY29tbWlzc2lvbikKICAgIGZyYW1lX2RpZyAtMwogICAgZnJhbWVfZGlnIC0yCiAgICBtdWx3CiAgICAvLyBzbWFydF9jb250cmFjdHMvaGVscGVycy9jb21tb24ucHk6NzYwCiAgICAvLyBwbGF0X2Vhcm4gPSBvcC5kaXZ3KHRtcFswXSwgdG1wWzFdLCBVSW50NjQoQ09NTUlTU0lPTl9NQVgpKQogICAgcHVzaGludCAxMDAwMDAwIC8vIDEwMDAwMDAKICAgIGRpdncKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9oZWxwZXJzL2NvbW1vbi5weTo3NjEKICAgIC8vIHVzZXJfZWFybiA9IGFtb3VudCAtIHBsYXRfZWFybgogICAgZnJhbWVfZGlnIC0zCiAgICBkaWcgMQogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5Ojc2NAogICAgLy8gdXNlcj1hcmM0LlVJbnQ2NCh1c2VyX2Vhcm4pLAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5Ojc2NQogICAgLy8gcGxhdGZvcm09YXJjNC5VSW50NjQocGxhdF9lYXJuKSwKICAgIHN3YXAKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9oZWxwZXJzL2NvbW1vbi5weTo3NjYKICAgIC8vIGFzc2V0X2lkPWFyYzQuVUludDY0KGFzc2V0X2lkKSwKICAgIGZyYW1lX2RpZyAtMQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5Ojc2My03NjcKICAgIC8vIHJldHVybiBFYXJuaW5nc0Rpc3RyaWJ1dGlvbigKICAgIC8vICAgICB1c2VyPWFyYzQuVUludDY0KHVzZXJfZWFybiksCiAgICAvLyAgICAgcGxhdGZvcm09YXJjNC5VSW50NjQocGxhdF9lYXJuKSwKICAgIC8vICAgICBhc3NldF9pZD1hcmM0LlVJbnQ2NChhc3NldF9pZCksCiAgICAvLyApCiAgICBjb3ZlciAyCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmRlbGVnYXRvcl9jb250cmFjdC5jb250cmFjdC5EZWxlZ2F0b3JDb250cmFjdC5icmVhY2hfbGltaXRzKCkgLT4gYnl0ZXM6CmJyZWFjaF9saW1pdHM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjY2MS02NjQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgYnJlYWNoX2xpbWl0cygKICAgIC8vICAgICBzZWxmLAogICAgLy8gKSAtPiBCcmVhY2hMaW1pdHNSZXR1cm46CiAgICBwcm90byAwIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NjgyCiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCBFUlJPUl9DQUxMRURfQllfTk9UX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NjgzCiAgICAvLyBhc3NlcnQgc2VsZi5zdGF0ZSA9PSBCeXRlcyhTVEFURV9MSVZFKSwgRVJST1JfTk9UX1NUQVRFX0xJVkUKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0ZSBleGlzdHMKICAgIGJ5dGVjIDYgLy8gMHgwNQogICAgPT0KICAgIGFzc2VydCAvLyBDYW5ub3QgYmUgY2FsbGVkIGZyb20gb3RoZXIgc3RhdGUgdGhhbiBMSVZFLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2ODUKICAgIC8vIGFzc2VydCBzZWxmLnJvdW5kX2VuZCA+IEdsb2JhbC5yb3VuZCwgRVJST1JfQUxSRUFEWV9FWFBJUkVECiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMyAvLyAicm91bmRfZW5kIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnJvdW5kX2VuZCBleGlzdHMKICAgIGdsb2JhbCBSb3VuZAogICAgPgogICAgYXNzZXJ0IC8vIENhbm5vdCBiZSBjYWxsZWQgd2hlbiB0aGUgY29udHJhY3QgaGFzIGFscmVhZHkgZXhwaXJlZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6Njg3CiAgICAvLyBhc3NlcnQgc2VsZi5yb3VuZF9icmVhY2hfbGFzdCArIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19iYWxhbmNlLnZhbHVlLnJvdW5kc19icmVhY2gubmF0aXZlIDwgR2xvYmFsLnJvdW5kLCBcCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTYgLy8gInJvdW5kX2JyZWFjaF9sYXN0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnJvdW5kX2JyZWFjaF9sYXN0IGV4aXN0cwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDEyIC8vICJCIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbGVnYXRpb25fdGVybXNfYmFsYW5jZSBleGlzdHMKICAgIGV4dHJhY3QgMTYgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgICsKICAgIGdsb2JhbCBSb3VuZAogICAgPAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2ODctNjg4CiAgICAvLyBhc3NlcnQgc2VsZi5yb3VuZF9icmVhY2hfbGFzdCArIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19iYWxhbmNlLnZhbHVlLnJvdW5kc19icmVhY2gubmF0aXZlIDwgR2xvYmFsLnJvdW5kLCBcCiAgICAvLyAgICAgRVJST1JfTElNSVRfQlJFQUNIX1RPT19FQVJMWQogICAgYXNzZXJ0IC8vIE5vdCBlbm91Z2ggcm91bmRzIGhhdmUgcGFzc2VkIHNpbmNlIGxhc3QgbGltaXQgYnJlYWNoIGV2ZW50LgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2OTAKICAgIC8vIGFzc2VydCBub3Qgc2VsZi5faXNfZWxpZ2libGUoKS5uYXRpdmUsIEVSUk9SX0lTX1NUSUxMX0VMSUdJQkxFCiAgICBjYWxsc3ViIF9pc19lbGlnaWJsZQogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgIQogICAgYXNzZXJ0IC8vIERlbGVnYXRvciBiZW5lZmljaWFyeSBpcyBzdGlsbCBlbGlnaWJsZSBhY2NvcmRpbmcgdG8gdGhlIGFncmVlZCBsaW1pdHMuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjY5Mi02OTMKICAgIC8vICMgVXBkYXRlIGxpbWl0IGJyZWFjaCBldmVudCBjb3VudGVyCiAgICAvLyBzZWxmLmNudF9icmVhY2hfZGVsICs9IDEKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMyAvLyAiY250X2JyZWFjaF9kZWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuY250X2JyZWFjaF9kZWwgZXhpc3RzCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgYnl0ZWMgMTMgLy8gImNudF9icmVhY2hfZGVsIgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6Njk0CiAgICAvLyBzZWxmLnJvdW5kX2JyZWFjaF9sYXN0ID0gR2xvYmFsLnJvdW5kCiAgICBieXRlYyAxNiAvLyAicm91bmRfYnJlYWNoX2xhc3QiCiAgICBnbG9iYWwgUm91bmQKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjY5Ni02OTcKICAgIC8vICMgQ2xhaW0gZWFybmluZ3MgdXAgdG8gdGhpcyByb3VuZAogICAgLy8gZWFybmluZ3NfZGlzdHJpYnV0aW9uID0gc2VsZi5jb250cmFjdF9jbGFpbSgpCiAgICBjYWxsc3ViIGNvbnRyYWN0X2NsYWltCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjY5OQogICAgLy8gbWF4X2JyZWFjaF9yZWFjaGVkID0gRmFsc2UKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjcwMAogICAgLy8gbXNnID0gTm90aWZpY2F0aW9uTWVzc2FnZS5mcm9tX2J5dGVzKE1TR19DT1JFX0JSRUFDSF9MSU1JVFNfRVJST1IpCiAgICBwdXNoYnl0ZXMgMHg0ZDY1NzM3MzYxNjc2NTIwNjY3MjZmNmQyMDU2NjE2YzYxNzIzYTIwNTk2Zjc1NzIyMDYyNjE2YzYxNmU2MzY1MjA2OTczMjA2Zjc1NzQ3MzY5NjQ2NTIwNzQ2ODY1MjA2YzY5NmQ2OTc0NzMyMDYxNjc3MjY1NjU2NDIwNzc2OTc0NjgyMDc0Njg2NTIwNmU2ZjY0NjUyMDcyNzU2ZTZlNjU3MjJlMjA0MzZmNzI3MjY1NjM3NDIwNjk3NDIxMjAyMDIwMjAyMAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3MDEKICAgIC8vIGlmIHNlbGYuY250X2JyZWFjaF9kZWwgPj0gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2JhbGFuY2UudmFsdWUuY250X2JyZWFjaF9kZWxfbWF4OgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDEyIC8vICJCIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbGVnYXRpb25fdGVybXNfYmFsYW5jZSBleGlzdHMKICAgIGV4dHJhY3QgOCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDEzIC8vICJjbnRfYnJlYWNoX2RlbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jbnRfYnJlYWNoX2RlbCBleGlzdHMKICAgIGl0b2IKICAgIGI8PQogICAgYnogYnJlYWNoX2xpbWl0c19hZnRlcl9pZl9lbHNlQDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzAyLTcwMwogICAgLy8gIyBDaGFuZ2Ugc3RhdGUgdG8gRU5ERURfTElNSVRTCiAgICAvLyBzZWxmLnN0YXRlID0gQnl0ZXMoU1RBVEVfRU5ERURfTElNSVRTKQogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBwdXNoYnl0ZXMgMHgxMgogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzA0LTcwNQogICAgLy8gIyBNYXJrIGVuZCBvZiBjb250cmFjdAogICAgLy8gc2VsZi5yb3VuZF9lbmRlZCA9IEdsb2JhbC5yb3VuZAogICAgYnl0ZWMgOCAvLyAicm91bmRfZW5kZWQiCiAgICBnbG9iYWwgUm91bmQKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjcwNi03MDcKICAgIC8vICMgTWFyayB0aGF0IG1heGltdW0gbnVtYmVyIG9mIGJyZWFjaGVzIGhhcyBiZWVuIHJlYWNoZWQKICAgIC8vIG1heF9icmVhY2hfcmVhY2hlZCA9IFRydWUKICAgIGludGNfMSAvLyAxCiAgICBmcmFtZV9idXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzA4CiAgICAvLyBtc2cgPSBOb3RpZmljYXRpb25NZXNzYWdlLmZyb21fYnl0ZXMoTVNHX0NPUkVfQlJFQUNIX0xJTUlUU19FTkQpCiAgICBwdXNoYnl0ZXMgMHg0ZDY1NzM3MzYxNjc2NTIwNjY3MjZmNmQyMDU2NjE2YzYxNzIzYTIwNTk2Zjc1NzIyMDYzNmY2ZTc0NzI2MTYzNzQyMDY4NjE3MzIwNjU2ZTY0NjU2NDIwNjI2NTYzNjE3NTczNjUyMDc5NmY3NTIwNjI3MjY1NjE2MzY4NjU2NDIwNzQ2ODY1MjA3NDY1NzI2ZDczMjA3NDZmNmYyMDZkNjE2ZTc5MjA3NDY5NmQ2NTczMmUyMDIwMjAyMDIwMjAyMDIwMjAyMAogICAgZnJhbWVfYnVyeSAyCgpicmVhY2hfbGltaXRzX2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzExCiAgICAvLyBtYXhfYnJlYWNoX3JlYWNoZWQgPSBhcmM0LkJvb2wobWF4X2JyZWFjaF9yZWFjaGVkKSwKICAgIGJ5dGVjIDE5IC8vIDB4MDAKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9kaWcgMQogICAgc2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjcxMwogICAgLy8gZGVsX21hbmFnZXI9YXJjNC5BZGRyZXNzKHNlbGYuZGVsX21hbmFnZXIpLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gImRlbF9tYW5hZ2VyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbF9tYW5hZ2VyIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3MTAtNzE1CiAgICAvLyByZXR1cm4gQnJlYWNoTGltaXRzUmV0dXJuKAogICAgLy8gICAgIG1heF9icmVhY2hfcmVhY2hlZCA9IGFyYzQuQm9vbChtYXhfYnJlYWNoX3JlYWNoZWQpLAogICAgLy8gICAgIGVhcm5pbmdzX2Rpc3RyaWJ1dGlvbj1lYXJuaW5nc19kaXN0cmlidXRpb24uY29weSgpLAogICAgLy8gICAgIGRlbF9tYW5hZ2VyPWFyYzQuQWRkcmVzcyhzZWxmLmRlbF9tYW5hZ2VyKSwKICAgIC8vICAgICBtc2c9bXNnLmNvcHkoKSwKICAgIC8vICkKICAgIHN3YXAKICAgIGZyYW1lX2RpZyAwCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZnJhbWVfZGlnIDIKICAgIGNvbmNhdAogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuZGVsZWdhdG9yX2NvbnRyYWN0LmNvbnRyYWN0LkRlbGVnYXRvckNvbnRyYWN0LmNvbnRyYWN0X2NsYWltKCkgLT4gYnl0ZXM6CmNvbnRyYWN0X2NsYWltOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo4MzAtODMzCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGNvbnRyYWN0X2NsYWltKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyApIC0+IEVhcm5pbmdzRGlzdHJpYnV0aW9uOgogICAgcHJvdG8gMCAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojg0NwogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgRVJST1JfQ0FMTEVEX0JZX05PVF9DUkVBVE9SCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHNtYXJ0IGNvbnRyYWN0IGNyZWF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojg0OAogICAgLy8gYXNzZXJ0IHNlbGYuc3RhdGUgPT0gQnl0ZXMoU1RBVEVfTElWRSksIEVSUk9SX05PVF9TVEFURV9MSVZFCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdGUgZXhpc3RzCiAgICBieXRlYyA2IC8vIDB4MDUKICAgID09CiAgICBhc3NlcnQgLy8gQ2Fubm90IGJlIGNhbGxlZCBmcm9tIG90aGVyIHN0YXRlIHRoYW4gTElWRS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6ODUwCiAgICAvLyBhc3NlcnQgc2VsZi5yb3VuZF9jbGFpbV9sYXN0IDwgR2xvYmFsLnJvdW5kLCBFUlJPUl9PUEVSQVRJT05fRkVFX0FMUkVBRFlfQ0xBSU1FRF9BVF9ST1VORAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDkgLy8gInJvdW5kX2NsYWltX2xhc3QiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfY2xhaW1fbGFzdCBleGlzdHMKICAgIGdsb2JhbCBSb3VuZAogICAgPAogICAgYXNzZXJ0IC8vIE9wZXJhdGlvbmFsIGZlZSBoYXMgYWxyZWFkeSBiZWVuIGNsYWltZWQgdXAgdG8gdGhpcyByb3VuZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6ODUyCiAgICAvLyBpZiBHbG9iYWwucm91bmQgPiBzZWxmLnJvdW5kX2VuZDoKICAgIGdsb2JhbCBSb3VuZAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzMgLy8gInJvdW5kX2VuZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5yb3VuZF9lbmQgZXhpc3RzCiAgICA+CiAgICBieiBjb250cmFjdF9jbGFpbV9lbHNlX2JvZHlAMgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo4NTMKICAgIC8vIHJvdW5kX2NsYWltX3RvID0gc2VsZi5yb3VuZF9lbmQKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18zIC8vICJyb3VuZF9lbmQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfZW5kIGV4aXN0cwogICAgYiBjb250cmFjdF9jbGFpbV9hZnRlcl9pZl9lbHNlQDMKCmNvbnRyYWN0X2NsYWltX2Vsc2VfYm9keUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo4NTUKICAgIC8vIHJvdW5kX2NsYWltX3RvID0gR2xvYmFsLnJvdW5kCiAgICBnbG9iYWwgUm91bmQKCmNvbnRyYWN0X2NsYWltX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6ODU4CiAgICAvLyBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5mZWVfcm91bmQubmF0aXZlLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gIkciCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsIGV4aXN0cwogICAgZXh0cmFjdCA4IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojg2MAogICAgLy8gc2VsZi5yb3VuZF9jbGFpbV9sYXN0LAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDkgLy8gInJvdW5kX2NsYWltX2xhc3QiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfY2xhaW1fbGFzdCBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6ODU3LTg2MQogICAgLy8gZmVlX29wZXJhdGlvbmFsX2Vhcm5lZCA9IGNhbGNfZmVlX29wZXJhdGlvbmFsKAogICAgLy8gICAgIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsLnZhbHVlLmZlZV9yb3VuZC5uYXRpdmUsCiAgICAvLyAgICAgcm91bmRfY2xhaW1fdG8sCiAgICAvLyAgICAgc2VsZi5yb3VuZF9jbGFpbV9sYXN0LAogICAgLy8gKQogICAgZGlnIDIKICAgIHN3YXAKICAgIGNhbGxzdWIgY2FsY19mZWVfb3BlcmF0aW9uYWwKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6ODYzCiAgICAvLyBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5mZWVfcm91bmRfcGFydG5lci5uYXRpdmUsCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiRyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwgZXhpc3RzCiAgICBleHRyYWN0IDY0IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojg2NQogICAgLy8gc2VsZi5yb3VuZF9jbGFpbV9sYXN0LAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDkgLy8gInJvdW5kX2NsYWltX2xhc3QiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfY2xhaW1fbGFzdCBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6ODYyLTg2NgogICAgLy8gZmVlX29wZXJhdGlvbmFsX2Vhcm5lZF9wYXJ0bmVyID0gY2FsY19mZWVfb3BlcmF0aW9uYWwoCiAgICAvLyAgICAgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUuZmVlX3JvdW5kX3BhcnRuZXIubmF0aXZlLAogICAgLy8gICAgIHJvdW5kX2NsYWltX3RvLAogICAgLy8gICAgIHNlbGYucm91bmRfY2xhaW1fbGFzdCwKICAgIC8vICkKICAgIGRpZyAzCiAgICBzd2FwCiAgICBjYWxsc3ViIGNhbGNfZmVlX29wZXJhdGlvbmFsCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojg2Ny04NzAKICAgIC8vIGVhcm5pbmdzX2Rpc3RyaWJ1dGlvbiA9IHNlbGYuX2Rpc3RyaWJ1dGVfZWFybmluZ3MoCiAgICAvLyAgICAgZmVlX29wZXJhdGlvbmFsX2Vhcm5lZCwKICAgIC8vICAgICBmZWVfb3BlcmF0aW9uYWxfZWFybmVkX3BhcnRuZXIsCiAgICAvLyApCiAgICBjYWxsc3ViIF9kaXN0cmlidXRlX2Vhcm5pbmdzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojg3MgogICAgLy8gc2VsZi5yb3VuZF9jbGFpbV9sYXN0ID0gcm91bmRfY2xhaW1fdG8KICAgIGJ5dGVjIDkgLy8gInJvdW5kX2NsYWltX2xhc3QiCiAgICB1bmNvdmVyIDIKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojg3NAogICAgLy8gcmV0dXJuIGVhcm5pbmdzX2Rpc3RyaWJ1dGlvbi5jb3B5KCkKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5kZWxlZ2F0b3JfY29udHJhY3QuY29udHJhY3QuRGVsZWdhdG9yQ29udHJhY3QuYnJlYWNoX3BheSgpIC0+IGJ5dGVzOgpicmVhY2hfcGF5OgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3MTctNzIwCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGJyZWFjaF9wYXkoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICkgLT4gTWVzc2FnZToKICAgIHByb3RvIDAgMQogICAgcHVzaGJ5dGVzICIiCiAgICBkdXBuIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzMzCiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCBFUlJPUl9DQUxMRURfQllfTk9UX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzM0CiAgICAvLyBhc3NlcnQgc2VsZi5zdGF0ZSA9PSBCeXRlcyhTVEFURV9MSVZFKSBvciBzZWxmLnN0YXRlID09IEJ5dGVzKFNUQVRFX1NVQk1JVFRFRCkgb3Igc2VsZi5zdGF0ZSA9PSBCeXRlcyhTVEFURV9SRUFEWSksIEVSUk9SX05PVF9TVEFURV9MSVZFX09SX1NVQk1JVFRFRF9PUl9SRUFEWSAgIyBub3FhOiBFNTAxCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdGUgZXhpc3RzCiAgICBieXRlYyA2IC8vIDB4MDUKICAgID09CiAgICBibnogYnJlYWNoX3BheV9ib29sX3RydWVAMwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gInN0YXRlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXRlIGV4aXN0cwogICAgYnl0ZWMgMTUgLy8gMHgwNAogICAgPT0KICAgIGJueiBicmVhY2hfcGF5X2Jvb2xfdHJ1ZUAzCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdGUgZXhpc3RzCiAgICBieXRlYyAxNCAvLyAweDAzCiAgICA9PQogICAgYnogYnJlYWNoX3BheV9ib29sX2ZhbHNlQDQKCmJyZWFjaF9wYXlfYm9vbF90cnVlQDM6CiAgICBpbnRjXzEgLy8gMQogICAgYiBicmVhY2hfcGF5X2Jvb2xfbWVyZ2VANQoKYnJlYWNoX3BheV9ib29sX2ZhbHNlQDQ6CiAgICBpbnRjXzAgLy8gMAoKYnJlYWNoX3BheV9ib29sX21lcmdlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjczNAogICAgLy8gYXNzZXJ0IHNlbGYuc3RhdGUgPT0gQnl0ZXMoU1RBVEVfTElWRSkgb3Igc2VsZi5zdGF0ZSA9PSBCeXRlcyhTVEFURV9TVUJNSVRURUQpIG9yIHNlbGYuc3RhdGUgPT0gQnl0ZXMoU1RBVEVfUkVBRFkpLCBFUlJPUl9OT1RfU1RBVEVfTElWRV9PUl9TVUJNSVRURURfT1JfUkVBRFkgICMgbm9xYTogRTUwMQogICAgYXNzZXJ0IC8vIENhbm5vdCBiZSBjYWxsZWQgZnJvbSBvdGhlciBzdGF0ZSB0aGFuIExJVkUgb3IgU1VCTUlUVEVEIG9yIFJFQURZLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3MzYKICAgIC8vIGFzc2VydCBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5mZWVfYXNzZXRfaWQgIT0gVUludDY0KEFMR09fQVNBX0lEKSwgRVJST1JfQUxHT19JU19QRVJNSVNTSU9OTEVTUwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gIkciCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsIGV4aXN0cwogICAgZXh0cmFjdCAyNCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgaW50Y18wIC8vIDAKICAgIGl0b2IKICAgIGIhPQogICAgYXNzZXJ0IC8vIEFMR08gY2Fubm90IGJlIGZyb3plbiBvciBjbGF3ZWQgYmFjay4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzM4CiAgICAvLyBmZWVfcm91bmQgPSBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5mZWVfcm91bmQubmF0aXZlCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiRyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwgZXhpc3RzCiAgICBleHRyYWN0IDggOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGZyYW1lX2J1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3MzkKICAgIC8vIGZlZV9yb3VuZF9wYXJ0bmVyID0gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUuZmVlX3JvdW5kX3BhcnRuZXIubmF0aXZlCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiRyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwgZXhpc3RzCiAgICBleHRyYWN0IDY0IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICBmcmFtZV9idXJ5IDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzQwCiAgICAvLyBmZWVfc2V0dXAgPSBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5mZWVfc2V0dXAubmF0aXZlCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiRyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwgZXhpc3RzCiAgICBleHRyYWN0IDE2IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICBmcmFtZV9idXJ5IDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzQxCiAgICAvLyBmZWVfc2V0dXBfcGFydG5lciA9IHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsLnZhbHVlLmZlZV9zZXR1cF9wYXJ0bmVyLm5hdGl2ZQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gIkciCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsIGV4aXN0cwogICAgZXh0cmFjdCA3MiA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnRvaQogICAgZnJhbWVfYnVyeSA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojc0MwogICAgLy8gYXNzZXQgPSBBc3NldChzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5mZWVfYXNzZXRfaWQubmF0aXZlKQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gIkciCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsIGV4aXN0cwogICAgZXh0cmFjdCAyNCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnRvaQogICAgZHVwCiAgICBmcmFtZV9idXJ5IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzQ0CiAgICAvLyBpZiBhc3NldC5mcm96ZW4oR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcyk6CiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgc3dhcAogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRGcm96ZW4KICAgIGFzc2VydCAvLyBhY2NvdW50IG9wdGVkIGludG8gYXNzZXQKICAgIGJueiBicmVhY2hfcGF5X2FmdGVyX2lmX2Vsc2VAMTkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzQ3CiAgICAvLyBpZiBzZWxmLnN0YXRlID09IEJ5dGVzKFNUQVRFX1JFQURZKToKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0ZSBleGlzdHMKICAgIGJ5dGVjIDE0IC8vIDB4MDMKICAgID09CiAgICBieiBicmVhY2hfcGF5X2Vsc2VfYm9keUA5CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojc0OAogICAgLy8gYmFzZV9mZWUgPSBmZWVfc2V0dXAgKyBzZWxmLmZlZV9vcGVyYXRpb25hbAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDEwIC8vICJmZWVfb3BlcmF0aW9uYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZmVlX29wZXJhdGlvbmFsIGV4aXN0cwogICAgZnJhbWVfZGlnIDMKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzQ5CiAgICAvLyBwYXJ0bmVyX2ZlZSA9IGZlZV9zZXR1cF9wYXJ0bmVyICsgc2VsZi5mZWVfb3BlcmF0aW9uYWxfcGFydG5lcgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDExIC8vICJmZWVfb3BlcmF0aW9uYWxfcGFydG5lciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5mZWVfb3BlcmF0aW9uYWxfcGFydG5lciBleGlzdHMKICAgIGZyYW1lX2RpZyA0CiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojc1MAogICAgLy8gYW10ID0gYmFzZV9mZWUgKyBwYXJ0bmVyX2ZlZQogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3NTEKICAgIC8vIGFzc2VydCBhc3NldC5iYWxhbmNlKEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MpIDwgYW10LCBFUlJPUl9FTk9VR0hfRlVORFNfRk9SX1NFVFVQX0FORF9PUEVSQVRJT05BTF9GRUUgICMgbm9xYTogRTUwMQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGZyYW1lX2RpZyAwCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IG9wdGVkIGludG8gYXNzZXQKICAgID4KICAgIGFzc2VydCAvLyBDb250cmFjdCBoYXMgc3VmZmljaWVudCBmdW5kcyB0byBwYXkgdGhlIHNldHVwIGFuZCBvcGVyYXRpb25hbCBmZWUuCiAgICBiIGJyZWFjaF9wYXlfYWZ0ZXJfaWZfZWxzZUAxOQoKYnJlYWNoX3BheV9lbHNlX2JvZHlAOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzUyCiAgICAvLyBlbGlmIHNlbGYuc3RhdGUgPT0gQnl0ZXMoU1RBVEVfU1VCTUlUVEVEKToKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0ZSBleGlzdHMKICAgIGJ5dGVjIDE1IC8vIDB4MDQKICAgID09CiAgICBieiBicmVhY2hfcGF5X2Vsc2VfYm9keUAxMQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3NTMKICAgIC8vIGJhc2VfZmVlID0gc2VsZi5mZWVfb3BlcmF0aW9uYWwKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMCAvLyAiZmVlX29wZXJhdGlvbmFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmZlZV9vcGVyYXRpb25hbCBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzU0CiAgICAvLyBwYXJ0bmVyX2ZlZSA9IHNlbGYuZmVlX29wZXJhdGlvbmFsX3BhcnRuZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMSAvLyAiZmVlX29wZXJhdGlvbmFsX3BhcnRuZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZmVlX29wZXJhdGlvbmFsX3BhcnRuZXIgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojc1NQogICAgLy8gYW10ID0gYmFzZV9mZWUgKyBwYXJ0bmVyX2ZlZQogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3NTYKICAgIC8vIGFzc2VydCBhc3NldC5iYWxhbmNlKEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MpIDwgYW10LCBFUlJPUl9FTk9VR0hfRlVORFNfRk9SX09QRVJBVElPTkFMX0ZFRQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGZyYW1lX2RpZyAwCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IG9wdGVkIGludG8gYXNzZXQKICAgID4KICAgIGFzc2VydCAvLyBDb250cmFjdCBoYXMgc3VmZmljaWVudCBmdW5kcyB0byBwYXkgdGhlIGZ1bGwgb3BlcmF0aW9uYWwgZmVlLgogICAgYiBicmVhY2hfcGF5X2FmdGVyX2lmX2Vsc2VAMTkKCmJyZWFjaF9wYXlfZWxzZV9ib2R5QDExOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3NTcKICAgIC8vIGVsaWYgc2VsZi5zdGF0ZSA9PSBCeXRlcyhTVEFURV9MSVZFKToKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0ZSBleGlzdHMKICAgIGJ5dGVjIDYgLy8gMHgwNQogICAgPT0KICAgIGJ6IGJyZWFjaF9wYXlfYWZ0ZXJfaWZfZWxzZUAxOQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3NTgKICAgIC8vIGlmIEdsb2JhbC5yb3VuZCA8IHNlbGYucm91bmRfZW5kOgogICAgZ2xvYmFsIFJvdW5kCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMyAvLyAicm91bmRfZW5kIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnJvdW5kX2VuZCBleGlzdHMKICAgIDwKICAgIGJ6IGJyZWFjaF9wYXlfZWxzZV9ib2R5QDE0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojc1OQogICAgLy8gdG1wX3IgPSBHbG9iYWwucm91bmQKICAgIGdsb2JhbCBSb3VuZAogICAgYiBicmVhY2hfcGF5X2FmdGVyX2lmX2Vsc2VAMTUKCmJyZWFjaF9wYXlfZWxzZV9ib2R5QDE0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3NjEKICAgIC8vIHRtcF9yID0gc2VsZi5yb3VuZF9lbmQKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18zIC8vICJyb3VuZF9lbmQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfZW5kIGV4aXN0cwoKYnJlYWNoX3BheV9hZnRlcl9pZl9lbHNlQDE1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3NjYKICAgIC8vIHJvdW5kX3N0YXJ0PXNlbGYucm91bmRfY2xhaW1fbGFzdCwKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA5IC8vICJyb3VuZF9jbGFpbV9sYXN0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnJvdW5kX2NsYWltX2xhc3QgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojc2My03NjcKICAgIC8vIGJhc2VfZmVlID0gY2FsY19mZWVfb3BlcmF0aW9uYWwoCiAgICAvLyAgICAgZmVlX3JvdW5kPWZlZV9yb3VuZCwKICAgIC8vICAgICByb3VuZF9lbmQ9dG1wX3IsCiAgICAvLyAgICAgcm91bmRfc3RhcnQ9c2VsZi5yb3VuZF9jbGFpbV9sYXN0LAogICAgLy8gKQogICAgZnJhbWVfZGlnIDEKICAgIGRpZyAyCiAgICB1bmNvdmVyIDIKICAgIGNhbGxzdWIgY2FsY19mZWVfb3BlcmF0aW9uYWwKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzcxCiAgICAvLyByb3VuZF9zdGFydD1zZWxmLnJvdW5kX2NsYWltX2xhc3QsCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgOSAvLyAicm91bmRfY2xhaW1fbGFzdCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5yb3VuZF9jbGFpbV9sYXN0IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3NjgtNzcyCiAgICAvLyBwYXJ0bmVyX2ZlZSA9IGNhbGNfZmVlX29wZXJhdGlvbmFsKAogICAgLy8gICAgIGZlZV9yb3VuZD1mZWVfcm91bmRfcGFydG5lciwKICAgIC8vICAgICByb3VuZF9lbmQ9dG1wX3IsCiAgICAvLyAgICAgcm91bmRfc3RhcnQ9c2VsZi5yb3VuZF9jbGFpbV9sYXN0LAogICAgLy8gKQogICAgZnJhbWVfZGlnIDIKICAgIHVuY292ZXIgMwogICAgdW5jb3ZlciAyCiAgICBjYWxsc3ViIGNhbGNfZmVlX29wZXJhdGlvbmFsCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojc3MwogICAgLy8gYW10ID0gYmFzZV9mZWUgKyBwYXJ0bmVyX2ZlZQogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3NzQKICAgIC8vIGFzc2VydCBhc3NldC5iYWxhbmNlKEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MpIDwgYW10LCBFUlJPUl9FTk9VR0hfRlVORFNfRk9SX0VBUk5FRF9PUEVSQVRJT05BTF9GRUUgICMgbm9xYTogRTUwMQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGZyYW1lX2RpZyAwCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IG9wdGVkIGludG8gYXNzZXQKICAgID4KICAgIGFzc2VydCAvLyBDb250cmFjdCBoYXMgc3VmZmljaWVudCBmdW5kcyB0byBwYXkgdGhlIGVhcm5lZCBvcGVyYXRpb25hbCBmZWUuCgpicmVhY2hfcGF5X2FmdGVyX2lmX2Vsc2VAMTk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojc3Ni03NzcKICAgIC8vICMgQ2hhbmdlIHN0YXRlIHRvIEVOREVEX0NBTk5PVF9QQVkKICAgIC8vIHNlbGYuc3RhdGUgPSBCeXRlcyhTVEFURV9FTkRFRF9DQU5OT1RfUEFZKQogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBwdXNoYnl0ZXMgMHgxNgogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6Nzc4LTc3OQogICAgLy8gIyBNYXJrIGVuZCBvZiBjb250cmFjdAogICAgLy8gc2VsZi5yb3VuZF9lbmRlZCA9IEdsb2JhbC5yb3VuZAogICAgYnl0ZWMgOCAvLyAicm91bmRfZW5kZWQiCiAgICBnbG9iYWwgUm91bmQKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojc4MwogICAgLy8gZGVsX21hbmFnZXI9YXJjNC5BZGRyZXNzKHNlbGYuZGVsX21hbmFnZXIpLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gImRlbF9tYW5hZ2VyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbF9tYW5hZ2VyIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3ODEKICAgIC8vIG1zZyA9IE5vdGlmaWNhdGlvbk1lc3NhZ2UuZnJvbV9ieXRlcyhNU0dfQ09SRV9CUkVBQ0hfUEFZKQogICAgcHVzaGJ5dGVzIDB4NGQ2NTczNzM2MTY3NjUyMDY2NzI2ZjZkMjA1NjYxNmM2MTcyM2EyMDU0Njg2NTcyNjUyMDY5NzMyMDYxNmUyMDY5NzM3Mzc1NjUyMDc3Njk3NDY4MjA3OTZmNzU3MjIwNzA2MTc5NmQ2NTZlNzQyMDc0NmYyMDc0Njg2NTIwNmU2ZjY0NjUyMDcyNzU2ZTZlNjU3MjJlMjA1OTZmNzUyMDY0NmY2ZTI3NzQyMDczNzQ2MTZiNjUyMDYxNmU3OTZkNmY3MjY1MmUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzgyLTc4NQogICAgLy8gcmV0dXJuIE1lc3NhZ2UoCiAgICAvLyAgICAgZGVsX21hbmFnZXI9YXJjNC5BZGRyZXNzKHNlbGYuZGVsX21hbmFnZXIpLAogICAgLy8gICAgIG1zZz1tc2cuY29weSgpLAogICAgLy8gKQogICAgY29uY2F0CiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5kZWxlZ2F0b3JfY29udHJhY3QuY29udHJhY3QuRGVsZWdhdG9yQ29udHJhY3QuYnJlYWNoX3N1c3BlbmRlZCgpIC0+IGJ5dGVzOgpicmVhY2hfc3VzcGVuZGVkOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3ODctNzkwCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGJyZWFjaF9zdXNwZW5kZWQoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICkgLT4gRWFybmluZ3NEaXN0cmlidXRpb25BbmRNZXNzYWdlOgogICAgcHJvdG8gMCAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjgwNgogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgRVJST1JfQ0FMTEVEX0JZX05PVF9DUkVBVE9SCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHNtYXJ0IGNvbnRyYWN0IGNyZWF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjgwNwogICAgLy8gYXNzZXJ0IHNlbGYuc3RhdGUgPT0gQnl0ZXMoU1RBVEVfTElWRSksIEVSUk9SX05PVF9TVEFURV9MSVZFCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdGUgZXhpc3RzCiAgICBieXRlYyA2IC8vIDB4MDUKICAgID09CiAgICBhc3NlcnQgLy8gQ2Fubm90IGJlIGNhbGxlZCBmcm9tIG90aGVyIHN0YXRlIHRoYW4gTElWRS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6ODA5CiAgICAvLyBhc3NlcnQgc2VsZi5yb3VuZF9lbmQgPiBHbG9iYWwucm91bmQsIEVSUk9SX0FMUkVBRFlfRVhQSVJFRAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzMgLy8gInJvdW5kX2VuZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5yb3VuZF9lbmQgZXhpc3RzCiAgICBnbG9iYWwgUm91bmQKICAgID4KICAgIGFzc2VydCAvLyBDYW5ub3QgYmUgY2FsbGVkIHdoZW4gdGhlIGNvbnRyYWN0IGhhcyBhbHJlYWR5IGV4cGlyZWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjgxMS04MTIKICAgIC8vICMgQ29uZmlybSB0aGF0IGFjY291bnQgd2FzIHN1c3BlbmRlZCBiYXNlZCBvbiBgQWNjdEluY2VudGl2ZUVsaWdpYmxlYCBwYXJhbWV0ZXIKICAgIC8vIGFjY3RfaW5jZW50aXZlX2VsaWdpYmxlX3JhdyA9IG9wLkFjY3RQYXJhbXNHZXQuYWNjdF9pbmNlbnRpdmVfZWxpZ2libGUoc2VsZi5kZWxfYmVuZWZpY2lhcnkpCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNyAvLyAiZGVsX2JlbmVmaWNpYXJ5IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbF9iZW5lZmljaWFyeSBleGlzdHMKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0SW5jZW50aXZlRWxpZ2libGUKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo4MTQKICAgIC8vIGFzc2VydCBub3QgYWNjdF9pbmNlbnRpdmVfZWxpZ2libGUsIEVSUk9SX0FDQ09VTlRfSEFTX05PVF9CRUVOX1NVU1BFTkRFRAogICAgIQogICAgYXNzZXJ0IC8vIEFjY291bnQgaXMgc3RpbGwgcGFydGljaXBhdGluZyBpbiBjb25zZW5zdXMuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjgxNi04MTcKICAgIC8vICMgQ2xhaW0gZWFybmluZ3MgdXAgdG8gdGhpcyByb3VuZAogICAgLy8gZWFybmluZ3NfZGlzdHJpYnV0aW9uID0gc2VsZi5jb250cmFjdF9jbGFpbSgpCiAgICBjYWxsc3ViIGNvbnRyYWN0X2NsYWltCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjgxOC04MTkKICAgIC8vICMgQ2hhbmdlIHN0YXRlIHRvIEVOREVEX1NVU1BFTkRFRAogICAgLy8gc2VsZi5zdGF0ZSA9IEJ5dGVzKFNUQVRFX0VOREVEX1NVU1BFTkRFRCkKICAgIGJ5dGVjXzEgLy8gInN0YXRlIgogICAgcHVzaGJ5dGVzIDB4MTUKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjgyMC04MjEKICAgIC8vICMgTWFyayBlbmQgb2YgY29udHJhY3QKICAgIC8vIHNlbGYucm91bmRfZW5kZWQgPSBHbG9iYWwucm91bmQKICAgIGJ5dGVjIDggLy8gInJvdW5kX2VuZGVkIgogICAgZ2xvYmFsIFJvdW5kCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo4MjYKICAgIC8vIGRlbF9tYW5hZ2VyPWFyYzQuQWRkcmVzcyhzZWxmLmRlbF9tYW5hZ2VyKSwKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJkZWxfbWFuYWdlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxfbWFuYWdlciBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6ODI0LTgyOAogICAgLy8gcmV0dXJuIEVhcm5pbmdzRGlzdHJpYnV0aW9uQW5kTWVzc2FnZSgKICAgIC8vICAgICBlYXJuaW5nc19kaXN0cmlidXRpb249ZWFybmluZ3NfZGlzdHJpYnV0aW9uLmNvcHkoKSwKICAgIC8vICAgICBkZWxfbWFuYWdlcj1hcmM0LkFkZHJlc3Moc2VsZi5kZWxfbWFuYWdlciksCiAgICAvLyAgICAgbXNnPW1zZy5jb3B5KCksCiAgICAvLyApCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6ODIzCiAgICAvLyBtc2cgPSBOb3RpZmljYXRpb25NZXNzYWdlLmZyb21fYnl0ZXMoTVNHX0NPUkVfQlJFQUNIX1NVU1BFTkRFRCkKICAgIHB1c2hieXRlcyAweDRkNjU3MzczNjE2NzY1MjA2NjcyNmY2ZDIwNTY2MTZjNjE3MjNhMjA1NDY4NjUyMDZlNjU3NDc3NmY3MjZiMjA2ODYxNzMyMDczNzU3MzcwNjU2ZTY0NjU2NDIwNzk2Zjc1NzIyMDYxNjM2MzZmNzU2ZTc0MjA2NjcyNmY2ZDIwNzM3NDYxNmI2OTZlNjcyZTIwNTk2Zjc1MjA2NDZmNmUyNzc0MjA3Mzc0NjE2YjY1MjA2MTZlNzk2ZDZmNzI2NTJlMjAyMDIwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjgyNC04MjgKICAgIC8vIHJldHVybiBFYXJuaW5nc0Rpc3RyaWJ1dGlvbkFuZE1lc3NhZ2UoCiAgICAvLyAgICAgZWFybmluZ3NfZGlzdHJpYnV0aW9uPWVhcm5pbmdzX2Rpc3RyaWJ1dGlvbi5jb3B5KCksCiAgICAvLyAgICAgZGVsX21hbmFnZXI9YXJjNC5BZGRyZXNzKHNlbGYuZGVsX21hbmFnZXIpLAogICAgLy8gICAgIG1zZz1tc2cuY29weSgpLAogICAgLy8gKQogICAgY29uY2F0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuZGVsZWdhdG9yX2NvbnRyYWN0LmNvbnRyYWN0LkRlbGVnYXRvckNvbnRyYWN0LmNvbnRyYWN0X2V4cGlyZWQoKSAtPiBieXRlczoKY29udHJhY3RfZXhwaXJlZDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTgwLTk4MwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBjb250cmFjdF9leHBpcmVkKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyApIC0+IEVhcm5pbmdzRGlzdHJpYnV0aW9uQW5kTWVzc2FnZToKICAgIHByb3RvIDAgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo5OTkKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IEdsb2JhbC5jcmVhdG9yX2FkZHJlc3MsIEVSUk9SX0NBTExFRF9CWV9OT1RfQ1JFQVRPUgogICAgdHhuIFNlbmRlcgogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSBzbWFydCBjb250cmFjdCBjcmVhdG9yLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDAwCiAgICAvLyBhc3NlcnQgc2VsZi5zdGF0ZSA9PSBCeXRlcyhTVEFURV9MSVZFKSwgRVJST1JfTk9UX1NUQVRFX0xJVkUKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0ZSBleGlzdHMKICAgIGJ5dGVjIDYgLy8gMHgwNQogICAgPT0KICAgIGFzc2VydCAvLyBDYW5ub3QgYmUgY2FsbGVkIGZyb20gb3RoZXIgc3RhdGUgdGhhbiBMSVZFLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDAyCiAgICAvLyBhc3NlcnQgc2VsZi5yb3VuZF9lbmQgPD0gR2xvYmFsLnJvdW5kLCBFUlJPUl9OT1RfWUVUX0VYUElSRUQKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18zIC8vICJyb3VuZF9lbmQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfZW5kIGV4aXN0cwogICAgZ2xvYmFsIFJvdW5kCiAgICA8PQogICAgYXNzZXJ0IC8vIENhbm5vdCBiZSBjYWxsZWQgd2hlbiB0aGUgY29udHJhY3QgaGFzIG5vdCB5ZXQgZXhwaXJlZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTAwNC0xMDA1CiAgICAvLyAjIENsYWltIGVhcm5pbmdzIHVwIHRvIHRoaXMgcm91bmQKICAgIC8vIGVhcm5pbmdzX2Rpc3RyaWJ1dGlvbiA9IHNlbGYuY29udHJhY3RfY2xhaW0oKQogICAgY2FsbHN1YiBjb250cmFjdF9jbGFpbQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDA2LTEwMDcKICAgIC8vICMgQ2hhbmdlIHN0YXRlIHRvIEVOREVEX0VYUElSRUQKICAgIC8vIHNlbGYuc3RhdGUgPSBCeXRlcyhTVEFURV9FTkRFRF9FWFBJUkVEKQogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBwdXNoYnl0ZXMgMHgxNAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTAwOC0xMDA5CiAgICAvLyAjIE1hcmsgZW5kIG9mIGNvbnRyYWN0CiAgICAvLyBzZWxmLnJvdW5kX2VuZGVkID0gR2xvYmFsLnJvdW5kCiAgICBieXRlYyA4IC8vICJyb3VuZF9lbmRlZCIKICAgIGdsb2JhbCBSb3VuZAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTAxNAogICAgLy8gZGVsX21hbmFnZXI9YXJjNC5BZGRyZXNzKHNlbGYuZGVsX21hbmFnZXIpLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gImRlbF9tYW5hZ2VyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbF9tYW5hZ2VyIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDEyLTEwMTYKICAgIC8vIHJldHVybiBFYXJuaW5nc0Rpc3RyaWJ1dGlvbkFuZE1lc3NhZ2UoCiAgICAvLyAgICAgZWFybmluZ3NfZGlzdHJpYnV0aW9uPWVhcm5pbmdzX2Rpc3RyaWJ1dGlvbi5jb3B5KCksCiAgICAvLyAgICAgZGVsX21hbmFnZXI9YXJjNC5BZGRyZXNzKHNlbGYuZGVsX21hbmFnZXIpLAogICAgLy8gICAgIG1zZz1tc2cuY29weSgpLAogICAgLy8gKQogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwMTEKICAgIC8vIG1zZyA9IE5vdGlmaWNhdGlvbk1lc3NhZ2UuZnJvbV9ieXRlcyhNU0dfQ09SRV9DT05UUkFDVF9FWFBJUkVEKQogICAgcHVzaGJ5dGVzIDB4NGQ2NTczNzM2MTY3NjUyMDY2NzI2ZjZkMjA1NjYxNmM2MTcyM2EyMDU5NmY3NTcyMjA2MzZmNmU3NDcyNjE2Mzc0MjA3NDZmMjA3Mzc0NjE2YjY1MjA3NzY5NzQ2ODIwNjEyMDZlNmY2NDY1MjA3Mjc1NmU2ZTY1NzIyMDY4NjE3MzIwNjU2ZTY0NjU2NDJlMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTAxMi0xMDE2CiAgICAvLyByZXR1cm4gRWFybmluZ3NEaXN0cmlidXRpb25BbmRNZXNzYWdlKAogICAgLy8gICAgIGVhcm5pbmdzX2Rpc3RyaWJ1dGlvbj1lYXJuaW5nc19kaXN0cmlidXRpb24uY29weSgpLAogICAgLy8gICAgIGRlbF9tYW5hZ2VyPWFyYzQuQWRkcmVzcyhzZWxmLmRlbF9tYW5hZ2VyKSwKICAgIC8vICAgICBtc2c9bXNnLmNvcHkoKSwKICAgIC8vICkKICAgIGNvbmNhdAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmRlbGVnYXRvcl9jb250cmFjdC5jb250cmFjdC5EZWxlZ2F0b3JDb250cmFjdC5jb250cmFjdF93aXRoZHJhdyhkZWxfbWFuYWdlcjogYnl0ZXMpIC0+IGJ5dGVzOgpjb250cmFjdF93aXRoZHJhdzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTAxOC0xMDIyCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGNvbnRyYWN0X3dpdGhkcmF3KAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZGVsX21hbmFnZXI6IGFyYzQuQWRkcmVzcywKICAgIC8vICkgLT4gRWFybmluZ3NEaXN0cmlidXRpb246CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTA0MAogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgRVJST1JfQ0FMTEVEX0JZX05PVF9DUkVBVE9SCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHNtYXJ0IGNvbnRyYWN0IGNyZWF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwNDEKICAgIC8vIGFzc2VydCBzZWxmLnN0YXRlID09IEJ5dGVzKFNUQVRFX0xJVkUpLCBFUlJPUl9OT1RfU1RBVEVfTElWRQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gInN0YXRlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXRlIGV4aXN0cwogICAgYnl0ZWMgNiAvLyAweDA1CiAgICA9PQogICAgYXNzZXJ0IC8vIENhbm5vdCBiZSBjYWxsZWQgZnJvbSBvdGhlciBzdGF0ZSB0aGFuIExJVkUuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwNDMKICAgIC8vIGFzc2VydCBkZWxfbWFuYWdlciA9PSBzZWxmLmRlbF9tYW5hZ2VyLCBFUlJPUl9OT1RfTUFOQUdFUgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gImRlbF9tYW5hZ2VyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbF9tYW5hZ2VyIGV4aXN0cwogICAgZnJhbWVfZGlnIC0xCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGFwcHJvdmVkIGJ5IGRlbGVnYXRvciBtYW5hZ2VyLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDQ1CiAgICAvLyBhc3NlcnQgc2VsZi5yb3VuZF9lbmQgPiBHbG9iYWwucm91bmQsIEVSUk9SX0FMUkVBRFlfRVhQSVJFRAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzMgLy8gInJvdW5kX2VuZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5yb3VuZF9lbmQgZXhpc3RzCiAgICBnbG9iYWwgUm91bmQKICAgID4KICAgIGFzc2VydCAvLyBDYW5ub3QgYmUgY2FsbGVkIHdoZW4gdGhlIGNvbnRyYWN0IGhhcyBhbHJlYWR5IGV4cGlyZWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwNDctMTA0OAogICAgLy8gIyBDbGFpbSBlYXJuaW5ncyB1cCB0byB0aGlzIHJvdW5kCiAgICAvLyBlYXJuaW5nc19kaXN0cmlidXRpb24gPSBzZWxmLmNvbnRyYWN0X2NsYWltKCkKICAgIGNhbGxzdWIgY29udHJhY3RfY2xhaW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTA0OS0xMDUwCiAgICAvLyAjIENoYW5nZSBzdGF0ZSB0byBFTkRFRF9XSVRIRFJFVwogICAgLy8gc2VsZi5zdGF0ZSA9IEJ5dGVzKFNUQVRFX0VOREVEX1dJVEhEUkVXKQogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBwdXNoYnl0ZXMgMHgxMwogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTA1MS0xMDUyCiAgICAvLyAjIE1hcmsgZW5kIG9mIGNvbnRyYWN0CiAgICAvLyBzZWxmLnJvdW5kX2VuZGVkID0gR2xvYmFsLnJvdW5kCiAgICBieXRlYyA4IC8vICJyb3VuZF9lbmRlZCIKICAgIGdsb2JhbCBSb3VuZAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTA1NAogICAgLy8gcmV0dXJuIGVhcm5pbmdzX2Rpc3RyaWJ1dGlvbi5jb3B5KCkKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5kZWxlZ2F0b3JfY29udHJhY3QuY29udHJhY3QuRGVsZWdhdG9yQ29udHJhY3QuY29udHJhY3RfZGVsZXRlKGRlbF9tYW5hZ2VyOiBieXRlcykgLT4gYnl0ZXM6CmNvbnRyYWN0X2RlbGV0ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTA1Ni0xMDYwCiAgICAvLyBAYXJjNC5hYmltZXRob2QoYWxsb3dfYWN0aW9ucz1bIkRlbGV0ZUFwcGxpY2F0aW9uIl0pCiAgICAvLyBkZWYgY29udHJhY3RfZGVsZXRlKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZGVsX21hbmFnZXI6IGFyYzQuQWRkcmVzcywKICAgIC8vICkgLT4gQ29udHJhY3REZWxldGVSZXR1cm46CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTA4MAogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgRVJST1JfQ0FMTEVEX0JZX05PVF9DUkVBVE9SCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHNtYXJ0IGNvbnRyYWN0IGNyZWF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwODEKICAgIC8vIGFzc2VydCAoc2VsZi5zdGF0ZSAmIEJ5dGVzKFNUQVRFX0VOREVEX01BU0spKSA9PSBCeXRlcyhTVEFURV9FTkRFRF9NQVNLKSwgRVJST1JfTk9UX0VOREVEX1NUQVRFCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdGUgZXhpc3RzCiAgICBieXRlYyAyMSAvLyAweDEwCiAgICBiJgogICAgYnl0ZWMgMjEgLy8gMHgxMAogICAgPT0KICAgIGFzc2VydCAvLyBDYW5ub3QgYmUgY2FsbGVkIGZyb20gb3RoZXIgc3RhdGUgdGhhbiBFTkRFRF94eXouCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwODMKICAgIC8vIGFzc2VydCBkZWxfbWFuYWdlciA9PSBzZWxmLmRlbF9tYW5hZ2VyLCBFUlJPUl9OT1RfTUFOQUdFUgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gImRlbF9tYW5hZ2VyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbF9tYW5hZ2VyIGV4aXN0cwogICAgZnJhbWVfZGlnIC0xCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGFwcHJvdmVkIGJ5IGRlbGVnYXRvciBtYW5hZ2VyLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDg1CiAgICAvLyBhc3NldF9pZCA9IHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsLnZhbHVlLmZlZV9hc3NldF9pZC5uYXRpdmUKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJHIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbCBleGlzdHMKICAgIGV4dHJhY3QgMjQgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDg2CiAgICAvLyBpZiBhc3NldF9pZCA9PSBVSW50NjQoQUxHT19BU0FfSUQpOgogICAgYm56IGNvbnRyYWN0X2RlbGV0ZV9lbHNlX2JvZHlAMwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDg3CiAgICAvLyBiYWwgPSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLmJhbGFuY2UgLSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RCYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgLQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwODktMTA5MgogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXNlbGYuZGVsX21hbmFnZXIsCiAgICAvLyAgICAgYW1vdW50PWJhbCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTA5MAogICAgLy8gcmVjZWl2ZXI9c2VsZi5kZWxfbWFuYWdlciwKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJkZWxfbWFuYWdlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxfbWFuYWdlciBleGlzdHMKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwODkKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIGludGNfMSAvLyBwYXkKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDg5LTEwOTIKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1zZWxmLmRlbF9tYW5hZ2VyLAogICAgLy8gICAgIGFtb3VudD1iYWwsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgYiBjb250cmFjdF9kZWxldGVfYWZ0ZXJfaWZfZWxzZUA1Cgpjb250cmFjdF9kZWxldGVfZWxzZV9ib2R5QDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwOTUKICAgIC8vIGJhbCA9IGFzc2V0LmJhbGFuY2UoR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcykKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBmcmFtZV9kaWcgMAogICAgZHVwCiAgICBjb3ZlciAyCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIHN3YXAKICAgIGR1cAogICAgY292ZXIgMgogICAgY292ZXIgMwogICAgYXNzZXJ0IC8vIGFjY291bnQgb3B0ZWQgaW50byBhc3NldAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDk3LTExMDIKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIC8vICAgICB4ZmVyX2Fzc2V0PWFzc2V0LAogICAgLy8gICAgIGFzc2V0X3JlY2VpdmVyPXNlbGYuZGVsX21hbmFnZXIsCiAgICAvLyAgICAgYXNzZXRfYW1vdW50PWJhbCwKICAgIC8vICAgICBhc3NldF9jbG9zZV90bz1zZWxmLmRlbF9tYW5hZ2VyLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDk5CiAgICAvLyBhc3NldF9yZWNlaXZlcj1zZWxmLmRlbF9tYW5hZ2VyLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gImRlbF9tYW5hZ2VyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbF9tYW5hZ2VyIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTAxCiAgICAvLyBhc3NldF9jbG9zZV90bz1zZWxmLmRlbF9tYW5hZ2VyLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gImRlbF9tYW5hZ2VyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbF9tYW5hZ2VyIGV4aXN0cwogICAgaXR4bl9maWVsZCBBc3NldENsb3NlVG8KICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTA5NwogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgaW50Y18yIC8vIGF4ZmVyCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTA5Ny0xMTAyCiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgeGZlcl9hc3NldD1hc3NldCwKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj1zZWxmLmRlbF9tYW5hZ2VyLAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD1iYWwsCiAgICAvLyAgICAgYXNzZXRfY2xvc2VfdG89c2VsZi5kZWxfbWFuYWdlciwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0Cgpjb250cmFjdF9kZWxldGVfYWZ0ZXJfaWZfZWxzZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTA0LTExMDkKICAgIC8vICMgQ2xvc2Ugb3V0IHRoZSBhY2NvdW50IHRvIGRlbGVnYXRvciBtYW5hZ2VyCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgcmVjZWl2ZXI9c2VsZi5kZWxfbWFuYWdlciwKICAgIC8vICAgICBhbW91bnQ9MCwKICAgIC8vICAgICBjbG9zZV9yZW1haW5kZXJfdG89c2VsZi5kZWxfbWFuYWdlciwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTEwNgogICAgLy8gcmVjZWl2ZXI9c2VsZi5kZWxfbWFuYWdlciwKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJkZWxfbWFuYWdlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxfbWFuYWdlciBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTEwOAogICAgLy8gY2xvc2VfcmVtYWluZGVyX3RvPXNlbGYuZGVsX21hbmFnZXIsCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAiZGVsX21hbmFnZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsX21hbmFnZXIgZXhpc3RzCiAgICBpdHhuX2ZpZWxkIENsb3NlUmVtYWluZGVyVG8KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTEwNwogICAgLy8gYW1vdW50PTAsCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTEwNC0xMTA1CiAgICAvLyAjIENsb3NlIG91dCB0aGUgYWNjb3VudCB0byBkZWxlZ2F0b3IgbWFuYWdlcgogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50Y18xIC8vIHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjExMDQtMTEwOQogICAgLy8gIyBDbG9zZSBvdXQgdGhlIGFjY291bnQgdG8gZGVsZWdhdG9yIG1hbmFnZXIKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1zZWxmLmRlbF9tYW5hZ2VyLAogICAgLy8gICAgIGFtb3VudD0wLAogICAgLy8gICAgIGNsb3NlX3JlbWFpbmRlcl90bz1zZWxmLmRlbF9tYW5hZ2VyLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTExMgogICAgLy8gcmVtYWluaW5nX2JhbGFuY2U9YXJjNC5VSW50NjQoYmFsKSwKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTExMwogICAgLy8gYXNzZXRfaWQ9YXJjNC5VSW50NjQoYXNzZXRfaWQpLAogICAgZnJhbWVfZGlnIDAKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTExMS0xMTE0CiAgICAvLyByZXR1cm4gQ29udHJhY3REZWxldGVSZXR1cm4oCiAgICAvLyAgICAgcmVtYWluaW5nX2JhbGFuY2U9YXJjNC5VSW50NjQoYmFsKSwKICAgIC8vICAgICBhc3NldF9pZD1hcmM0LlVJbnQ2NChhc3NldF9pZCksCiAgICAvLyApCiAgICBjb25jYXQKICAgIHN3YXAKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5kZWxlZ2F0b3JfY29udHJhY3QuY29udHJhY3QuRGVsZWdhdG9yQ29udHJhY3QuY29udHJhY3RfcmVwb3J0X2V4cGlyeV9zb29uKGJlZm9yZV9leHBpcnk6IHVpbnQ2NCwgcmVwb3J0X3BlcmlvZDogdWludDY0KSAtPiBieXRlczoKY29udHJhY3RfcmVwb3J0X2V4cGlyeV9zb29uOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTE2LTExMjEKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgY29udHJhY3RfcmVwb3J0X2V4cGlyeV9zb29uKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgYmVmb3JlX2V4cGlyeTogVUludDY0LAogICAgLy8gICAgIHJlcG9ydF9wZXJpb2Q6IFVJbnQ2NCwKICAgIC8vICkgLT4gTWVzc2FnZToKICAgIHByb3RvIDIgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTQyCiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCBFUlJPUl9DQUxMRURfQllfTk9UX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTE0MwogICAgLy8gYXNzZXJ0IHNlbGYuc3RhdGUgPT0gQnl0ZXMoU1RBVEVfTElWRSksIEVSUk9SX05PVF9TVEFURV9MSVZFCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdGUgZXhpc3RzCiAgICBieXRlYyA2IC8vIDB4MDUKICAgID09CiAgICBhc3NlcnQgLy8gQ2Fubm90IGJlIGNhbGxlZCBmcm9tIG90aGVyIHN0YXRlIHRoYW4gTElWRS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTE0NQogICAgLy8gYXNzZXJ0IEdsb2JhbC5yb3VuZCArIGJlZm9yZV9leHBpcnkgPj0gc2VsZi5yb3VuZF9lbmQsIEVSUk9SX1RPT19TT09OX1RPX1JFUE9SVF9FWFBJUllfU09PTgogICAgZ2xvYmFsIFJvdW5kCiAgICBmcmFtZV9kaWcgLTIKICAgICsKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18zIC8vICJyb3VuZF9lbmQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfZW5kIGV4aXN0cwogICAgPj0KICAgIGFzc2VydCAvLyBJdCBpcyB0b28gc29vbiB0byByZXBvcnQgdGhlIGNvbnRyYWN0IGlzIGFib3V0IHRvIGV4cGlyZS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTE0NgogICAgLy8gYXNzZXJ0IHNlbGYucm91bmRfZW5kID4gR2xvYmFsLnJvdW5kLCBFUlJPUl9BTFJFQURZX0VYUElSRUQKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18zIC8vICJyb3VuZF9lbmQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfZW5kIGV4aXN0cwogICAgZ2xvYmFsIFJvdW5kCiAgICA+CiAgICBhc3NlcnQgLy8gQ2Fubm90IGJlIGNhbGxlZCB3aGVuIHRoZSBjb250cmFjdCBoYXMgYWxyZWFkeSBleHBpcmVkLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTQ4CiAgICAvLyBhc3NlcnQgR2xvYmFsLnJvdW5kID49IHNlbGYucm91bmRfZXhwaXJ5X3Nvb25fbGFzdCArIHJlcG9ydF9wZXJpb2QsIEVSUk9SX1RPT19TT09OX1RPX1JFUE9SVF9FWFBJUllfU09PTl9BR0FJTgogICAgZ2xvYmFsIFJvdW5kCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMjAgLy8gInJvdW5kX2V4cGlyeV9zb29uX2xhc3QiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfZXhwaXJ5X3Nvb25fbGFzdCBleGlzdHMKICAgIGZyYW1lX2RpZyAtMQogICAgKwogICAgPj0KICAgIGFzc2VydCAvLyBJdCBpcyB0b28gc29vbiB0byByZXBvcnQgYWdhaW4gdGhhdCB0aGUgY29udHJhY3QgaXMgYWJvdXQgdG8gZXhwaXJlLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTQ5CiAgICAvLyBzZWxmLnJvdW5kX2V4cGlyeV9zb29uX2xhc3QgPSBHbG9iYWwucm91bmQKICAgIGJ5dGVjIDIwIC8vICJyb3VuZF9leHBpcnlfc29vbl9sYXN0IgogICAgZ2xvYmFsIFJvdW5kCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTUzCiAgICAvLyBkZWxfbWFuYWdlcj1hcmM0LkFkZHJlc3Moc2VsZi5kZWxfbWFuYWdlciksCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAiZGVsX21hbmFnZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsX21hbmFnZXIgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjExNTEKICAgIC8vIG1zZyA9IE5vdGlmaWNhdGlvbk1lc3NhZ2UuZnJvbV9ieXRlcyhNU0dfQ09SRV9XSUxMX0VYUElSRSkKICAgIHB1c2hieXRlcyAweDRkNjU3MzczNjE2NzY1MjA2NjcyNmY2ZDIwNTY2MTZjNjE3MjNhMjA1OTZmNzU3MjIwNjM2ZjZlNzQ3MjYxNjM3NDIwNzQ2ZjIwNzM3NDYxNmI2NTIwNzc2OTc0NjgyMDYxMjA2ZTZmNjQ2NTIwNzI3NTZlNmU2NTcyMjA2OTczMjA2NTc4NzA2OTcyNjk2ZTY3MmUyMDQzNmY2ZTczNjk2NDY1NzIyMDY1Nzg3NDY1NmU2NDY5NmU2NzIwNjk3NDIxMjAyMDIwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjExNTItMTE1NQogICAgLy8gcmV0dXJuIE1lc3NhZ2UoCiAgICAvLyAgICAgZGVsX21hbmFnZXI9YXJjNC5BZGRyZXNzKHNlbGYuZGVsX21hbmFnZXIpLAogICAgLy8gICAgIG1zZz1tc2cuY29weSgpLAogICAgLy8gKQogICAgY29uY2F0CiAgICByZXRzdWIK",
        "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCgpzbWFydF9jb250cmFjdHMuZGVsZWdhdG9yX2NvbnRyYWN0LmNvbnRyYWN0LkRlbGVnYXRvckNvbnRyYWN0LmNsZWFyX3N0YXRlX3Byb2dyYW06CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg=="
    },
    "state": {
        "global": {
            "num_byte_slices": 9,
            "num_uints": 12
        },
        "local": {
            "num_byte_slices": 0,
            "num_uints": 0
        }
    },
    "schema": {
        "global": {
            "declared": {
                "cnt_breach_del": {
                    "type": "uint64",
                    "key": "cnt_breach_del"
                },
                "del_beneficiary": {
                    "type": "bytes",
                    "key": "del_beneficiary"
                },
                "del_manager": {
                    "type": "bytes",
                    "key": "del_manager"
                },
                "delegation_terms_balance": {
                    "type": "bytes",
                    "key": "B",
                    "descr": "Balance related delegation terms."
                },
                "delegation_terms_general": {
                    "type": "bytes",
                    "key": "G",
                    "descr": "General delegation terms."
                },
                "fee_operational": {
                    "type": "uint64",
                    "key": "fee_operational"
                },
                "fee_operational_partner": {
                    "type": "uint64",
                    "key": "fee_operational_partner"
                },
                "noticeboard_app_id": {
                    "type": "uint64",
                    "key": "noticeboard_app_id"
                },
                "round_breach_last": {
                    "type": "uint64",
                    "key": "round_breach_last"
                },
                "round_claim_last": {
                    "type": "uint64",
                    "key": "round_claim_last"
                },
                "round_end": {
                    "type": "uint64",
                    "key": "round_end"
                },
                "round_ended": {
                    "type": "uint64",
                    "key": "round_ended"
                },
                "round_expiry_soon_last": {
                    "type": "uint64",
                    "key": "round_expiry_soon_last"
                },
                "round_start": {
                    "type": "uint64",
                    "key": "round_start"
                },
                "sel_key": {
                    "type": "bytes",
                    "key": "sel_key"
                },
                "state": {
                    "type": "bytes",
                    "key": "state"
                },
                "state_proof_key": {
                    "type": "bytes",
                    "key": "state_proof_key"
                },
                "tc_sha256": {
                    "type": "bytes",
                    "key": "tc_sha256"
                },
                "validator_ad_app_id": {
                    "type": "uint64",
                    "key": "validator_ad_app_id"
                },
                "vote_key": {
                    "type": "bytes",
                    "key": "vote_key"
                },
                "vote_key_dilution": {
                    "type": "uint64",
                    "key": "vote_key_dilution"
                }
            },
            "reserved": {}
        },
        "local": {
            "declared": {},
            "reserved": {}
        }
    },
    "contract": {
        "name": "DelegatorContract",
        "methods": [
            {
                "name": "contract_create",
                "args": [
                    {
                        "type": "address",
                        "name": "del_manager",
                        "desc": "Manager address for the delegation contract."
                    },
                    {
                        "type": "address",
                        "name": "del_beneficiary",
                        "desc": "Beneficiary address for the delegation contract."
                    },
                    {
                        "type": "uint64",
                        "name": "noticeboard_app_id",
                        "desc": "App ID of the Noticeboard smart contract to which to tie this contract."
                    }
                ],
                "returns": {
                    "type": "uint64",
                    "desc": "App ID of the created delegation contract application."
                },
                "desc": "Creates a new DelegatorContract.\nDefines delegator contract manager and beneficiary accounts. Defines Noticeboard and ValidatorAd app ID to which this contract belongs to."
            },
            {
                "name": "contract_setup",
                "args": [
                    {
                        "type": "byte[32]",
                        "name": "tc_sha256",
                        "desc": "Hash (i.e. SHA 256) of the Terms and Conditions defining the delegation contract concluded between the delegator and validator."
                    },
                    {
                        "type": "(uint64,uint64,uint64,uint64,address,uint64,uint64,uint64,uint64)",
                        "name": "delegation_terms_general",
                        "desc": "General delegation contract terms."
                    },
                    {
                        "type": "(uint64,uint64,uint64,(uint64,uint64)[2])",
                        "name": "delegation_terms_balance",
                        "desc": "Balance delegation contract terms."
                    },
                    {
                        "type": "uint64",
                        "name": "rounds_duration",
                        "desc": "Contract duration in number of rounds."
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Sets the general and balance delegation contract terms.\nDefines contract start and end rounds. Opts in the payment asset if it is not ALGO."
            },
            {
                "name": "contract_pay",
                "args": [
                    {
                        "type": "txn",
                        "name": "txn",
                        "desc": "Transaction for the payment of the setup and operational fees."
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Pays the validator setup and operational fee."
            },
            {
                "name": "keys_confirm",
                "args": [
                    {
                        "type": "address",
                        "name": "del_manager",
                        "desc": "Purported delegator manager account."
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Delegator manager confirms that the delegator beneficiary has confirmed the submitted keys.."
            },
            {
                "name": "keys_not_confirmed",
                "args": [],
                "returns": {
                    "type": "(address,byte[100])",
                    "desc": "Address of delegator manager."
                },
                "desc": "Reports that keys have not been confirmed in time."
            },
            {
                "name": "keys_not_submitted",
                "args": [],
                "returns": {
                    "type": "(address,byte[100])",
                    "desc": "Address of delegator manager."
                },
                "desc": "Reports that keys have not been submitted in time."
            },
            {
                "name": "keys_submit",
                "args": [
                    {
                        "type": "(uint64,uint64,uint64,byte[32],byte[32],byte[64],address)",
                        "name": "key_reg_txn_info",
                        "desc": "Information about the generated participation keys."
                    }
                ],
                "returns": {
                    "type": "((uint64,uint64,uint64),address,byte[100])",
                    "desc": "Amount of earnings of the validator which equal the setup fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted."
                },
                "desc": "ValidatorAd submits the keys generated for the delegator beneficiary according to the contract terms."
            },
            {
                "name": "breach_limits",
                "args": [],
                "returns": {
                    "type": "(bool,(uint64,uint64,uint64),address,byte[100])",
                    "desc": "Boolean denoting if maximum number of breaches has already been reached (True) or not (False)."
                },
                "desc": "Reports that a limit breach event occurred."
            },
            {
                "name": "breach_pay",
                "args": [],
                "returns": {
                    "type": "(address,byte[100])",
                    "desc": "Address of delegator manager."
                },
                "desc": "Reports that a payment for the fee cannot be made from DelegatorContract.\nThis can happen if the DelegatorContract payment asset has been frozen or clawed back by the asset manager."
            },
            {
                "name": "breach_suspended",
                "args": [],
                "returns": {
                    "type": "((uint64,uint64,uint64),address,byte[100])",
                    "desc": "Amount of earnings of the validator which equal any unclaimed operational fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted."
                },
                "desc": "Reports that the delegator beneficiary was suspended by consensus."
            },
            {
                "name": "contract_claim",
                "args": [],
                "returns": {
                    "type": "(uint64,uint64,uint64)",
                    "desc": "Amount of earnings of the validator which equal any unclaimed operational fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted."
                },
                "desc": "Claims operational fee of validator up to this round.\nCommission from the fee gets claimed by the noticeboard. Partner convenience fee gets claimed by the partner."
            },
            {
                "name": "contract_expired",
                "args": [],
                "returns": {
                    "type": "((uint64,uint64,uint64),address,byte[100])",
                    "desc": "Amount of earnings of the validator which equal any unclaimed operational fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted."
                },
                "desc": "Reports that a contract has expired."
            },
            {
                "name": "contract_withdraw",
                "args": [
                    {
                        "type": "address",
                        "name": "del_manager",
                        "desc": "Manager address for the delegation contract."
                    }
                ],
                "returns": {
                    "type": "(uint64,uint64,uint64)",
                    "desc": "Amount of earnings of the validator which equal any unclaimed operational fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted."
                },
                "desc": "Delegator gracefully withdraws from the contract prematurely.\nThe delegator beneficiary should issue a key deregistration transaction 320 round before this call."
            },
            {
                "name": "contract_delete",
                "args": [
                    {
                        "type": "address",
                        "name": "del_manager",
                        "desc": "Manager address for the delegation contract."
                    }
                ],
                "returns": {
                    "type": "(uint64,uint64)",
                    "desc": "Balance of the fee asset that remained in the contract."
                },
                "desc": "Delegator deletes an ended contract and withdraws any remaining balance.\nThere can be non-zero balance to withdraw if someone sent the contract some balance, or if it was not possible to claim the fee by validator and/or noticeboard if they had the asset frozen."
            },
            {
                "name": "contract_report_expiry_soon",
                "args": [
                    {
                        "type": "uint64",
                        "name": "before_expiry",
                        "desc": "How many rounds before contract end can the report be made."
                    },
                    {
                        "type": "uint64",
                        "name": "report_period",
                        "desc": "How frequently can the report be made."
                    }
                ],
                "returns": {
                    "type": "(address,byte[100])",
                    "desc": "Address of delegator manager."
                },
                "desc": "Reports that the contract will expire soon.\nNotification message can be triggered only a pre-defined time in advance and with limited frequency to prevent spamming."
            }
        ],
        "networks": {},
        "desc": "\n    Contract between a delegator manager and a validator (a.k.a. node runner), for the latter to participate in\n    consensus on the behalf of the delegator beneficiary for specific amount of time and for a specific fee.\n    The contract terms and conditions are defined in this contract.\n    The contract also acts as an escrow account for the delegator's payment to the validator for the service.\n\n    Global state\n    ------------\n    noticeboard_app_id : UInt64\n        App ID of noticeboard platform to which this contract belongs to.\n    validator_ad_app_id : UInt64\n        App ID of validator ad to which this contract belongs to.\n\n\n    delegation_terms_general : DelegationTermsGeneral\n        General delegation terms agreed by delegator and validator to govern this contract.\n    fee_operational : UInt64\n        Calculated operational fee based on the agreed contract terms.\n    fee_operational_partner : UInt64\n        Calculated operational fee charged for convenience by the partner.\n    delegation_terms_balance : DelegationTermsBalance\n        Requirements for delegator beneficiary balance agreed by delegator and validator to govern this contract.\n\n    del_manager : Account\n        Delegator manager account.\n    del_beneficiary : UInt64\n        Delegator beneficiary account.\n\n    round_start : UInt64\n        Agreed start round of the contract, i.e. time of its creation.\n    round_end : UInt64\n        Agreed end round of the contract.\n    round_ended : UInt64\n        Actual round at which the contract ended.\n        Can be smaller than round_end in case of early contract end.\n\n    vote_key_dilution : UInt64\n        Vote key dilution parameter of the agreed participation key.\n    vote_pk = VotePk\n        Vote public key of the agreed participation key.\n    selection_pk : SelPk\n        Selection public key of the agreed participation key.\n    state_proof_pk = StateProofPk\n        State proof public key of the agreed participation key.\n\n    state : Bytes\n        State of the contract. Can be one of the following:\n            CREATED - contract has been created.\n            LIVE - contract is live.\n            READY - waiting for keys submission.\n            SET - contract terms have been set.\n            SUBMITTED - waiting for keys confirmation.\n            ENDED_NOT_SUBMITTED - keys have not been submitted in time.\n            ENDED_NOT_CONFIRMED - keys have not been confirmed in time.\n            ENDED_LIMITS - maximum number of limit breach events has been reached.\n            ENDED_WITHDREW - delegator withdrew from the contract prematurely.\n            ENDED_EXPIRED - contract has expired.\n            ENDED_SUSPENDED - delegator has been suspended by consensus.\n            ENDED_CANNOT_PAY - delegator cannot pay the validator (as funds could have been frozen and/or clawed back).\n\n    tc_sha256 : Sha256\n        Hash (i.e. SHA 256) of the Terms and Conditions defining the delegation contract concluded between the delegator\n        and validator.\n\n    cnt_breach_del : UInt64\n        Counter of limit breach events.\n    round_breach_last : UInt64\n        Number of round of last limit breach event.\n\n    round_claim_last : UInt64\n        Number of the round the operational fee was last claimed.\n\n    round_expiry_soon_last : UInt64\n        Number of the round it was last reported that the contract will expire soon.\n\n    Methods\n    -------\n    contract_create(\n        del_manager: arc4.Address,\n        del_beneficiary: arc4.Address,\n        noticeboard_app_id: UInt64,\n    ) -> Application:\n        Creates a new delegator contract and returns its app ID.\n\n    contract_setup(\n        delegation_terms_general: DelegationTermsGeneral,\n        delegation_terms_balance: DelegationTermsBalance,\n        rounds_duration: UInt64,\n    ) -> None:\n        Sets the delegation contract terms.\n\n    contract_pay(\n        txn: gtxn.Transaction,\n    ) -> None:\n        Pays the validator setup and operational fee.\n\n    keys_confirm(\n        del_manager: arc4.Address,\n    ) -> None:\n        Delegator confirms the participation keys.\n\n    keys_not_confirmed() -> Message:\n        Reports that keys have not been confirmed in time.\n\n    keys_not_submitted() -> Message:\n        Reports that keys have not been submitted in time.\n\n    keys_submit(\n        key_reg_txn_info : KeyRegTxnInfo,\n    ) -> EarningsDistributionAndMessage:\n        ValidatorAd submits the keys generated for the delegator beneficiary according to the contract terms.\n\n    breach_limits(\n    ) -> BreachLimitsReturn:\n        Reports that a limit breach event occurred.\n\n    breach_pay(\n    ) -> Message:\n        Reports that a payment for the fee cannot be made from DelegatorContract (due to freeze or claw back).\n\n    breach_suspended(\n    ) -> EarningsDistributionAndMessage:\n        Reports that the delegator beneficiary was suspended by consensus.\n\n    contract_claim(\n    ) -> EarningsDistribution:\n        Claims and distributes the operational fee of validator up to this round to the validator and noticeboard,\n        as well as to the partner.\n\n    contract_expired(\n    ) -> EarningsDistributionAndMessage:\n        Reports that a contract has expired.\n\n    contract_withdraw(\n        del_manager: arc4.Address,\n    ) -> EarningsDistribution:\n        Delegator gracefully withdraws from the contract prematurely.\n\n    contract_delete(\n        del_manager: arc4.Address,\n        updating : arc4.Bool,\n    ) -> ContractDeleteReturn:\n        Delegator deletes an ended contract and withdraws any remaining balance.\n\n    contract_report_expiry_soon(\n        before_expiry: UInt64,\n        report_period: UInt64,\n    ) -> Message:\n        Reports that the contract will expire soon.\n\n    Private methods\n    ---------------\n    _distribute_earnings(\n        amount: UInt64,\n        amount_partner: UInt64,\n    ) -> EarningsDistribution:\n        Internal method for distributing the earnings between the validator ad and the noticeboard platform,\n        as well as for distributing the earnings of the partner.\n\n    _is_eligible(\n    ) -> arc4.Bool:\n        Check if del_beneficiary meets the agreed balance limits or not\n\n    _try_return_fee(\n        fee_asset: Asset,\n        amt_return: UInt64,\n    ) -> None:\n        Tries to return the input fee amount of given asset to del_manager.\n        The fee cannot be returned if the del_manager is closed out or frozen for the given asset.\n\n    "
    },
    "bare_call_config": {}
}"""
APP_SPEC = algokit_utils.ApplicationSpecification.from_json(_APP_SPEC_JSON)
_TReturn = typing.TypeVar("_TReturn")


class _ArgsBase(ABC, typing.Generic[_TReturn]):
    @staticmethod
    @abstractmethod
    def method() -> str:
        ...


_TArgs = typing.TypeVar("_TArgs", bound=_ArgsBase[typing.Any])


@dataclasses.dataclass(kw_only=True)
class _TArgsHolder(typing.Generic[_TArgs]):
    args: _TArgs


@dataclasses.dataclass(kw_only=True)
class DeployCreate(algokit_utils.DeployCreateCallArgs, _TArgsHolder[_TArgs], typing.Generic[_TArgs]):
    pass


@dataclasses.dataclass(kw_only=True)
class Deploy(algokit_utils.DeployCallArgs, _TArgsHolder[_TArgs], typing.Generic[_TArgs]):
    pass


def _filter_none(value: dict | typing.Any) -> dict | typing.Any:
    if isinstance(value, dict):
        return {k: _filter_none(v) for k, v in value.items() if v is not None}
    return value


def _as_dict(data: typing.Any, *, convert_all: bool = True) -> dict[str, typing.Any]:
    if data is None:
        return {}
    if not dataclasses.is_dataclass(data):
        raise TypeError(f"{data} must be a dataclass")
    if convert_all:
        result = dataclasses.asdict(data) # type: ignore[call-overload]
    else:
        result = {f.name: getattr(data, f.name) for f in dataclasses.fields(data)}
    return _filter_none(result)


def _convert_transaction_parameters(
    transaction_parameters: algokit_utils.TransactionParameters | None,
) -> algokit_utils.TransactionParametersDict:
    return typing.cast(algokit_utils.TransactionParametersDict, _as_dict(transaction_parameters))


def _convert_call_transaction_parameters(
    transaction_parameters: algokit_utils.TransactionParameters | None,
) -> algokit_utils.OnCompleteCallParametersDict:
    return typing.cast(algokit_utils.OnCompleteCallParametersDict, _as_dict(transaction_parameters))


def _convert_create_transaction_parameters(
    transaction_parameters: algokit_utils.TransactionParameters | None,
    on_complete: algokit_utils.OnCompleteActionName,
) -> algokit_utils.CreateCallParametersDict:
    result = typing.cast(algokit_utils.CreateCallParametersDict, _as_dict(transaction_parameters))
    on_complete_enum = on_complete.replace("_", " ").title().replace(" ", "") + "OC"
    result["on_complete"] = getattr(algosdk.transaction.OnComplete, on_complete_enum)
    return result


def _convert_deploy_args(
    deploy_args: algokit_utils.DeployCallArgs | None,
) -> algokit_utils.ABICreateCallArgsDict | None:
    if deploy_args is None:
        return None

    deploy_args_dict = typing.cast(algokit_utils.ABICreateCallArgsDict, _as_dict(deploy_args))
    if isinstance(deploy_args, _TArgsHolder):
        deploy_args_dict["args"] = _as_dict(deploy_args.args)
        deploy_args_dict["method"] = deploy_args.args.method()

    return deploy_args_dict


@dataclasses.dataclass(kw_only=True)
class DelegationTermsGeneral:
    commission: int
    fee_round: int
    fee_setup: int
    fee_asset_id: int
    partner_address: str
    fee_round_partner: int
    fee_setup_partner: int
    rounds_setup: int
    rounds_confirm: int


@dataclasses.dataclass(kw_only=True)
class DelegationTermsBalance:
    stake_max: int
    cnt_breach_del_max: int
    rounds_breach: int
    gating_asa_list: list[tuple[int, int]] | tuple[tuple[int, int], tuple[int, int]]


@dataclasses.dataclass(kw_only=True)
class ContractSetupArgs(_ArgsBase[None]):
    """Sets the general and balance delegation contract terms.
    Defines contract start and end rounds. Opts in the payment asset if it is not ALGO."""

    tc_sha256: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    """Hash (i.e. SHA 256) of the Terms and Conditions defining the delegation contract concluded between the delegator and validator."""
    delegation_terms_general: DelegationTermsGeneral
    """General delegation contract terms."""
    delegation_terms_balance: DelegationTermsBalance
    """Balance delegation contract terms."""
    rounds_duration: int
    """Contract duration in number of rounds."""

    @staticmethod
    def method() -> str:
        return "contract_setup(byte[32],(uint64,uint64,uint64,uint64,address,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,(uint64,uint64)[2]),uint64)void"


@dataclasses.dataclass(kw_only=True)
class ContractPayArgs(_ArgsBase[None]):
    """Pays the validator setup and operational fee."""

    txn: TransactionWithSigner
    """Transaction for the payment of the setup and operational fees."""

    @staticmethod
    def method() -> str:
        return "contract_pay(txn)void"


@dataclasses.dataclass(kw_only=True)
class KeysConfirmArgs(_ArgsBase[None]):
    """Delegator manager confirms that the delegator beneficiary has confirmed the submitted keys.."""

    del_manager: str
    """Purported delegator manager account."""

    @staticmethod
    def method() -> str:
        return "keys_confirm(address)void"


@dataclasses.dataclass(kw_only=True)
class Message:
    del_manager: str
    msg: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]


@dataclasses.dataclass(kw_only=True)
class KeysNotConfirmedArgs(_ArgsBase[Message]):
    """Reports that keys have not been confirmed in time."""

    @staticmethod
    def method() -> str:
        return "keys_not_confirmed()(address,byte[100])"


@dataclasses.dataclass(kw_only=True)
class KeysNotSubmittedArgs(_ArgsBase[Message]):
    """Reports that keys have not been submitted in time."""

    @staticmethod
    def method() -> str:
        return "keys_not_submitted()(address,byte[100])"


@dataclasses.dataclass(kw_only=True)
class KeyRegTxnInfo:
    vote_first: int
    vote_last: int
    vote_key_dilution: int
    vote_pk: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    selection_pk: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    state_proof_pk: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    sender: str


@dataclasses.dataclass(kw_only=True)
class EarningsDistributionAndMessage:
    earnings_distribution: tuple[int, int, int]
    del_manager: str
    msg: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]


@dataclasses.dataclass(kw_only=True)
class KeysSubmitArgs(_ArgsBase[EarningsDistributionAndMessage]):
    """ValidatorAd submits the keys generated for the delegator beneficiary according to the contract terms."""

    key_reg_txn_info: KeyRegTxnInfo
    """Information about the generated participation keys."""

    @staticmethod
    def method() -> str:
        return "keys_submit((uint64,uint64,uint64,byte[32],byte[32],byte[64],address))((uint64,uint64,uint64),address,byte[100])"


@dataclasses.dataclass(kw_only=True)
class BreachLimitsReturn:
    max_breach_reached: bool
    earnings_distribution: tuple[int, int, int]
    del_manager: str
    msg: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]


@dataclasses.dataclass(kw_only=True)
class BreachLimitsArgs(_ArgsBase[BreachLimitsReturn]):
    """Reports that a limit breach event occurred."""

    @staticmethod
    def method() -> str:
        return "breach_limits()(bool,(uint64,uint64,uint64),address,byte[100])"


@dataclasses.dataclass(kw_only=True)
class BreachPayArgs(_ArgsBase[Message]):
    """Reports that a payment for the fee cannot be made from DelegatorContract.
    This can happen if the DelegatorContract payment asset has been frozen or clawed back by the asset manager."""

    @staticmethod
    def method() -> str:
        return "breach_pay()(address,byte[100])"


@dataclasses.dataclass(kw_only=True)
class BreachSuspendedArgs(_ArgsBase[EarningsDistributionAndMessage]):
    """Reports that the delegator beneficiary was suspended by consensus."""

    @staticmethod
    def method() -> str:
        return "breach_suspended()((uint64,uint64,uint64),address,byte[100])"


@dataclasses.dataclass(kw_only=True)
class EarningsDistribution:
    user: int
    platform: int
    asset_id: int


@dataclasses.dataclass(kw_only=True)
class ContractClaimArgs(_ArgsBase[EarningsDistribution]):
    """Claims operational fee of validator up to this round.
    Commission from the fee gets claimed by the noticeboard. Partner convenience fee gets claimed by the partner."""

    @staticmethod
    def method() -> str:
        return "contract_claim()(uint64,uint64,uint64)"


@dataclasses.dataclass(kw_only=True)
class ContractExpiredArgs(_ArgsBase[EarningsDistributionAndMessage]):
    """Reports that a contract has expired."""

    @staticmethod
    def method() -> str:
        return "contract_expired()((uint64,uint64,uint64),address,byte[100])"


@dataclasses.dataclass(kw_only=True)
class ContractWithdrawArgs(_ArgsBase[EarningsDistribution]):
    """Delegator gracefully withdraws from the contract prematurely.
    The delegator beneficiary should issue a key deregistration transaction 320 round before this call."""

    del_manager: str
    """Manager address for the delegation contract."""

    @staticmethod
    def method() -> str:
        return "contract_withdraw(address)(uint64,uint64,uint64)"


@dataclasses.dataclass(kw_only=True)
class ContractReportExpirySoonArgs(_ArgsBase[Message]):
    """Reports that the contract will expire soon.
    Notification message can be triggered only a pre-defined time in advance and with limited frequency to prevent spamming."""

    before_expiry: int
    """How many rounds before contract end can the report be made."""
    report_period: int
    """How frequently can the report be made."""

    @staticmethod
    def method() -> str:
        return "contract_report_expiry_soon(uint64,uint64)(address,byte[100])"


@dataclasses.dataclass(kw_only=True)
class ContractCreateArgs(_ArgsBase[int]):
    """Creates a new DelegatorContract.
    Defines delegator contract manager and beneficiary accounts. Defines Noticeboard and ValidatorAd app ID to which this contract belongs to."""

    del_manager: str
    """Manager address for the delegation contract."""
    del_beneficiary: str
    """Beneficiary address for the delegation contract."""
    noticeboard_app_id: int
    """App ID of the Noticeboard smart contract to which to tie this contract."""

    @staticmethod
    def method() -> str:
        return "contract_create(address,address,uint64)uint64"


@dataclasses.dataclass(kw_only=True)
class ContractDeleteReturn:
    remaining_balance: int
    asset_id: int


@dataclasses.dataclass(kw_only=True)
class ContractDeleteArgs(_ArgsBase[ContractDeleteReturn]):
    """Delegator deletes an ended contract and withdraws any remaining balance.
    There can be non-zero balance to withdraw if someone sent the contract some balance, or if it was not possible to claim the fee by validator and/or noticeboard if they had the asset frozen."""

    del_manager: str
    """Manager address for the delegation contract."""

    @staticmethod
    def method() -> str:
        return "contract_delete(address)(uint64,uint64)"


class ByteReader:
    def __init__(self, data: bytes):
        self._data = data

    @property
    def as_bytes(self) -> bytes:
        return self._data

    @property
    def as_str(self) -> str:
        return self._data.decode("utf8")

    @property
    def as_base64(self) -> str:
        return base64.b64encode(self._data).decode("utf8")

    @property
    def as_hex(self) -> str:
        return self._data.hex()


class GlobalState:
    def __init__(self, data: dict[bytes, bytes | int]):
        self.cnt_breach_del = typing.cast(int, data.get(b"cnt_breach_del"))
        self.del_beneficiary = ByteReader(typing.cast(bytes, data.get(b"del_beneficiary")))
        self.del_manager = ByteReader(typing.cast(bytes, data.get(b"del_manager")))
        self.delegation_terms_balance = ByteReader(typing.cast(bytes, data.get(b"B")))
        """Balance related delegation terms."""
        self.delegation_terms_general = ByteReader(typing.cast(bytes, data.get(b"G")))
        """General delegation terms."""
        self.fee_operational = typing.cast(int, data.get(b"fee_operational"))
        self.fee_operational_partner = typing.cast(int, data.get(b"fee_operational_partner"))
        self.noticeboard_app_id = typing.cast(int, data.get(b"noticeboard_app_id"))
        self.round_breach_last = typing.cast(int, data.get(b"round_breach_last"))
        self.round_claim_last = typing.cast(int, data.get(b"round_claim_last"))
        self.round_end = typing.cast(int, data.get(b"round_end"))
        self.round_ended = typing.cast(int, data.get(b"round_ended"))
        self.round_expiry_soon_last = typing.cast(int, data.get(b"round_expiry_soon_last"))
        self.round_start = typing.cast(int, data.get(b"round_start"))
        self.sel_key = ByteReader(typing.cast(bytes, data.get(b"sel_key")))
        self.state = ByteReader(typing.cast(bytes, data.get(b"state")))
        self.state_proof_key = ByteReader(typing.cast(bytes, data.get(b"state_proof_key")))
        self.tc_sha256 = ByteReader(typing.cast(bytes, data.get(b"tc_sha256")))
        self.validator_ad_app_id = typing.cast(int, data.get(b"validator_ad_app_id"))
        self.vote_key = ByteReader(typing.cast(bytes, data.get(b"vote_key")))
        self.vote_key_dilution = typing.cast(int, data.get(b"vote_key_dilution"))


@dataclasses.dataclass(kw_only=True)
class SimulateOptions:
    allow_more_logs: bool = dataclasses.field(default=False)
    allow_empty_signatures: bool = dataclasses.field(default=False)
    extra_opcode_budget: int = dataclasses.field(default=0)
    exec_trace_config: models.SimulateTraceConfig | None         = dataclasses.field(default=None)


class Composer:

    def __init__(self, app_client: algokit_utils.ApplicationClient, atc: AtomicTransactionComposer):
        self.app_client = app_client
        self.atc = atc

    def build(self) -> AtomicTransactionComposer:
        return self.atc

    def simulate(self, options: SimulateOptions | None = None) -> SimulateAtomicTransactionResponse:
        request = models.SimulateRequest(
            allow_more_logs=options.allow_more_logs,
            allow_empty_signatures=options.allow_empty_signatures,
            extra_opcode_budget=options.extra_opcode_budget,
            exec_trace_config=options.exec_trace_config,
            txn_groups=[]
        ) if options else None
        result = self.atc.simulate(self.app_client.algod_client, request)
        return result

    def execute(self) -> AtomicTransactionResponse:
        return self.app_client.execute_atc(self.atc)

    def contract_setup(
        self,
        *,
        tc_sha256: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int],
        delegation_terms_general: DelegationTermsGeneral,
        delegation_terms_balance: DelegationTermsBalance,
        rounds_duration: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Sets the general and balance delegation contract terms.
        Defines contract start and end rounds. Opts in the payment asset if it is not ALGO.
        
        Adds a call to `contract_setup(byte[32],(uint64,uint64,uint64,uint64,address,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,(uint64,uint64)[2]),uint64)void` ABI method
        
        :param bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int] tc_sha256: Hash (i.e. SHA 256) of the Terms and Conditions defining the delegation contract concluded between the delegator and validator.
        :param DelegationTermsGeneral delegation_terms_general: General delegation contract terms.
        :param DelegationTermsBalance delegation_terms_balance: Balance delegation contract terms.
        :param int rounds_duration: Contract duration in number of rounds.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = ContractSetupArgs(
            tc_sha256=tc_sha256,
            delegation_terms_general=delegation_terms_general,
            delegation_terms_balance=delegation_terms_balance,
            rounds_duration=rounds_duration,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def contract_pay(
        self,
        *,
        txn: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Pays the validator setup and operational fee.
        
        Adds a call to `contract_pay(txn)void` ABI method
        
        :param TransactionWithSigner txn: Transaction for the payment of the setup and operational fees.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = ContractPayArgs(
            txn=txn,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def keys_confirm(
        self,
        *,
        del_manager: str,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Delegator manager confirms that the delegator beneficiary has confirmed the submitted keys..
        
        Adds a call to `keys_confirm(address)void` ABI method
        
        :param str del_manager: Purported delegator manager account.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = KeysConfirmArgs(
            del_manager=del_manager,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def keys_not_confirmed(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Reports that keys have not been confirmed in time.
        
        Adds a call to `keys_not_confirmed()(address,byte[100])` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = KeysNotConfirmedArgs()
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def keys_not_submitted(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Reports that keys have not been submitted in time.
        
        Adds a call to `keys_not_submitted()(address,byte[100])` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = KeysNotSubmittedArgs()
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def keys_submit(
        self,
        *,
        key_reg_txn_info: KeyRegTxnInfo,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """ValidatorAd submits the keys generated for the delegator beneficiary according to the contract terms.
        
        Adds a call to `keys_submit((uint64,uint64,uint64,byte[32],byte[32],byte[64],address))((uint64,uint64,uint64),address,byte[100])` ABI method
        
        :param KeyRegTxnInfo key_reg_txn_info: Information about the generated participation keys.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = KeysSubmitArgs(
            key_reg_txn_info=key_reg_txn_info,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def breach_limits(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Reports that a limit breach event occurred.
        
        Adds a call to `breach_limits()(bool,(uint64,uint64,uint64),address,byte[100])` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = BreachLimitsArgs()
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def breach_pay(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Reports that a payment for the fee cannot be made from DelegatorContract.
        This can happen if the DelegatorContract payment asset has been frozen or clawed back by the asset manager.
        
        Adds a call to `breach_pay()(address,byte[100])` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = BreachPayArgs()
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def breach_suspended(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Reports that the delegator beneficiary was suspended by consensus.
        
        Adds a call to `breach_suspended()((uint64,uint64,uint64),address,byte[100])` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = BreachSuspendedArgs()
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def contract_claim(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Claims operational fee of validator up to this round.
        Commission from the fee gets claimed by the noticeboard. Partner convenience fee gets claimed by the partner.
        
        Adds a call to `contract_claim()(uint64,uint64,uint64)` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = ContractClaimArgs()
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def contract_expired(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Reports that a contract has expired.
        
        Adds a call to `contract_expired()((uint64,uint64,uint64),address,byte[100])` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = ContractExpiredArgs()
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def contract_withdraw(
        self,
        *,
        del_manager: str,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Delegator gracefully withdraws from the contract prematurely.
        The delegator beneficiary should issue a key deregistration transaction 320 round before this call.
        
        Adds a call to `contract_withdraw(address)(uint64,uint64,uint64)` ABI method
        
        :param str del_manager: Manager address for the delegation contract.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = ContractWithdrawArgs(
            del_manager=del_manager,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def contract_report_expiry_soon(
        self,
        *,
        before_expiry: int,
        report_period: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Reports that the contract will expire soon.
        Notification message can be triggered only a pre-defined time in advance and with limited frequency to prevent spamming.
        
        Adds a call to `contract_report_expiry_soon(uint64,uint64)(address,byte[100])` ABI method
        
        :param int before_expiry: How many rounds before contract end can the report be made.
        :param int report_period: How frequently can the report be made.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = ContractReportExpirySoonArgs(
            before_expiry=before_expiry,
            report_period=report_period,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def create_contract_create(
        self,
        *,
        del_manager: str,
        del_beneficiary: str,
        noticeboard_app_id: int,
        on_complete: typing.Literal["no_op"] = "no_op",
        transaction_parameters: algokit_utils.CreateTransactionParameters | None = None,
    ) -> "Composer":
        """Creates a new DelegatorContract.
        Defines delegator contract manager and beneficiary accounts. Defines Noticeboard and ValidatorAd app ID to which this contract belongs to.
        
        Adds a call to `contract_create(address,address,uint64)uint64` ABI method
        
        :param str del_manager: Manager address for the delegation contract.
        :param str del_beneficiary: Beneficiary address for the delegation contract.
        :param int noticeboard_app_id: App ID of the Noticeboard smart contract to which to tie this contract.
        :param typing.Literal[no_op] on_complete: On completion type to use
        :param algokit_utils.CreateTransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = ContractCreateArgs(
            del_manager=del_manager,
            del_beneficiary=del_beneficiary,
            noticeboard_app_id=noticeboard_app_id,
        )
        self.app_client.compose_create(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_create_transaction_parameters(transaction_parameters, on_complete),
            **_as_dict(args, convert_all=True),
        )
        return self

    def delete_contract_delete(
        self,
        *,
        del_manager: str,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Delegator deletes an ended contract and withdraws any remaining balance.
        There can be non-zero balance to withdraw if someone sent the contract some balance, or if it was not possible to claim the fee by validator and/or noticeboard if they had the asset frozen.
        
        Adds a call to `contract_delete(address)(uint64,uint64)` ABI method
        
        :param str del_manager: Manager address for the delegation contract.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = ContractDeleteArgs(
            del_manager=del_manager,
        )
        self.app_client.compose_delete(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def clear_state(
        self,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
        app_args: list[bytes] | None = None,
    ) -> "Composer":
        """Adds a call to the application with on completion set to ClearState
    
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :param list[bytes] | None app_args: (optional) Application args to pass"""
    
        self.app_client.compose_clear_state(self.atc, _convert_transaction_parameters(transaction_parameters), app_args)
        return self


class DelegatorContractClient:
    """
        Contract between a delegator manager and a validator (a.k.a. node runner), for the latter to participate in
        consensus on the behalf of the delegator beneficiary for specific amount of time and for a specific fee.
        The contract terms and conditions are defined in this contract.
        The contract also acts as an escrow account for the delegator's payment to the validator for the service.
    
        Global state
        ------------
        noticeboard_app_id : UInt64
            App ID of noticeboard platform to which this contract belongs to.
        validator_ad_app_id : UInt64
            App ID of validator ad to which this contract belongs to.
    
    
        delegation_terms_general : DelegationTermsGeneral
            General delegation terms agreed by delegator and validator to govern this contract.
        fee_operational : UInt64
            Calculated operational fee based on the agreed contract terms.
        fee_operational_partner : UInt64
            Calculated operational fee charged for convenience by the partner.
        delegation_terms_balance : DelegationTermsBalance
            Requirements for delegator beneficiary balance agreed by delegator and validator to govern this contract.
    
        del_manager : Account
            Delegator manager account.
        del_beneficiary : UInt64
            Delegator beneficiary account.
    
        round_start : UInt64
            Agreed start round of the contract, i.e. time of its creation.
        round_end : UInt64
            Agreed end round of the contract.
        round_ended : UInt64
            Actual round at which the contract ended.
            Can be smaller than round_end in case of early contract end.
    
        vote_key_dilution : UInt64
            Vote key dilution parameter of the agreed participation key.
        vote_pk = VotePk
            Vote public key of the agreed participation key.
        selection_pk : SelPk
            Selection public key of the agreed participation key.
        state_proof_pk = StateProofPk
            State proof public key of the agreed participation key.
    
        state : Bytes
            State of the contract. Can be one of the following:
                CREATED - contract has been created.
                LIVE - contract is live.
                READY - waiting for keys submission.
                SET - contract terms have been set.
                SUBMITTED - waiting for keys confirmation.
                ENDED_NOT_SUBMITTED - keys have not been submitted in time.
                ENDED_NOT_CONFIRMED - keys have not been confirmed in time.
                ENDED_LIMITS - maximum number of limit breach events has been reached.
                ENDED_WITHDREW - delegator withdrew from the contract prematurely.
                ENDED_EXPIRED - contract has expired.
                ENDED_SUSPENDED - delegator has been suspended by consensus.
                ENDED_CANNOT_PAY - delegator cannot pay the validator (as funds could have been frozen and/or clawed back).
    
        tc_sha256 : Sha256
            Hash (i.e. SHA 256) of the Terms and Conditions defining the delegation contract concluded between the delegator
            and validator.
    
        cnt_breach_del : UInt64
            Counter of limit breach events.
        round_breach_last : UInt64
            Number of round of last limit breach event.
    
        round_claim_last : UInt64
            Number of the round the operational fee was last claimed.
    
        round_expiry_soon_last : UInt64
            Number of the round it was last reported that the contract will expire soon.
    
        Methods
        -------
        contract_create(
            del_manager: arc4.Address,
            del_beneficiary: arc4.Address,
            noticeboard_app_id: UInt64,
        ) -> Application:
            Creates a new delegator contract and returns its app ID.
    
        contract_setup(
            delegation_terms_general: DelegationTermsGeneral,
            delegation_terms_balance: DelegationTermsBalance,
            rounds_duration: UInt64,
        ) -> None:
            Sets the delegation contract terms.
    
        contract_pay(
            txn: gtxn.Transaction,
        ) -> None:
            Pays the validator setup and operational fee.
    
        keys_confirm(
            del_manager: arc4.Address,
        ) -> None:
            Delegator confirms the participation keys.
    
        keys_not_confirmed() -> Message:
            Reports that keys have not been confirmed in time.
    
        keys_not_submitted() -> Message:
            Reports that keys have not been submitted in time.
    
        keys_submit(
            key_reg_txn_info : KeyRegTxnInfo,
        ) -> EarningsDistributionAndMessage:
            ValidatorAd submits the keys generated for the delegator beneficiary according to the contract terms.
    
        breach_limits(
        ) -> BreachLimitsReturn:
            Reports that a limit breach event occurred.
    
        breach_pay(
        ) -> Message:
            Reports that a payment for the fee cannot be made from DelegatorContract (due to freeze or claw back).
    
        breach_suspended(
        ) -> EarningsDistributionAndMessage:
            Reports that the delegator beneficiary was suspended by consensus.
    
        contract_claim(
        ) -> EarningsDistribution:
            Claims and distributes the operational fee of validator up to this round to the validator and noticeboard,
            as well as to the partner.
    
        contract_expired(
        ) -> EarningsDistributionAndMessage:
            Reports that a contract has expired.
    
        contract_withdraw(
            del_manager: arc4.Address,
        ) -> EarningsDistribution:
            Delegator gracefully withdraws from the contract prematurely.
    
        contract_delete(
            del_manager: arc4.Address,
            updating : arc4.Bool,
        ) -> ContractDeleteReturn:
            Delegator deletes an ended contract and withdraws any remaining balance.
    
        contract_report_expiry_soon(
            before_expiry: UInt64,
            report_period: UInt64,
        ) -> Message:
            Reports that the contract will expire soon.
    
        Private methods
        ---------------
        _distribute_earnings(
            amount: UInt64,
            amount_partner: UInt64,
        ) -> EarningsDistribution:
            Internal method for distributing the earnings between the validator ad and the noticeboard platform,
            as well as for distributing the earnings of the partner.
    
        _is_eligible(
        ) -> arc4.Bool:
            Check if del_beneficiary meets the agreed balance limits or not
    
        _try_return_fee(
            fee_asset: Asset,
            amt_return: UInt64,
        ) -> None:
            Tries to return the input fee amount of given asset to del_manager.
            The fee cannot be returned if the del_manager is closed out or frozen for the given asset.
    
        
    
    A class for interacting with the DelegatorContract app providing high productivity and
    strongly typed methods to deploy and call the app"""

    @typing.overload
    def __init__(
        self,
        algod_client: algosdk.v2client.algod.AlgodClient,
        *,
        app_id: int = 0,
        signer: TransactionSigner | algokit_utils.Account | None = None,
        sender: str | None = None,
        suggested_params: algosdk.transaction.SuggestedParams | None = None,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        app_name: str | None = None,
    ) -> None:
        ...

    @typing.overload
    def __init__(
        self,
        algod_client: algosdk.v2client.algod.AlgodClient,
        *,
        creator: str | algokit_utils.Account,
        indexer_client: algosdk.v2client.indexer.IndexerClient | None = None,
        existing_deployments: algokit_utils.AppLookup | None = None,
        signer: TransactionSigner | algokit_utils.Account | None = None,
        sender: str | None = None,
        suggested_params: algosdk.transaction.SuggestedParams | None = None,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        app_name: str | None = None,
    ) -> None:
        ...

    def __init__(
        self,
        algod_client: algosdk.v2client.algod.AlgodClient,
        *,
        creator: str | algokit_utils.Account | None = None,
        indexer_client: algosdk.v2client.indexer.IndexerClient | None = None,
        existing_deployments: algokit_utils.AppLookup | None = None,
        app_id: int = 0,
        signer: TransactionSigner | algokit_utils.Account | None = None,
        sender: str | None = None,
        suggested_params: algosdk.transaction.SuggestedParams | None = None,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        app_name: str | None = None,
    ) -> None:
        """
        DelegatorContractClient can be created with an app_id to interact with an existing application, alternatively
        it can be created with a creator and indexer_client specified to find existing applications by name and creator.
        
        :param AlgodClient algod_client: AlgoSDK algod client
        :param int app_id: The app_id of an existing application, to instead find the application by creator and name
        use the creator and indexer_client parameters
        :param str | Account creator: The address or Account of the app creator to resolve the app_id
        :param IndexerClient indexer_client: AlgoSDK indexer client, only required if deploying or finding app_id by
        creator and app name
        :param AppLookup existing_deployments:
        :param TransactionSigner | Account signer: Account or signer to use to sign transactions, if not specified and
        creator was passed as an Account will use that.
        :param str sender: Address to use as the sender for all transactions, will use the address associated with the
        signer if not specified.
        :param TemplateValueMapping template_values: Values to use for TMPL_* template variables, dictionary keys should
        *NOT* include the TMPL_ prefix
        :param str | None app_name: Name of application to use when deploying, defaults to name defined on the
        Application Specification
            """

        self.app_spec = APP_SPEC
        
        # calling full __init__ signature, so ignoring mypy warning about overloads
        self.app_client = algokit_utils.ApplicationClient(  # type: ignore[call-overload, misc]
            algod_client=algod_client,
            app_spec=self.app_spec,
            app_id=app_id,
            creator=creator,
            indexer_client=indexer_client,
            existing_deployments=existing_deployments,
            signer=signer,
            sender=sender,
            suggested_params=suggested_params,
            template_values=template_values,
            app_name=app_name,
        )

    @property
    def algod_client(self) -> algosdk.v2client.algod.AlgodClient:
        return self.app_client.algod_client

    @property
    def app_id(self) -> int:
        return self.app_client.app_id

    @app_id.setter
    def app_id(self, value: int) -> None:
        self.app_client.app_id = value

    @property
    def app_address(self) -> str:
        return self.app_client.app_address

    @property
    def sender(self) -> str | None:
        return self.app_client.sender

    @sender.setter
    def sender(self, value: str) -> None:
        self.app_client.sender = value

    @property
    def signer(self) -> TransactionSigner | None:
        return self.app_client.signer

    @signer.setter
    def signer(self, value: TransactionSigner) -> None:
        self.app_client.signer = value

    @property
    def suggested_params(self) -> algosdk.transaction.SuggestedParams | None:
        return self.app_client.suggested_params

    @suggested_params.setter
    def suggested_params(self, value: algosdk.transaction.SuggestedParams | None) -> None:
        self.app_client.suggested_params = value

    def get_global_state(self) -> GlobalState:
        """Returns the application's global state wrapped in a strongly typed class with options to format the stored value"""

        state = typing.cast(dict[bytes, bytes | int], self.app_client.get_global_state(raw=True))
        return GlobalState(state)

    def contract_setup(
        self,
        *,
        tc_sha256: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int],
        delegation_terms_general: DelegationTermsGeneral,
        delegation_terms_balance: DelegationTermsBalance,
        rounds_duration: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Sets the general and balance delegation contract terms.
        Defines contract start and end rounds. Opts in the payment asset if it is not ALGO.
        
        Calls `contract_setup(byte[32],(uint64,uint64,uint64,uint64,address,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,(uint64,uint64)[2]),uint64)void` ABI method
        
        :param bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int] tc_sha256: Hash (i.e. SHA 256) of the Terms and Conditions defining the delegation contract concluded between the delegator and validator.
        :param DelegationTermsGeneral delegation_terms_general: General delegation contract terms.
        :param DelegationTermsBalance delegation_terms_balance: Balance delegation contract terms.
        :param int rounds_duration: Contract duration in number of rounds.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = ContractSetupArgs(
            tc_sha256=tc_sha256,
            delegation_terms_general=delegation_terms_general,
            delegation_terms_balance=delegation_terms_balance,
            rounds_duration=rounds_duration,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def contract_pay(
        self,
        *,
        txn: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Pays the validator setup and operational fee.
        
        Calls `contract_pay(txn)void` ABI method
        
        :param TransactionWithSigner txn: Transaction for the payment of the setup and operational fees.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = ContractPayArgs(
            txn=txn,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def keys_confirm(
        self,
        *,
        del_manager: str,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Delegator manager confirms that the delegator beneficiary has confirmed the submitted keys..
        
        Calls `keys_confirm(address)void` ABI method
        
        :param str del_manager: Purported delegator manager account.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = KeysConfirmArgs(
            del_manager=del_manager,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def keys_not_confirmed(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[Message]:
        """Reports that keys have not been confirmed in time.
        
        Calls `keys_not_confirmed()(address,byte[100])` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[Message]: Address of delegator manager."""

        args = KeysNotConfirmedArgs()
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        elements = self.app_spec.hints[args.method()].structs["output"]["elements"]
        result_dict = {element[0]: value for element, value in zip(elements, result.return_value)}
        result.return_value = Message(**result_dict)
        return result

    def keys_not_submitted(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[Message]:
        """Reports that keys have not been submitted in time.
        
        Calls `keys_not_submitted()(address,byte[100])` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[Message]: Address of delegator manager."""

        args = KeysNotSubmittedArgs()
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        elements = self.app_spec.hints[args.method()].structs["output"]["elements"]
        result_dict = {element[0]: value for element, value in zip(elements, result.return_value)}
        result.return_value = Message(**result_dict)
        return result

    def keys_submit(
        self,
        *,
        key_reg_txn_info: KeyRegTxnInfo,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[EarningsDistributionAndMessage]:
        """ValidatorAd submits the keys generated for the delegator beneficiary according to the contract terms.
        
        Calls `keys_submit((uint64,uint64,uint64,byte[32],byte[32],byte[64],address))((uint64,uint64,uint64),address,byte[100])` ABI method
        
        :param KeyRegTxnInfo key_reg_txn_info: Information about the generated participation keys.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[EarningsDistributionAndMessage]: Amount of earnings of the validator which equal the setup fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted."""

        args = KeysSubmitArgs(
            key_reg_txn_info=key_reg_txn_info,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        elements = self.app_spec.hints[args.method()].structs["output"]["elements"]
        result_dict = {element[0]: value for element, value in zip(elements, result.return_value)}
        result.return_value = EarningsDistributionAndMessage(**result_dict)
        return result

    def breach_limits(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[BreachLimitsReturn]:
        """Reports that a limit breach event occurred.
        
        Calls `breach_limits()(bool,(uint64,uint64,uint64),address,byte[100])` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[BreachLimitsReturn]: Boolean denoting if maximum number of breaches has already been reached (True) or not (False)."""

        args = BreachLimitsArgs()
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        elements = self.app_spec.hints[args.method()].structs["output"]["elements"]
        result_dict = {element[0]: value for element, value in zip(elements, result.return_value)}
        result.return_value = BreachLimitsReturn(**result_dict)
        return result

    def breach_pay(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[Message]:
        """Reports that a payment for the fee cannot be made from DelegatorContract.
        This can happen if the DelegatorContract payment asset has been frozen or clawed back by the asset manager.
        
        Calls `breach_pay()(address,byte[100])` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[Message]: Address of delegator manager."""

        args = BreachPayArgs()
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        elements = self.app_spec.hints[args.method()].structs["output"]["elements"]
        result_dict = {element[0]: value for element, value in zip(elements, result.return_value)}
        result.return_value = Message(**result_dict)
        return result

    def breach_suspended(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[EarningsDistributionAndMessage]:
        """Reports that the delegator beneficiary was suspended by consensus.
        
        Calls `breach_suspended()((uint64,uint64,uint64),address,byte[100])` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[EarningsDistributionAndMessage]: Amount of earnings of the validator which equal any unclaimed operational fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted."""

        args = BreachSuspendedArgs()
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        elements = self.app_spec.hints[args.method()].structs["output"]["elements"]
        result_dict = {element[0]: value for element, value in zip(elements, result.return_value)}
        result.return_value = EarningsDistributionAndMessage(**result_dict)
        return result

    def contract_claim(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[EarningsDistribution]:
        """Claims operational fee of validator up to this round.
        Commission from the fee gets claimed by the noticeboard. Partner convenience fee gets claimed by the partner.
        
        Calls `contract_claim()(uint64,uint64,uint64)` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[EarningsDistribution]: Amount of earnings of the validator which equal any unclaimed operational fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted."""

        args = ContractClaimArgs()
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        elements = self.app_spec.hints[args.method()].structs["output"]["elements"]
        result_dict = {element[0]: value for element, value in zip(elements, result.return_value)}
        result.return_value = EarningsDistribution(**result_dict)
        return result

    def contract_expired(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[EarningsDistributionAndMessage]:
        """Reports that a contract has expired.
        
        Calls `contract_expired()((uint64,uint64,uint64),address,byte[100])` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[EarningsDistributionAndMessage]: Amount of earnings of the validator which equal any unclaimed operational fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted."""

        args = ContractExpiredArgs()
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        elements = self.app_spec.hints[args.method()].structs["output"]["elements"]
        result_dict = {element[0]: value for element, value in zip(elements, result.return_value)}
        result.return_value = EarningsDistributionAndMessage(**result_dict)
        return result

    def contract_withdraw(
        self,
        *,
        del_manager: str,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[EarningsDistribution]:
        """Delegator gracefully withdraws from the contract prematurely.
        The delegator beneficiary should issue a key deregistration transaction 320 round before this call.
        
        Calls `contract_withdraw(address)(uint64,uint64,uint64)` ABI method
        
        :param str del_manager: Manager address for the delegation contract.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[EarningsDistribution]: Amount of earnings of the validator which equal any unclaimed operational fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted."""

        args = ContractWithdrawArgs(
            del_manager=del_manager,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        elements = self.app_spec.hints[args.method()].structs["output"]["elements"]
        result_dict = {element[0]: value for element, value in zip(elements, result.return_value)}
        result.return_value = EarningsDistribution(**result_dict)
        return result

    def contract_report_expiry_soon(
        self,
        *,
        before_expiry: int,
        report_period: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[Message]:
        """Reports that the contract will expire soon.
        Notification message can be triggered only a pre-defined time in advance and with limited frequency to prevent spamming.
        
        Calls `contract_report_expiry_soon(uint64,uint64)(address,byte[100])` ABI method
        
        :param int before_expiry: How many rounds before contract end can the report be made.
        :param int report_period: How frequently can the report be made.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[Message]: Address of delegator manager."""

        args = ContractReportExpirySoonArgs(
            before_expiry=before_expiry,
            report_period=report_period,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        elements = self.app_spec.hints[args.method()].structs["output"]["elements"]
        result_dict = {element[0]: value for element, value in zip(elements, result.return_value)}
        result.return_value = Message(**result_dict)
        return result

    def create_contract_create(
        self,
        *,
        del_manager: str,
        del_beneficiary: str,
        noticeboard_app_id: int,
        on_complete: typing.Literal["no_op"] = "no_op",
        transaction_parameters: algokit_utils.CreateTransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[int]:
        """Creates a new DelegatorContract.
        Defines delegator contract manager and beneficiary accounts. Defines Noticeboard and ValidatorAd app ID to which this contract belongs to.
        
        Calls `contract_create(address,address,uint64)uint64` ABI method
        
        :param str del_manager: Manager address for the delegation contract.
        :param str del_beneficiary: Beneficiary address for the delegation contract.
        :param int noticeboard_app_id: App ID of the Noticeboard smart contract to which to tie this contract.
        :param typing.Literal[no_op] on_complete: On completion type to use
        :param algokit_utils.CreateTransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[int]: App ID of the created delegation contract application."""

        args = ContractCreateArgs(
            del_manager=del_manager,
            del_beneficiary=del_beneficiary,
            noticeboard_app_id=noticeboard_app_id,
        )
        result = self.app_client.create(
            call_abi_method=args.method(),
            transaction_parameters=_convert_create_transaction_parameters(transaction_parameters, on_complete),
            **_as_dict(args, convert_all=True),
        )
        return result

    def delete_contract_delete(
        self,
        *,
        del_manager: str,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[ContractDeleteReturn]:
        """Delegator deletes an ended contract and withdraws any remaining balance.
        There can be non-zero balance to withdraw if someone sent the contract some balance, or if it was not possible to claim the fee by validator and/or noticeboard if they had the asset frozen.
        
        Calls `contract_delete(address)(uint64,uint64)` ABI method
        
        :param str del_manager: Manager address for the delegation contract.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[ContractDeleteReturn]: Balance of the fee asset that remained in the contract."""

        args = ContractDeleteArgs(
            del_manager=del_manager,
        )
        result = self.app_client.delete(
            call_abi_method=args.method(),
            transaction_parameters=_convert_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        elements = self.app_spec.hints[args.method()].structs["output"]["elements"]
        result_dict = {element[0]: value for element, value in zip(elements, result.return_value)}
        result.return_value = ContractDeleteReturn(**result_dict)
        return result

    def clear_state(
        self,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
        app_args: list[bytes] | None = None,
    ) -> algokit_utils.TransactionResponse:
        """Calls the application with on completion set to ClearState
    
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :param list[bytes] | None app_args: (optional) Application args to pass
        :returns algokit_utils.TransactionResponse: The result of the transaction"""
    
        return self.app_client.clear_state(_convert_transaction_parameters(transaction_parameters), app_args)

    def deploy(
        self,
        version: str | None = None,
        *,
        signer: TransactionSigner | None = None,
        sender: str | None = None,
        allow_update: bool | None = None,
        allow_delete: bool | None = None,
        on_update: algokit_utils.OnUpdate = algokit_utils.OnUpdate.Fail,
        on_schema_break: algokit_utils.OnSchemaBreak = algokit_utils.OnSchemaBreak.Fail,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        create_args: DeployCreate[ContractCreateArgs],
        update_args: algokit_utils.DeployCallArgs | None = None,
        delete_args: Deploy[ContractDeleteArgs],
    ) -> algokit_utils.DeployResponse:
        """Deploy an application and update client to reference it.
        
        Idempotently deploy (create, update/delete if changed) an app against the given name via the given creator
        account, including deploy-time template placeholder substitutions.
        To understand the architecture decisions behind this functionality please see
        <https://github.com/algorandfoundation/algokit-cli/blob/main/docs/architecture-decisions/2023-01-12_smart-contract-deployment.md>
        
        ```{note}
        If there is a breaking state schema change to an existing app (and `on_schema_break` is set to
        'ReplaceApp' the existing app will be deleted and re-created.
        ```
        
        ```{note}
        If there is an update (different TEAL code) to an existing app (and `on_update` is set to 'ReplaceApp')
        the existing app will be deleted and re-created.
        ```
        
        :param str version: version to use when creating or updating app, if None version will be auto incremented
        :param algosdk.atomic_transaction_composer.TransactionSigner signer: signer to use when deploying app
        , if None uses self.signer
        :param str sender: sender address to use when deploying app, if None uses self.sender
        :param bool allow_delete: Used to set the `TMPL_DELETABLE` template variable to conditionally control if an app
        can be deleted
        :param bool allow_update: Used to set the `TMPL_UPDATABLE` template variable to conditionally control if an app
        can be updated
        :param OnUpdate on_update: Determines what action to take if an application update is required
        :param OnSchemaBreak on_schema_break: Determines what action to take if an application schema requirements
        has increased beyond the current allocation
        :param dict[str, int|str|bytes] template_values: Values to use for `TMPL_*` template variables, dictionary keys
        should *NOT* include the TMPL_ prefix
        :param DeployCreate[ContractCreateArgs] create_args: Arguments used when creating an application
        :param algokit_utils.DeployCallArgs | None update_args: Arguments used when updating an application
        :param Deploy[ContractDeleteArgs] delete_args: Arguments used when deleting an application
        :return DeployResponse: details action taken and relevant transactions
        :raises DeploymentError: If the deployment failed"""

        return self.app_client.deploy(
            version,
            signer=signer,
            sender=sender,
            allow_update=allow_update,
            allow_delete=allow_delete,
            on_update=on_update,
            on_schema_break=on_schema_break,
            template_values=template_values,
            create_args=_convert_deploy_args(create_args),
            update_args=_convert_deploy_args(update_args),
            delete_args=_convert_deploy_args(delete_args),
        )

    def compose(self, atc: AtomicTransactionComposer | None = None) -> Composer:
        return Composer(self.app_client, atc or AtomicTransactionComposer())
