# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _titanlib
else:
    import _titanlib

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _titanlib.delete_SwigPyIterator

    def value(self):
        return _titanlib.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _titanlib.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _titanlib.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _titanlib.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _titanlib.SwigPyIterator_equal(self, x)

    def copy(self):
        return _titanlib.SwigPyIterator_copy(self)

    def next(self):
        return _titanlib.SwigPyIterator_next(self)

    def __next__(self):
        return _titanlib.SwigPyIterator___next__(self)

    def previous(self):
        return _titanlib.SwigPyIterator_previous(self)

    def advance(self, n):
        return _titanlib.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _titanlib.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _titanlib.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _titanlib.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _titanlib.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _titanlib.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _titanlib.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _titanlib:
_titanlib.SwigPyIterator_swigregister(SwigPyIterator)

class IntVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _titanlib.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _titanlib.IntVector___nonzero__(self)

    def __bool__(self):
        return _titanlib.IntVector___bool__(self)

    def __len__(self):
        return _titanlib.IntVector___len__(self)

    def __getslice__(self, i, j):
        return _titanlib.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _titanlib.IntVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _titanlib.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _titanlib.IntVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _titanlib.IntVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _titanlib.IntVector___setitem__(self, *args)

    def pop(self):
        return _titanlib.IntVector_pop(self)

    def append(self, x):
        return _titanlib.IntVector_append(self, x)

    def empty(self):
        return _titanlib.IntVector_empty(self)

    def size(self):
        return _titanlib.IntVector_size(self)

    def swap(self, v):
        return _titanlib.IntVector_swap(self, v)

    def begin(self):
        return _titanlib.IntVector_begin(self)

    def end(self):
        return _titanlib.IntVector_end(self)

    def rbegin(self):
        return _titanlib.IntVector_rbegin(self)

    def rend(self):
        return _titanlib.IntVector_rend(self)

    def clear(self):
        return _titanlib.IntVector_clear(self)

    def get_allocator(self):
        return _titanlib.IntVector_get_allocator(self)

    def pop_back(self):
        return _titanlib.IntVector_pop_back(self)

    def erase(self, *args):
        return _titanlib.IntVector_erase(self, *args)

    def __init__(self, *args):
        _titanlib.IntVector_swiginit(self, _titanlib.new_IntVector(*args))

    def push_back(self, x):
        return _titanlib.IntVector_push_back(self, x)

    def front(self):
        return _titanlib.IntVector_front(self)

    def back(self):
        return _titanlib.IntVector_back(self)

    def assign(self, n, x):
        return _titanlib.IntVector_assign(self, n, x)

    def resize(self, *args):
        return _titanlib.IntVector_resize(self, *args)

    def insert(self, *args):
        return _titanlib.IntVector_insert(self, *args)

    def reserve(self, n):
        return _titanlib.IntVector_reserve(self, n)

    def capacity(self):
        return _titanlib.IntVector_capacity(self)
    __swig_destroy__ = _titanlib.delete_IntVector

# Register IntVector in _titanlib:
_titanlib.IntVector_swigregister(IntVector)

class FloatVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _titanlib.FloatVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _titanlib.FloatVector___nonzero__(self)

    def __bool__(self):
        return _titanlib.FloatVector___bool__(self)

    def __len__(self):
        return _titanlib.FloatVector___len__(self)

    def __getslice__(self, i, j):
        return _titanlib.FloatVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _titanlib.FloatVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _titanlib.FloatVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _titanlib.FloatVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _titanlib.FloatVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _titanlib.FloatVector___setitem__(self, *args)

    def pop(self):
        return _titanlib.FloatVector_pop(self)

    def append(self, x):
        return _titanlib.FloatVector_append(self, x)

    def empty(self):
        return _titanlib.FloatVector_empty(self)

    def size(self):
        return _titanlib.FloatVector_size(self)

    def swap(self, v):
        return _titanlib.FloatVector_swap(self, v)

    def begin(self):
        return _titanlib.FloatVector_begin(self)

    def end(self):
        return _titanlib.FloatVector_end(self)

    def rbegin(self):
        return _titanlib.FloatVector_rbegin(self)

    def rend(self):
        return _titanlib.FloatVector_rend(self)

    def clear(self):
        return _titanlib.FloatVector_clear(self)

    def get_allocator(self):
        return _titanlib.FloatVector_get_allocator(self)

    def pop_back(self):
        return _titanlib.FloatVector_pop_back(self)

    def erase(self, *args):
        return _titanlib.FloatVector_erase(self, *args)

    def __init__(self, *args):
        _titanlib.FloatVector_swiginit(self, _titanlib.new_FloatVector(*args))

    def push_back(self, x):
        return _titanlib.FloatVector_push_back(self, x)

    def front(self):
        return _titanlib.FloatVector_front(self)

    def back(self):
        return _titanlib.FloatVector_back(self)

    def assign(self, n, x):
        return _titanlib.FloatVector_assign(self, n, x)

    def resize(self, *args):
        return _titanlib.FloatVector_resize(self, *args)

    def insert(self, *args):
        return _titanlib.FloatVector_insert(self, *args)

    def reserve(self, n):
        return _titanlib.FloatVector_reserve(self, n)

    def capacity(self):
        return _titanlib.FloatVector_capacity(self)
    __swig_destroy__ = _titanlib.delete_FloatVector

# Register FloatVector in _titanlib:
_titanlib.FloatVector_swigregister(FloatVector)

class FloatVector3(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _titanlib.FloatVector3_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _titanlib.FloatVector3___nonzero__(self)

    def __bool__(self):
        return _titanlib.FloatVector3___bool__(self)

    def __len__(self):
        return _titanlib.FloatVector3___len__(self)

    def __getslice__(self, i, j):
        return _titanlib.FloatVector3___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _titanlib.FloatVector3___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _titanlib.FloatVector3___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _titanlib.FloatVector3___delitem__(self, *args)

    def __getitem__(self, *args):
        return _titanlib.FloatVector3___getitem__(self, *args)

    def __setitem__(self, *args):
        return _titanlib.FloatVector3___setitem__(self, *args)

    def pop(self):
        return _titanlib.FloatVector3_pop(self)

    def append(self, x):
        return _titanlib.FloatVector3_append(self, x)

    def empty(self):
        return _titanlib.FloatVector3_empty(self)

    def size(self):
        return _titanlib.FloatVector3_size(self)

    def swap(self, v):
        return _titanlib.FloatVector3_swap(self, v)

    def begin(self):
        return _titanlib.FloatVector3_begin(self)

    def end(self):
        return _titanlib.FloatVector3_end(self)

    def rbegin(self):
        return _titanlib.FloatVector3_rbegin(self)

    def rend(self):
        return _titanlib.FloatVector3_rend(self)

    def clear(self):
        return _titanlib.FloatVector3_clear(self)

    def get_allocator(self):
        return _titanlib.FloatVector3_get_allocator(self)

    def pop_back(self):
        return _titanlib.FloatVector3_pop_back(self)

    def erase(self, *args):
        return _titanlib.FloatVector3_erase(self, *args)

    def __init__(self, *args):
        _titanlib.FloatVector3_swiginit(self, _titanlib.new_FloatVector3(*args))

    def push_back(self, x):
        return _titanlib.FloatVector3_push_back(self, x)

    def front(self):
        return _titanlib.FloatVector3_front(self)

    def back(self):
        return _titanlib.FloatVector3_back(self)

    def assign(self, n, x):
        return _titanlib.FloatVector3_assign(self, n, x)

    def resize(self, *args):
        return _titanlib.FloatVector3_resize(self, *args)

    def insert(self, *args):
        return _titanlib.FloatVector3_insert(self, *args)

    def reserve(self, n):
        return _titanlib.FloatVector3_reserve(self, n)

    def capacity(self):
        return _titanlib.FloatVector3_capacity(self)
    __swig_destroy__ = _titanlib.delete_FloatVector3

# Register FloatVector3 in _titanlib:
_titanlib.FloatVector3_swigregister(FloatVector3)

class IntVector2(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _titanlib.IntVector2_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _titanlib.IntVector2___nonzero__(self)

    def __bool__(self):
        return _titanlib.IntVector2___bool__(self)

    def __len__(self):
        return _titanlib.IntVector2___len__(self)

    def __getslice__(self, i, j):
        return _titanlib.IntVector2___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _titanlib.IntVector2___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _titanlib.IntVector2___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _titanlib.IntVector2___delitem__(self, *args)

    def __getitem__(self, *args):
        return _titanlib.IntVector2___getitem__(self, *args)

    def __setitem__(self, *args):
        return _titanlib.IntVector2___setitem__(self, *args)

    def pop(self):
        return _titanlib.IntVector2_pop(self)

    def append(self, x):
        return _titanlib.IntVector2_append(self, x)

    def empty(self):
        return _titanlib.IntVector2_empty(self)

    def size(self):
        return _titanlib.IntVector2_size(self)

    def swap(self, v):
        return _titanlib.IntVector2_swap(self, v)

    def begin(self):
        return _titanlib.IntVector2_begin(self)

    def end(self):
        return _titanlib.IntVector2_end(self)

    def rbegin(self):
        return _titanlib.IntVector2_rbegin(self)

    def rend(self):
        return _titanlib.IntVector2_rend(self)

    def clear(self):
        return _titanlib.IntVector2_clear(self)

    def get_allocator(self):
        return _titanlib.IntVector2_get_allocator(self)

    def pop_back(self):
        return _titanlib.IntVector2_pop_back(self)

    def erase(self, *args):
        return _titanlib.IntVector2_erase(self, *args)

    def __init__(self, *args):
        _titanlib.IntVector2_swiginit(self, _titanlib.new_IntVector2(*args))

    def push_back(self, x):
        return _titanlib.IntVector2_push_back(self, x)

    def front(self):
        return _titanlib.IntVector2_front(self)

    def back(self):
        return _titanlib.IntVector2_back(self)

    def assign(self, n, x):
        return _titanlib.IntVector2_assign(self, n, x)

    def resize(self, *args):
        return _titanlib.IntVector2_resize(self, *args)

    def insert(self, *args):
        return _titanlib.IntVector2_insert(self, *args)

    def reserve(self, n):
        return _titanlib.IntVector2_reserve(self, n)

    def capacity(self):
        return _titanlib.IntVector2_capacity(self)
    __swig_destroy__ = _titanlib.delete_IntVector2

# Register IntVector2 in _titanlib:
_titanlib.IntVector2_swigregister(IntVector2)

class DoubleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _titanlib.DoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _titanlib.DoubleVector___nonzero__(self)

    def __bool__(self):
        return _titanlib.DoubleVector___bool__(self)

    def __len__(self):
        return _titanlib.DoubleVector___len__(self)

    def __getslice__(self, i, j):
        return _titanlib.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _titanlib.DoubleVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _titanlib.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _titanlib.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _titanlib.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _titanlib.DoubleVector___setitem__(self, *args)

    def pop(self):
        return _titanlib.DoubleVector_pop(self)

    def append(self, x):
        return _titanlib.DoubleVector_append(self, x)

    def empty(self):
        return _titanlib.DoubleVector_empty(self)

    def size(self):
        return _titanlib.DoubleVector_size(self)

    def swap(self, v):
        return _titanlib.DoubleVector_swap(self, v)

    def begin(self):
        return _titanlib.DoubleVector_begin(self)

    def end(self):
        return _titanlib.DoubleVector_end(self)

    def rbegin(self):
        return _titanlib.DoubleVector_rbegin(self)

    def rend(self):
        return _titanlib.DoubleVector_rend(self)

    def clear(self):
        return _titanlib.DoubleVector_clear(self)

    def get_allocator(self):
        return _titanlib.DoubleVector_get_allocator(self)

    def pop_back(self):
        return _titanlib.DoubleVector_pop_back(self)

    def erase(self, *args):
        return _titanlib.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        _titanlib.DoubleVector_swiginit(self, _titanlib.new_DoubleVector(*args))

    def push_back(self, x):
        return _titanlib.DoubleVector_push_back(self, x)

    def front(self):
        return _titanlib.DoubleVector_front(self)

    def back(self):
        return _titanlib.DoubleVector_back(self)

    def assign(self, n, x):
        return _titanlib.DoubleVector_assign(self, n, x)

    def resize(self, *args):
        return _titanlib.DoubleVector_resize(self, *args)

    def insert(self, *args):
        return _titanlib.DoubleVector_insert(self, *args)

    def reserve(self, n):
        return _titanlib.DoubleVector_reserve(self, n)

    def capacity(self):
        return _titanlib.DoubleVector_capacity(self)
    __swig_destroy__ = _titanlib.delete_DoubleVector

# Register DoubleVector in _titanlib:
_titanlib.DoubleVector_swigregister(DoubleVector)

class FloatVector2(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _titanlib.FloatVector2_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _titanlib.FloatVector2___nonzero__(self)

    def __bool__(self):
        return _titanlib.FloatVector2___bool__(self)

    def __len__(self):
        return _titanlib.FloatVector2___len__(self)

    def __getslice__(self, i, j):
        return _titanlib.FloatVector2___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _titanlib.FloatVector2___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _titanlib.FloatVector2___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _titanlib.FloatVector2___delitem__(self, *args)

    def __getitem__(self, *args):
        return _titanlib.FloatVector2___getitem__(self, *args)

    def __setitem__(self, *args):
        return _titanlib.FloatVector2___setitem__(self, *args)

    def pop(self):
        return _titanlib.FloatVector2_pop(self)

    def append(self, x):
        return _titanlib.FloatVector2_append(self, x)

    def empty(self):
        return _titanlib.FloatVector2_empty(self)

    def size(self):
        return _titanlib.FloatVector2_size(self)

    def swap(self, v):
        return _titanlib.FloatVector2_swap(self, v)

    def begin(self):
        return _titanlib.FloatVector2_begin(self)

    def end(self):
        return _titanlib.FloatVector2_end(self)

    def rbegin(self):
        return _titanlib.FloatVector2_rbegin(self)

    def rend(self):
        return _titanlib.FloatVector2_rend(self)

    def clear(self):
        return _titanlib.FloatVector2_clear(self)

    def get_allocator(self):
        return _titanlib.FloatVector2_get_allocator(self)

    def pop_back(self):
        return _titanlib.FloatVector2_pop_back(self)

    def erase(self, *args):
        return _titanlib.FloatVector2_erase(self, *args)

    def __init__(self, *args):
        _titanlib.FloatVector2_swiginit(self, _titanlib.new_FloatVector2(*args))

    def push_back(self, x):
        return _titanlib.FloatVector2_push_back(self, x)

    def front(self):
        return _titanlib.FloatVector2_front(self)

    def back(self):
        return _titanlib.FloatVector2_back(self)

    def assign(self, n, x):
        return _titanlib.FloatVector2_assign(self, n, x)

    def resize(self, *args):
        return _titanlib.FloatVector2_resize(self, *args)

    def insert(self, *args):
        return _titanlib.FloatVector2_insert(self, *args)

    def reserve(self, n):
        return _titanlib.FloatVector2_reserve(self, n)

    def capacity(self):
        return _titanlib.FloatVector2_capacity(self)
    __swig_destroy__ = _titanlib.delete_FloatVector2

# Register FloatVector2 in _titanlib:
_titanlib.FloatVector2_swigregister(FloatVector2)

class DoubleVector2(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _titanlib.DoubleVector2_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _titanlib.DoubleVector2___nonzero__(self)

    def __bool__(self):
        return _titanlib.DoubleVector2___bool__(self)

    def __len__(self):
        return _titanlib.DoubleVector2___len__(self)

    def __getslice__(self, i, j):
        return _titanlib.DoubleVector2___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _titanlib.DoubleVector2___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _titanlib.DoubleVector2___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _titanlib.DoubleVector2___delitem__(self, *args)

    def __getitem__(self, *args):
        return _titanlib.DoubleVector2___getitem__(self, *args)

    def __setitem__(self, *args):
        return _titanlib.DoubleVector2___setitem__(self, *args)

    def pop(self):
        return _titanlib.DoubleVector2_pop(self)

    def append(self, x):
        return _titanlib.DoubleVector2_append(self, x)

    def empty(self):
        return _titanlib.DoubleVector2_empty(self)

    def size(self):
        return _titanlib.DoubleVector2_size(self)

    def swap(self, v):
        return _titanlib.DoubleVector2_swap(self, v)

    def begin(self):
        return _titanlib.DoubleVector2_begin(self)

    def end(self):
        return _titanlib.DoubleVector2_end(self)

    def rbegin(self):
        return _titanlib.DoubleVector2_rbegin(self)

    def rend(self):
        return _titanlib.DoubleVector2_rend(self)

    def clear(self):
        return _titanlib.DoubleVector2_clear(self)

    def get_allocator(self):
        return _titanlib.DoubleVector2_get_allocator(self)

    def pop_back(self):
        return _titanlib.DoubleVector2_pop_back(self)

    def erase(self, *args):
        return _titanlib.DoubleVector2_erase(self, *args)

    def __init__(self, *args):
        _titanlib.DoubleVector2_swiginit(self, _titanlib.new_DoubleVector2(*args))

    def push_back(self, x):
        return _titanlib.DoubleVector2_push_back(self, x)

    def front(self):
        return _titanlib.DoubleVector2_front(self)

    def back(self):
        return _titanlib.DoubleVector2_back(self)

    def assign(self, n, x):
        return _titanlib.DoubleVector2_assign(self, n, x)

    def resize(self, *args):
        return _titanlib.DoubleVector2_resize(self, *args)

    def insert(self, *args):
        return _titanlib.DoubleVector2_insert(self, *args)

    def reserve(self, n):
        return _titanlib.DoubleVector2_reserve(self, n)

    def capacity(self):
        return _titanlib.DoubleVector2_capacity(self)
    __swig_destroy__ = _titanlib.delete_DoubleVector2

# Register DoubleVector2 in _titanlib:
_titanlib.DoubleVector2_swigregister(DoubleVector2)

TITANLIB_VERSION = _titanlib.TITANLIB_VERSION

__version__ = _titanlib.__version__

Geodetic = _titanlib.Geodetic

Cartesian = _titanlib.Cartesian

VerticalProfile = _titanlib.VerticalProfile

VerticalProfileTheilSen = _titanlib.VerticalProfileTheilSen

MeanOuterCircle = _titanlib.MeanOuterCircle

MedianOuterCircle = _titanlib.MedianOuterCircle

External = _titanlib.External

Eq = _titanlib.Eq

Gt = _titanlib.Gt

Geq = _titanlib.Geq

Lt = _titanlib.Lt

Leq = _titanlib.Leq


def sct(*args):
    r"""
    sct(points, values, num_min, num_max, inner_radius, outer_radius, num_iterations, num_min_prof, min_elev_diff, min_horizontal_scale, vertical_scale, pos, neg, eps2, obs_to_check=titanlib::ivec()) -> IntVector

    Parameters
    ----------
    points: titanlib::Points const &
    values: titanlib::vec const &
    num_min: int
    num_max: int
    inner_radius: float
    outer_radius: float
    num_iterations: int
    num_min_prof: int
    min_elev_diff: float
    min_horizontal_scale: float
    vertical_scale: float
    pos: titanlib::vec const &
    neg: titanlib::vec const &
    eps2: titanlib::vec const &
    obs_to_check: titanlib::ivec const &

    """
    return _titanlib.sct(*args)

def sct_resistant(points, values, obs_to_check, background_values, background_elab_type, num_min_outer, num_max_outer, inner_radius, outer_radius, num_iterations, num_min_prof, min_elev_diff, min_horizontal_scale, max_horizontal_scale, kth_closest_obs_horizontal_scale, vertical_scale, value_mina, value_maxa, value_minv, value_maxv, eps2, tpos, tneg, debug, basic):
    r"""
    sct_resistant(points, values, obs_to_check, background_values, background_elab_type, num_min_outer, num_max_outer, inner_radius, outer_radius, num_iterations, num_min_prof, min_elev_diff, min_horizontal_scale, max_horizontal_scale, kth_closest_obs_horizontal_scale, vertical_scale, value_mina, value_maxa, value_minv, value_maxv, eps2, tpos, tneg, debug, basic) -> IntVector

    Parameters
    ----------
    points: titanlib::Points const &
    values: titanlib::vec const &
    obs_to_check: titanlib::ivec const &
    background_values: titanlib::vec const &
    background_elab_type: enum titanlib::BackgroundType
    num_min_outer: int
    num_max_outer: int
    inner_radius: float
    outer_radius: float
    num_iterations: int
    num_min_prof: int
    min_elev_diff: float
    min_horizontal_scale: float
    max_horizontal_scale: float
    kth_closest_obs_horizontal_scale: int
    vertical_scale: float
    value_mina: titanlib::vec const &
    value_maxa: titanlib::vec const &
    value_minv: titanlib::vec const &
    value_maxv: titanlib::vec const &
    eps2: titanlib::vec const &
    tpos: titanlib::vec const &
    tneg: titanlib::vec const &
    debug: bool
    basic: bool

    """
    return _titanlib.sct_resistant(points, values, obs_to_check, background_values, background_elab_type, num_min_outer, num_max_outer, inner_radius, outer_radius, num_iterations, num_min_prof, min_elev_diff, min_horizontal_scale, max_horizontal_scale, kth_closest_obs_horizontal_scale, vertical_scale, value_mina, value_maxa, value_minv, value_maxv, eps2, tpos, tneg, debug, basic)

def sct_dual(points, values, obs_to_check, event_thresholds, condition, num_min_outer, num_max_outer, inner_radius, outer_radius, num_iterations, min_horizontal_scale, max_horizontal_scale, kth_closest_obs_horizontal_scale, vertical_scale, test_thresholds, debug):
    r"""
    sct_dual(points, values, obs_to_check, event_thresholds, condition, num_min_outer, num_max_outer, inner_radius, outer_radius, num_iterations, min_horizontal_scale, max_horizontal_scale, kth_closest_obs_horizontal_scale, vertical_scale, test_thresholds, debug) -> IntVector

    Parameters
    ----------
    points: titanlib::Points const &
    values: titanlib::vec const &
    obs_to_check: titanlib::ivec const &
    event_thresholds: titanlib::vec const &
    condition: enum titanlib::ConditionType
    num_min_outer: int
    num_max_outer: int
    inner_radius: float
    outer_radius: float
    num_iterations: int
    min_horizontal_scale: float
    max_horizontal_scale: float
    kth_closest_obs_horizontal_scale: int
    vertical_scale: float
    test_thresholds: titanlib::vec const &
    debug: bool

    """
    return _titanlib.sct_dual(points, values, obs_to_check, event_thresholds, condition, num_min_outer, num_max_outer, inner_radius, outer_radius, num_iterations, min_horizontal_scale, max_horizontal_scale, kth_closest_obs_horizontal_scale, vertical_scale, test_thresholds, debug)

def fgt(points, values, obs_to_check, background_values, background_uncertainties, background_elab_type, num_min_outer, num_max_outer, inner_radius, outer_radius, num_iterations, num_min_prof, min_elev_diff, value_mina, value_maxa, value_minv, value_maxv, tpos, tneg, debug, basic):
    r"""
    fgt(points, values, obs_to_check, background_values, background_uncertainties, background_elab_type, num_min_outer, num_max_outer, inner_radius, outer_radius, num_iterations, num_min_prof, min_elev_diff, value_mina, value_maxa, value_minv, value_maxv, tpos, tneg, debug, basic) -> IntVector

    Parameters
    ----------
    points: titanlib::Points const &
    values: titanlib::vec const &
    obs_to_check: titanlib::ivec const &
    background_values: titanlib::vec const &
    background_uncertainties: titanlib::vec const &
    background_elab_type: enum titanlib::BackgroundType
    num_min_outer: int
    num_max_outer: int
    inner_radius: float
    outer_radius: float
    num_iterations: int
    num_min_prof: int
    min_elev_diff: float
    value_mina: titanlib::vec const &
    value_maxa: titanlib::vec const &
    value_minv: titanlib::vec const &
    value_maxv: titanlib::vec const &
    tpos: titanlib::vec const &
    tneg: titanlib::vec const &
    debug: bool
    basic: bool

    """
    return _titanlib.fgt(points, values, obs_to_check, background_values, background_uncertainties, background_elab_type, num_min_outer, num_max_outer, inner_radius, outer_radius, num_iterations, num_min_prof, min_elev_diff, value_mina, value_maxa, value_minv, value_maxv, tpos, tneg, debug, basic)

def range_check(values, min, max):
    r"""
    range_check(values, min, max) -> IntVector

    Parameters
    ----------
    values: titanlib::vec const &
    min: titanlib::vec const &
    max: titanlib::vec const &

    """
    return _titanlib.range_check(values, min, max)

def range_check_climatology(points, values, unixtime, pos, neg):
    r"""
    range_check_climatology(points, values, unixtime, pos, neg) -> IntVector

    Parameters
    ----------
    points: titanlib::Points const &
    values: titanlib::vec const &
    unixtime: int
    pos: titanlib::vec const &
    neg: titanlib::vec const &

    """
    return _titanlib.range_check_climatology(points, values, unixtime, pos, neg)

def buddy_check(*args):
    r"""
    buddy_check(points, values, radius, num_min, threshold, max_elev_diff, elev_gradient, min_std, num_iterations, obs_to_check=titanlib::ivec()) -> IntVector

    Parameters
    ----------
    points: titanlib::Points const &
    values: titanlib::vec const &
    radius: titanlib::vec const &
    num_min: titanlib::ivec const &
    threshold: float
    max_elev_diff: float
    elev_gradient: float
    min_std: float
    num_iterations: int
    obs_to_check: titanlib::ivec const &

    """
    return _titanlib.buddy_check(*args)

def buddy_event_check(*args):
    r"""
    buddy_event_check(points, values, radius, num_min, event_threshold, threshold, max_elev_diff, elev_gradient, num_iterations, obs_to_check=titanlib::ivec()) -> IntVector

    Parameters
    ----------
    points: titanlib::Points const &
    values: titanlib::vec const &
    radius: titanlib::vec const &
    num_min: titanlib::ivec const &
    event_threshold: float
    threshold: float
    max_elev_diff: float
    elev_gradient: float
    num_iterations: int
    obs_to_check: titanlib::ivec const &

    """
    return _titanlib.buddy_event_check(*args)

def isolation_check(*args):
    r"""
    isolation_check(points, num_min, radius, vertical_radius=MV) -> IntVector

    Parameters
    ----------
    points: titanlib::Points const &
    num_min: int
    radius: float
    vertical_radius: float

    isolation_check(points, num_min, radius, vertical_radius=titanlib::vec()) -> IntVector

    Parameters
    ----------
    points: titanlib::Points const &
    num_min: titanlib::ivec const &
    radius: titanlib::vec const &
    vertical_radius: titanlib::vec const &

    """
    return _titanlib.isolation_check(*args)

def duplicate_check(*args):
    r"""
    duplicate_check(points, radius, vertical_range=MV) -> IntVector

    Parameters
    ----------
    points: titanlib::Points const &
    radius: float
    vertical_range: float

    """
    return _titanlib.duplicate_check(*args)

def metadata_check(points, check_lat=True, check_lon=True, check_elev=True, check_laf=True):
    r"""
    metadata_check(points, check_lat=True, check_lon=True, check_elev=True, check_laf=True) -> IntVector

    Parameters
    ----------
    points: titanlib::Points const &
    check_lat: bool
    check_lon: bool
    check_elev: bool
    check_laf: bool

    """
    return _titanlib.metadata_check(points, check_lat, check_lon, check_elev, check_laf)

def lag_reduction_filter(times, values, a=0.5, b=0.5, k1=0.25, k2=0.25, n=10):
    r"""
    lag_reduction_filter(times, values, a=0.5, b=0.5, k1=0.25, k2=0.25, n=10) -> FloatVector

    Parameters
    ----------
    times: titanlib::vec const &
    values: titanlib::vec const &
    a: float
    b: float
    k1: float
    k2: float
    n: int

    """
    return _titanlib.lag_reduction_filter(times, values, a, b, k1, k2, n)

def set_omp_threads(num):
    r"""
    set_omp_threads(num)

    Parameters
    ----------
    num: int

    """
    return _titanlib.set_omp_threads(num)

def get_omp_threads():
    r"""get_omp_threads() -> int"""
    return _titanlib.get_omp_threads()

def initialize_omp():
    r"""initialize_omp()"""
    return _titanlib.initialize_omp()

def version():
    r"""version() -> std::string"""
    return _titanlib.version()

def clock():
    r"""clock() -> double"""
    return _titanlib.clock()

def is_valid(value):
    r"""
    is_valid(value) -> bool

    Parameters
    ----------
    value: float

    """
    return _titanlib.is_valid(value)

def compute_vertical_profile(elevs, oelevs, values, num_min_prof, min_elev_diff, debug=False):
    r"""
    compute_vertical_profile(elevs, oelevs, values, num_min_prof, min_elev_diff, debug=False) -> FloatVector

    Parameters
    ----------
    elevs: titanlib::vec const &
    oelevs: titanlib::vec const &
    values: titanlib::vec const &
    num_min_prof: int
    min_elev_diff: double
    debug: bool

    """
    return _titanlib.compute_vertical_profile(elevs, oelevs, values, num_min_prof, min_elev_diff, debug)

def compute_vertical_profile_Theil_Sen(elevs, oelevs, values, num_min_prof, min_elev_diff, debug):
    r"""
    compute_vertical_profile_Theil_Sen(elevs, oelevs, values, num_min_prof, min_elev_diff, debug) -> FloatVector

    Parameters
    ----------
    elevs: titanlib::vec const &
    oelevs: titanlib::vec const &
    values: titanlib::vec const &
    num_min_prof: int
    min_elev_diff: double
    debug: bool

    """
    return _titanlib.compute_vertical_profile_Theil_Sen(elevs, oelevs, values, num_min_prof, min_elev_diff, debug)

def convert_coordinates(*args):
    r"""
    convert_coordinates(lats, lons) -> bool

    Parameters
    ----------
    lats: titanlib::vec const &
    lons: titanlib::vec const &

    convert_coordinates(lat, lon, x_coord, y_coord, z_coord) -> bool

    Parameters
    ----------
    lat: float
    lon: float
    x_coord: float &
    y_coord: float &
    z_coord: float &

    """
    return _titanlib.convert_coordinates(*args)

def interpolate_to_points(input_lats, input_lons, input_values, output_lats, output_lons):
    r"""
    interpolate_to_points(input_lats, input_lons, input_values, output_lats, output_lons) -> FloatVector

    Parameters
    ----------
    input_lats: titanlib::vec2 const &
    input_lons: titanlib::vec2 const &
    input_values: titanlib::vec2 const &
    output_lats: titanlib::vec const &
    output_lons: titanlib::vec const &

    """
    return _titanlib.interpolate_to_points(input_lats, input_lons, input_values, output_lats, output_lons)

def deg2rad(deg):
    r"""
    deg2rad(deg) -> float

    Parameters
    ----------
    deg: float

    """
    return _titanlib.deg2rad(deg)

def calc_distance(*args):
    r"""
    calc_distance(lat1, lon1, lat2, lon2) -> float

    Parameters
    ----------
    lat1: float
    lon1: float
    lat2: float
    lon2: float

    calc_distance(x0, y0, z0, x1, y1, z1) -> float

    Parameters
    ----------
    x0: float
    y0: float
    z0: float
    x1: float
    y1: float
    z1: float

    """
    return _titanlib.calc_distance(*args)

def compute_quantile(quantile, array):
    r"""
    compute_quantile(quantile, array) -> float

    Parameters
    ----------
    quantile: double
    array: titanlib::vec const &

    """
    return _titanlib.compute_quantile(quantile, array)

def find_k_closest(array, k):
    r"""
    find_k_closest(array, k) -> float

    Parameters
    ----------
    array: titanlib::vec const &
    k: int

    """
    return _titanlib.find_k_closest(array, k)

def background(elevs, values, num_min_prof, min_elev_diff, value_minp, value_maxp, background_type, external_background_values, indices_global_outer, debug):
    r"""
    background(elevs, values, num_min_prof, min_elev_diff, value_minp, value_maxp, background_type, external_background_values, indices_global_outer, debug) -> FloatVector

    Parameters
    ----------
    elevs: titanlib::vec const &
    values: titanlib::vec const &
    num_min_prof: int
    min_elev_diff: float
    value_minp: float
    value_maxp: float
    background_type: enum titanlib::BackgroundType
    external_background_values: titanlib::vec const &
    indices_global_outer: titanlib::ivec const &
    debug: bool

    """
    return _titanlib.background(elevs, values, num_min_prof, min_elev_diff, value_minp, value_maxp, background_type, external_background_values, indices_global_outer, debug)

def invert_matrix(input, inverse):
    r"""
    invert_matrix(input, inverse) -> bool

    Parameters
    ----------
    input: boost::numeric::ublas::matrix< float > const &
    inverse: boost::numeric::ublas::matrix< float > &

    """
    return _titanlib.invert_matrix(input, inverse)

def set_indices(indices_global_outer_guess, obs_test, dqcflags, dist_outer_guess, inner_radius, test_just_this, indices_global_outer, indices_global_test, indices_outer_inner, indices_outer_test, indices_inner_test):
    r"""
    set_indices(indices_global_outer_guess, obs_test, dqcflags, dist_outer_guess, inner_radius, test_just_this, indices_global_outer, indices_global_test, indices_outer_inner, indices_outer_test, indices_inner_test) -> bool

    Parameters
    ----------
    indices_global_outer_guess: titanlib::ivec const &
    obs_test: titanlib::ivec const &
    dqcflags: titanlib::ivec const &
    dist_outer_guess: titanlib::vec const &
    inner_radius: float
    test_just_this: int
    indices_global_outer: titanlib::ivec &
    indices_global_test: titanlib::ivec &
    indices_outer_inner: titanlib::ivec &
    indices_outer_test: titanlib::ivec &
    indices_inner_test: titanlib::ivec &

    """
    return _titanlib.set_indices(indices_global_outer_guess, obs_test, dqcflags, dist_outer_guess, inner_radius, test_just_this, indices_global_outer, indices_global_test, indices_outer_inner, indices_outer_test, indices_inner_test)

def test_array(v):
    r"""
    test_array(v) -> float *

    Parameters
    ----------
    v: float *

    """
    return _titanlib.test_array(v)

def test_not_implemented_exception():
    r"""test_not_implemented_exception()"""
    return _titanlib.test_not_implemented_exception()
class Point(object):
    r"""Proxy of C++ titanlib::Point class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self, lat, lon, elev=MV, laf=MV, type=Geodetic) -> Point

        Parameters
        ----------
        lat: float
        lon: float
        elev: float
        laf: float
        type: enum titanlib::CoordinateType

        """
        _titanlib.Point_swiginit(self, _titanlib.new_Point(*args))
    lat = property(_titanlib.Point_lat_get, _titanlib.Point_lat_set, doc=r"""lat""")
    lon = property(_titanlib.Point_lon_get, _titanlib.Point_lon_set, doc=r"""lon""")
    elev = property(_titanlib.Point_elev_get, _titanlib.Point_elev_set, doc=r"""elev""")
    laf = property(_titanlib.Point_laf_get, _titanlib.Point_laf_set, doc=r"""laf""")
    type = property(_titanlib.Point_type_get, _titanlib.Point_type_set, doc=r"""type""")
    __swig_destroy__ = _titanlib.delete_Point

# Register Point in _titanlib:
_titanlib.Point_swigregister(Point)
cvar = _titanlib.cvar
MV = cvar.MV
MV_CML = cvar.MV_CML
pi = cvar.pi
radius_earth = cvar.radius_earth

class KDTree(object):
    r"""Proxy of C++ titanlib::KDTree class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self, lats, lons, type=Geodetic) -> KDTree

        Parameters
        ----------
        lats: titanlib::vec
        lons: titanlib::vec
        type: enum titanlib::CoordinateType

        __init__(self, other) -> KDTree

        Parameters
        ----------
        other: titanlib::KDTree const &

        __init__(self, type=Geodetic) -> KDTree

        Parameters
        ----------
        type: enum titanlib::CoordinateType

        """
        _titanlib.KDTree_swiginit(self, _titanlib.new_KDTree(*args))

    def get_nearest_neighbour(self, lat, lon, include_match=True):
        r"""
        get_nearest_neighbour(self, lat, lon, include_match=True) -> int

        Parameters
        ----------
        lat: float
        lon: float
        include_match: bool

        """
        return _titanlib.KDTree_get_nearest_neighbour(self, lat, lon, include_match)

    def get_neighbours(self, lat, lon, radius, include_match=True):
        r"""
        get_neighbours(self, lat, lon, radius, include_match=True) -> IntVector

        Parameters
        ----------
        lat: float
        lon: float
        radius: float
        include_match: bool

        """
        return _titanlib.KDTree_get_neighbours(self, lat, lon, radius, include_match)

    def get_neighbours_with_distance(self, lat, lon, radius, include_match=True):
        r"""
        get_neighbours_with_distance(self, lat, lon, radius, include_match=True) -> IntVector

        Parameters
        ----------
        lat: float
        lon: float
        radius: float
        include_match: bool

        """
        return _titanlib.KDTree_get_neighbours_with_distance(self, lat, lon, radius, include_match)

    def get_num_neighbours(self, lat, lon, radius, include_match=True):
        r"""
        get_num_neighbours(self, lat, lon, radius, include_match=True) -> int

        Parameters
        ----------
        lat: float
        lon: float
        radius: float
        include_match: bool

        """
        return _titanlib.KDTree_get_num_neighbours(self, lat, lon, radius, include_match)

    def get_closest_neighbours(self, lat, lon, num, include_match=True):
        r"""
        get_closest_neighbours(self, lat, lon, num, include_match=True) -> IntVector

        Parameters
        ----------
        lat: float
        lon: float
        num: int
        include_match: bool

        """
        return _titanlib.KDTree_get_closest_neighbours(self, lat, lon, num, include_match)

    def convert_coordinates(self, *args):
        r"""
        convert_coordinates(self, lats, lons) -> bool

        Parameters
        ----------
        lats: titanlib::vec const &
        lons: titanlib::vec const &

        convert_coordinates(self, lat, lon, x_coord, y_coord, z_coord) -> bool

        Parameters
        ----------
        lat: float
        lon: float
        x_coord: float &
        y_coord: float &
        z_coord: float &

        """
        return _titanlib.KDTree_convert_coordinates(self, *args)

    @staticmethod
    def deg2rad(deg):
        r"""
        deg2rad(deg) -> float

        Parameters
        ----------
        deg: float

        """
        return _titanlib.KDTree_deg2rad(deg)

    @staticmethod
    def rad2deg(deg):
        r"""
        rad2deg(deg) -> float

        Parameters
        ----------
        deg: float

        """
        return _titanlib.KDTree_rad2deg(deg)

    @staticmethod
    def calc_distance(*args):
        r"""
        calc_distance(lat1, lon1, lat2, lon2, type=Geodetic) -> float

        Parameters
        ----------
        lat1: float
        lon1: float
        lat2: float
        lon2: float
        type: enum titanlib::CoordinateType

        calc_distance(x0, y0, z0, x1, y1, z1) -> float

        Parameters
        ----------
        x0: float
        y0: float
        z0: float
        x1: float
        y1: float
        z1: float

        """
        return _titanlib.KDTree_calc_distance(*args)

    @staticmethod
    def calc_distance_fast(*args):
        r"""
        calc_distance_fast(lat1, lon1, lat2, lon2, type=Geodetic) -> float

        Parameters
        ----------
        lat1: float
        lon1: float
        lat2: float
        lon2: float
        type: enum titanlib::CoordinateType

        calc_distance_fast(p1, p2) -> float

        Parameters
        ----------
        p1: titanlib::Point const &
        p2: titanlib::Point const &

        """
        return _titanlib.KDTree_calc_distance_fast(*args)

    def get_lats(self):
        r"""get_lats(self) -> FloatVector"""
        return _titanlib.KDTree_get_lats(self)

    def get_lons(self):
        r"""get_lons(self) -> FloatVector"""
        return _titanlib.KDTree_get_lons(self)

    def size(self):
        r"""size(self) -> int"""
        return _titanlib.KDTree_size(self)

    def get_coordinate_type(self):
        r"""get_coordinate_type(self) -> titanlib::CoordinateType"""
        return _titanlib.KDTree_get_coordinate_type(self)
    __swig_destroy__ = _titanlib.delete_KDTree

# Register KDTree in _titanlib:
_titanlib.KDTree_swigregister(KDTree)

def KDTree_deg2rad(deg):
    r"""
    KDTree_deg2rad(deg) -> float

    Parameters
    ----------
    deg: float

    """
    return _titanlib.KDTree_deg2rad(deg)

def KDTree_rad2deg(deg):
    r"""
    KDTree_rad2deg(deg) -> float

    Parameters
    ----------
    deg: float

    """
    return _titanlib.KDTree_rad2deg(deg)

def KDTree_calc_distance(*args):
    r"""
    KDTree_calc_distance(lat1, lon1, lat2, lon2, type=Geodetic) -> float

    Parameters
    ----------
    lat1: float
    lon1: float
    lat2: float
    lon2: float
    type: enum titanlib::CoordinateType

    KDTree_calc_distance(x0, y0, z0, x1, y1, z1) -> float

    Parameters
    ----------
    x0: float
    y0: float
    z0: float
    x1: float
    y1: float
    z1: float

    """
    return _titanlib.KDTree_calc_distance(*args)

def KDTree_calc_distance_fast(*args):
    r"""
    KDTree_calc_distance_fast(lat1, lon1, lat2, lon2, type=Geodetic) -> float

    Parameters
    ----------
    lat1: float
    lon1: float
    lat2: float
    lon2: float
    type: enum titanlib::CoordinateType

    KDTree_calc_distance_fast(p1, p2) -> float

    Parameters
    ----------
    p1: titanlib::Point const &
    p2: titanlib::Point const &

    """
    return _titanlib.KDTree_calc_distance_fast(*args)

class Points(object):
    r"""Proxy of C++ titanlib::Points class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> Points
        __init__(self, lats, lons, elevs=titanlib::vec(), lafs=titanlib::vec(), type=Geodetic) -> Points

        Parameters
        ----------
        lats: titanlib::vec
        lons: titanlib::vec
        elevs: titanlib::vec
        lafs: titanlib::vec
        type: enum titanlib::CoordinateType

        __init__(self, tree, elevs=titanlib::vec(), lafs=titanlib::vec()) -> Points

        Parameters
        ----------
        tree: titanlib::KDTree
        elevs: titanlib::vec
        lafs: titanlib::vec

        __init__(self, other) -> Points

        Parameters
        ----------
        other: titanlib::Points const &

        """
        _titanlib.Points_swiginit(self, _titanlib.new_Points(*args))

    def get_nearest_neighbour(self, lat, lon, include_match=True):
        r"""
        get_nearest_neighbour(self, lat, lon, include_match=True) -> int

        Parameters
        ----------
        lat: float
        lon: float
        include_match: bool

        """
        return _titanlib.Points_get_nearest_neighbour(self, lat, lon, include_match)

    def get_neighbours(self, lat, lon, radius, include_match=True):
        r"""
        get_neighbours(self, lat, lon, radius, include_match=True) -> IntVector

        Parameters
        ----------
        lat: float
        lon: float
        radius: float
        include_match: bool

        """
        return _titanlib.Points_get_neighbours(self, lat, lon, radius, include_match)

    def get_neighbours_with_distance(self, lat, lon, radius, include_match=True):
        r"""
        get_neighbours_with_distance(self, lat, lon, radius, include_match=True) -> IntVector

        Parameters
        ----------
        lat: float
        lon: float
        radius: float
        include_match: bool

        """
        return _titanlib.Points_get_neighbours_with_distance(self, lat, lon, radius, include_match)

    def get_num_neighbours(self, lat, lon, radius, include_match=True):
        r"""
        get_num_neighbours(self, lat, lon, radius, include_match=True) -> int

        Parameters
        ----------
        lat: float
        lon: float
        radius: float
        include_match: bool

        """
        return _titanlib.Points_get_num_neighbours(self, lat, lon, radius, include_match)

    def get_closest_neighbours(self, lat, lon, num, include_match=True):
        r"""
        get_closest_neighbours(self, lat, lon, num, include_match=True) -> IntVector

        Parameters
        ----------
        lat: float
        lon: float
        num: int
        include_match: bool

        """
        return _titanlib.Points_get_closest_neighbours(self, lat, lon, num, include_match)

    def get_lats(self):
        r"""get_lats(self) -> FloatVector"""
        return _titanlib.Points_get_lats(self)

    def get_lons(self):
        r"""get_lons(self) -> FloatVector"""
        return _titanlib.Points_get_lons(self)

    def get_elevs(self):
        r"""get_elevs(self) -> FloatVector"""
        return _titanlib.Points_get_elevs(self)

    def get_lafs(self):
        r"""get_lafs(self) -> FloatVector"""
        return _titanlib.Points_get_lafs(self)

    def size(self):
        r"""size(self) -> int"""
        return _titanlib.Points_size(self)

    def get_coordinate_type(self):
        r"""get_coordinate_type(self) -> titanlib::CoordinateType"""
        return _titanlib.Points_get_coordinate_type(self)
    __swig_destroy__ = _titanlib.delete_Points

# Register Points in _titanlib:
_titanlib.Points_swigregister(Points)

class Dataset(object):
    r"""Proxy of C++ titanlib::Dataset class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, points, ivalues):
        r"""
        __init__(self, points, ivalues) -> Dataset

        Parameters
        ----------
        points: titanlib::Points
        ivalues: titanlib::vec

        """
        _titanlib.Dataset_swiginit(self, _titanlib.new_Dataset(points, ivalues))

    def range_check(self, *args):
        r"""
        range_check(self, min, max, indices=titanlib::ivec(1, -1))

        Parameters
        ----------
        min: titanlib::vec const &
        max: titanlib::vec const &
        indices: titanlib::ivec const &

        """
        return _titanlib.Dataset_range_check(self, *args)

    def range_check_climatology(self, *args):
        r"""
        range_check_climatology(self, unixtime, pos, neg, indices=titanlib::ivec(1, -1))

        Parameters
        ----------
        unixtime: int
        pos: titanlib::vec const &
        neg: titanlib::vec const &
        indices: titanlib::ivec const &

        """
        return _titanlib.Dataset_range_check_climatology(self, *args)

    def sct(self, *args):
        r"""
        sct(self, num_min, num_max, inner_radius, outer_radius, num_iterations, num_min_prof, min_elev_diff, min_horizontal_scale, vertical_scale, t2pos, t2neg, eps2, indices=titanlib::ivec(1, -1))

        Parameters
        ----------
        num_min: int
        num_max: int
        inner_radius: float
        outer_radius: float
        num_iterations: int
        num_min_prof: int
        min_elev_diff: float
        min_horizontal_scale: float
        vertical_scale: float
        t2pos: titanlib::vec const &
        t2neg: titanlib::vec const &
        eps2: titanlib::vec const &
        indices: titanlib::ivec const &

        """
        return _titanlib.Dataset_sct(self, *args)

    def sct_dual(self, *args):
        r"""
        sct_dual(self, event_thresholds, condition, num_min, num_max, inner_radius, outer_radius, num_iterations, min_horizontal_scale, max_horizontal_scale, kth_closest_obs_horizontal_scale, vertical_scale, test_thresholds, debug, obs_to_check=titanlib::ivec(), indices=titanlib::ivec(1, -1))

        Parameters
        ----------
        event_thresholds: titanlib::vec const &
        condition: enum titanlib::ConditionType
        num_min: int
        num_max: int
        inner_radius: float
        outer_radius: float
        num_iterations: int
        min_horizontal_scale: float
        max_horizontal_scale: float
        kth_closest_obs_horizontal_scale: int
        vertical_scale: float
        test_thresholds: titanlib::vec const &
        debug: bool
        obs_to_check: titanlib::ivec const &
        indices: titanlib::ivec const &

        """
        return _titanlib.Dataset_sct_dual(self, *args)

    def buddy_check(self, *args):
        r"""
        buddy_check(self, radius, num_min, threshold, max_elev_diff, elev_gradient, min_std, num_iterations, obs_to_check=titanlib::ivec(), indices=titanlib::ivec(1, -1))

        Parameters
        ----------
        radius: titanlib::vec const &
        num_min: titanlib::ivec const &
        threshold: float
        max_elev_diff: float
        elev_gradient: float
        min_std: float
        num_iterations: int
        obs_to_check: titanlib::ivec const &
        indices: titanlib::ivec const &

        """
        return _titanlib.Dataset_buddy_check(self, *args)

    def buddy_event_check(self, *args):
        r"""
        buddy_event_check(self, radius, num_min, event_threshold, threshold, max_elev_diff, elev_gradient, num_iterations, obs_to_check=titanlib::ivec(), indices=titanlib::ivec(1, -1))

        Parameters
        ----------
        radius: titanlib::vec const &
        num_min: titanlib::ivec const &
        event_threshold: float
        threshold: float
        max_elev_diff: float
        elev_gradient: float
        num_iterations: int
        obs_to_check: titanlib::ivec const &
        indices: titanlib::ivec const &

        """
        return _titanlib.Dataset_buddy_event_check(self, *args)

    def isolation_check(self, *args):
        r"""
        isolation_check(self, num_min, radius, vertical_radius=MV, indices=titanlib::ivec(1, -1))

        Parameters
        ----------
        num_min: int
        radius: float
        vertical_radius: float
        indices: titanlib::ivec const &

        isolation_check(self, num_min, radius, vertical_radius=titanlib::vec(), indices=titanlib::ivec(1, -1))

        Parameters
        ----------
        num_min: titanlib::ivec const &
        radius: titanlib::vec const &
        vertical_radius: titanlib::vec const &
        indices: titanlib::ivec const &

        """
        return _titanlib.Dataset_isolation_check(self, *args)

    def duplicate_check(self, *args):
        r"""
        duplicate_check(self, radius, vertical_range=MV, indices=titanlib::ivec(1, -1))

        Parameters
        ----------
        radius: float
        vertical_range: float
        indices: titanlib::ivec const &

        """
        return _titanlib.Dataset_duplicate_check(self, *args)

    def dem_check(self, dem, max_elev_diff):
        r"""
        dem_check(self, dem, max_elev_diff)

        Parameters
        ----------
        dem: titanlib::vec const &
        max_elev_diff: float

        """
        return _titanlib.Dataset_dem_check(self, dem, max_elev_diff)

    def external_check(self, flags):
        r"""
        external_check(self, flags)

        Parameters
        ----------
        flags: titanlib::ivec const &

        """
        return _titanlib.Dataset_external_check(self, flags)

    def metadata_check(self, *args):
        r"""
        metadata_check(self, check_lat=True, check_lon=True, check_elev=True, check_laf=True, indices=titanlib::ivec(1, -1))

        Parameters
        ----------
        check_lat: bool
        check_lon: bool
        check_elev: bool
        check_laf: bool
        indices: titanlib::ivec const &

        """
        return _titanlib.Dataset_metadata_check(self, *args)

    def get_points(self):
        r"""get_points(self) -> Points"""
        return _titanlib.Dataset_get_points(self)

    def get_values(self):
        r"""get_values(self) -> FloatVector"""
        return _titanlib.Dataset_get_values(self)

    def get_flags(self):
        r"""get_flags(self) -> IntVector"""
        return _titanlib.Dataset_get_flags(self)

    def set_values(self, ivalues):
        r"""
        set_values(self, ivalues)

        Parameters
        ----------
        ivalues: titanlib::vec

        """
        return _titanlib.Dataset_set_values(self, ivalues)

    def set_flags(self, ivalues):
        r"""
        set_flags(self, ivalues)

        Parameters
        ----------
        ivalues: titanlib::ivec

        """
        return _titanlib.Dataset_set_flags(self, ivalues)

    def set_points(self, ipoints):
        r"""
        set_points(self, ipoints)

        Parameters
        ----------
        ipoints: titanlib::Points

        """
        return _titanlib.Dataset_set_points(self, ipoints)
    points = property(_titanlib.Dataset_points_get, _titanlib.Dataset_points_set, doc=r"""points""")
    values = property(_titanlib.Dataset_values_get, _titanlib.Dataset_values_set, doc=r"""values""")
    flags = property(_titanlib.Dataset_flags_get, _titanlib.Dataset_flags_set, doc=r"""flags""")
    __swig_destroy__ = _titanlib.delete_Dataset

# Register Dataset in _titanlib:
_titanlib.Dataset_swigregister(Dataset)

class not_implemented_exception(object):
    r"""Proxy of C++ titanlib::not_implemented_exception class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(self) -> not_implemented_exception"""
        _titanlib.not_implemented_exception_swiginit(self, _titanlib.new_not_implemented_exception())
    __swig_destroy__ = _titanlib.delete_not_implemented_exception

# Register not_implemented_exception in _titanlib:
_titanlib.not_implemented_exception_swigregister(not_implemented_exception)


def subset(*args):
    r"""
    subset(input, indices) -> Points

    Parameters
    ----------
    input: titanlib::Points const &
    indices: titanlib::ivec const &

    subset(array, indices) -> IntVector

    Parameters
    ----------
    array: std::vector< int,std::allocator< int > > const &
    indices: titanlib::ivec const &

    subset(array, indices) -> FloatVector

    Parameters
    ----------
    array: std::vector< float,std::allocator< float > > const &
    indices: titanlib::ivec const &

    """
    return _titanlib.subset(*args)


