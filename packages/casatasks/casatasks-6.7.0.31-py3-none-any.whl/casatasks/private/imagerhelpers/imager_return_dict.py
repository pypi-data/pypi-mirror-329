import os
import numpy as np

# Assume CASA 6, CASA 5 is no longer built
from casatools import image
from casatasks import casalog
ia = image()


class ImagingDict():
    """
    Class that constructs the tclean return dictionary - implemented
    specifically for the niter=0 case, to reproduce the dictionary generated in
    C++ without modifying the C++ code.

    Attributes:
    -----------
    residname       : Name of the input residual image (required)
    modelname       : Name of the input model image (optional)
    summaryminor    : The dictionary containing summaryminor
    retrec          : The full return dictionary

    Methods:
    --------

    image_dimensions(residname)
        Use the image() tool to query for the number of Stokes planes and
        frequency channels in the input image.

    fill_summary_minor(residname, modelname, channo, stokes, stokes_axis, freq_axis, fullsummary):
        Given the input image name, and the corresponding field, channel number, and
        Stokes plane, extract the relevant information from the image to generate a
        summaryminor dict as defined

    construct_summary_minor(self, paramList):
        Constructs and populates a nested dictionary containing the summaryMinor()
        information required by tclean.
        This is a duplicate of the existing summaryMinor() class in C++, but is
        being re-written here to avoid issues with modifying iterControl.

    construct_residual_dict(paramList):
        Construct the residual dictionary given the input image name and associated parameters. This residual dictionary is meant to
        duplicate that generated by imager.getSummary(fullsummary) for the special
    """

    def __init__(self) -> None:
        self._returndict = {}
        self._summaryminor = {}

        # These three parameters cannot be assigned, only accessed.
        # They reflect the values in the summaryminor key in the return dict.

        self._nfield = 0
        self._nstokes = 0
        self._nchan = 0

        self.residname = ''
        self.modelname = ''
        self.maskname = ''

        self._initialize()

        self._summaryminor_keys = ['iterDone', 'peakRes', 'modelFlux', 'cycleThresh',
                                   'cycleStartIters', 'startIterDone',
                                   'startPeakRes', 'startModelFlux',
                                   'startPeakResNM', 'peakResNM', 'masksum',
                                   'mpiServer', 'stopCode']

    def __str__(self) -> str:
        """
        Pretty print the return dictionary.
        """

        retstr = ''
        for key, val in self._returndict.items():
            if key == 'summaryminor':
                retstr += 'summaryminor:\n'
                for field in val.keys():
                    for freq in val[field].keys():
                        for stokes in val[field][freq].keys():
                            for key2, val2 in val[field][freq][stokes].items():
                                retstr += f'\t Field: {field: 3d}, Chan: {freq: 3d}, Stokes: {stokes :2d}, {key2}, {val2}\n'
            else:
                retstr += f'{key}: {val}\n'
        return retstr

    @property
    def returndict(self) -> dict:
        return self._returndict

    @returndict.setter
    def returndict(self, inpdict: dict) -> None:
        self._returndict = inpdict

    @returndict.deleter
    def returndict(self) -> None:
        del self._returndict

    @property
    def nfield(self) -> int:
        self._nfield = len(self._returndict['summaryminor'].keys())
        return self._nfield

    @nfield.deleter
    def nfield(self) -> None:
        del self._nfield

    # XXX : This assumes that the number of channels is the same for all fields
    @property
    def nchan(self) -> int:
        self._nchan = 0
        for field in self._returndict['summaryminor'].keys():
            self._nchan = len(self._returndict['summaryminor'][field].keys())
            break

        return self._nchan

    @nchan.deleter
    def nchan(self) -> None:
        del self._nchan

    @property
    def nstokes(self) -> int:
        self._nstokes = 0
        for field in self._returndict['summaryminor'].keys():
            for freq in self._returndict['summaryminor'][field].keys():
                self._nstokes = len(self._returndict['summaryminor'][field][freq].keys())
                break

        return self._nstokes

    @nstokes.deleter
    def nstokes(self) -> None:
        del self._nstokes

    def _initialize(self) -> None:
        """
        Initialize the return dictionary with dummy values. This sets up the
        dictionary structure and keys to expect, and will be filled in with
        real values when running tclean or deconvolve.
        """

        # Initialize the values that don't need to inspect any images
        self._returndict['cleanstate'] = ''
        self._returndict['cyclefactor'] = 1.0
        self._returndict['cycleiterdone'] = 0
        self._returndict['cycleniter'] = 0
        self._returndict['cyclethreshold'] = 0
        self._returndict['interactiveiterdone'] = 0
        self._returndict['interactivemode'] = False
        self._returndict['interactiveniter'] = 0
        self._returndict['interactivethreshold'] = 0

        self._returndict['iterdone'] = 0
        self._returndict['loopgain'] = 0
        self._returndict['maxpsffraction'] = 0
        self._returndict['maxpsfsidelobe'] = 0
        self._returndict['minpsffraction'] = 0

        self._returndict['niter'] = 0
        self._returndict['nmajordone'] = 0
        self._returndict['nsigma'] = 0.0
        self._returndict['stopcode'] = 0

        self._returndict['summarymajor'] = np.array([])
        # Summary minor is nested as {field{freq{stokes}}
        # TODO : Figure out a better way to initialize the empty summary minor
        # without explicitly setting a field/stokes/channel number.
        self._returndict['summaryminor'] = {}
        self._returndict['summaryminor'][0] = {}
        self._returndict['summaryminor'][0][0] = {}
        self._returndict['summaryminor'][0][0][0] = self._initialize_summary_minor()

        self._returndict['threshold'] = 0.0
        self._returndict['stopDescription'] = 'Zero iterations performed'


    def _initialize_summary_minor(self) -> dict:
        """
        Initialize the summary minor dictionary with dummy values. This sets up the
        dictionary structure and keys to expect, and will be filled in with
        real values when running tclean or deconvolve.
        """

        self._summaryminor['iterDone'] = []
        self._summaryminor['peakRes'] = []
        self._summaryminor['modelFlux'] = []
        self._summaryminor['cycleThresh'] = []
        self._summaryminor['cycleStartIters'] = []
        self._summaryminor['startIterDone'] = []
        self._summaryminor['startPeakRes'] = []
        self._summaryminor['startModelFlux'] = []
        self._summaryminor['startPeakResNM'] = []
        self._summaryminor['peakResNM'] = []
        self._summaryminor['masksum'] = []
        self._summaryminor['mpiServer'] = []
        self._summaryminor['stopCode'] = []

        return self._summaryminor



    def get_key(self, key:str, field:int=0, chan:int=0, stokes:int=0) -> list:
        """
        Return the list of values for the specified key. If requesting a key
        within "summaryminor", also specify the field, channel and stokes plane.

        Inputs:
        key         The key to return. str
        field       The field to return. int
        chan        The channel to return. int
        stokes      The stokes plane to return. int

        Returns:
        The list of values for the specified key. list
        """

        #if key.lower() == 'peakres':
        #    print(f"field {field}, chan {chan}, stokes {stokes}, peakres {self._returndict['summaryminor'][field][chan][stokes][key]}")

        try:
            if key in self._summaryminor_keys:
                return self._returndict['summaryminor'][field][chan][stokes][key]
            else:
                return self._returndict[key]
        except KeyError:
            print(f'WARNING : Key {key} not found in return dictionary.')
            return []


    @staticmethod
    def get_summaryminor_stopdesc(stopcode:int=None) -> str:
        """
        Given the summaryminor stopcode, return the stop description.

        Inputs:
        stopcode        The stopcode to return the description for. int

        Returns:
        stopdesc        The stop description. str
        """

        stopdesc = {0:'Skipped this channel/polarization. Zero mask.',
                    1:'Reached cycleniter',
                    2:'Reached cyclethreshold',
                    3:'Zero iterations performed',
                    4:'Possible divergence. Peak residual increased by 10% from minimum',
                    5:'Exited deconvolver minor cycle without reaching any stopping criterion',
                    6:'Reached n-sigma threshold'}

        if stopcode is None:
            return stopdesc

        return stopdesc[stopcode]



    def merge(self, tclean_dict: dict, deconv_dict: dict, key_path=[]) -> None:
        """
        Merge the return dictionaries from tclean and deconvolve.

        Inputs:
        tclean_dict     The return dictionary from deconvolve. dict
        deconv_dict     The return dictionary from tclean. dict

        Returns:
        merge_dict
        """

        merge_dict = tclean_dict.copy()

        for key, val in deconv_dict.items():
            if key == 'summaryminor':
                # Copy summaryminor from deconvolve always
                merge_dict[key] = val
            # Copy all the iteration control keys from deconvolve
            elif key in ['iterdone', 'cycleiterdone', 'cycleniter', 'cyclethreshold',
                         'maxpsffraction', 'maxpsfsidelobe', 'minpsffraction', 'nsigma']:
                merge_dict[key] = val

        return merge_dict


    def concat(self, dict1:dict, dict2:dict) -> None:
        """
        Concatenate the two input dictionaries. The input dictionary must be a
        fully formed return dictionary from either `tclean` or `deconvolve`.

        The keys within summaryminor are always concatenated.
        The following keys are incremented :
            iterdone
            nmajordone

        The rest of the keys are left unchanged, and default to the values in dict2.

        Inputs:
        dict1     The initial dictionary, dict
        dict2     The input dictionary to append. dict

        Returns:
        appendix  The concatenated dictionary. dict
        """

        appendix = dict1.copy()

        # All unique keys
        dict_keys = list(dict1.keys()) + [key for key in dict2.keys() if key not in dict1.keys()]

        for key in dict_keys:
            if key not in dict1.keys() or key not in dict2.keys():
                print("Internal Error : KEY mismatch : ", key)

            if key in ['iterdone', 'nmajordone']:
                appendix[key] = dict1[key] + dict2[key]
            elif isinstance(dict1[key], dict) and isinstance(dict2[key], dict):
                appendix[key] = self.concat(dict1[key], dict2[key])
            elif isinstance(dict1[key], list) and isinstance(dict2[key], list):
                appendix[key] = dict1[key] + dict2[key]
            elif isinstance(dict1[key], np.ndarray) and isinstance(dict2[key], np.ndarray):
                # Using a list allows either key to be completely empty
                # numpy.concatenate breaks if one or both are length 0
                temparr = []
                temparr.extend(dict1[key])
                temparr.extend(dict2[key])
                appendix[key] = np.array(temparr)
            elif isinstance(dict1[key], (int, float, complex)) and isinstance(dict2[key], (int, float, complex)):
                appendix[key] = dict2[key]
            else:
                # Just use the key from dict1
                appendix[key] = dict2[key]

        return appendix



    def check_masksum(self, field:int=0, major_index:int=-1) -> int:
        """
        Checks if the masksum key in summaryminor is uniformly zero across all
        channels and Stokes planes.

        By default it checks the last major cycle.
        """

        masksum = 0
        for chan in range(self.nchan):
            for stokes in range(self.nstokes):
                masksum += self.get_key('masksum', field, chan, stokes)[major_index]

        return masksum


    def get_peakres(self, field:int=0, major_index:int=-1) -> float:
        """
        Calculates the peak residual across all channels and Stokes planes.

        By default it calculates the peak residual over the last major cycle.
        major_index directly indexes into the major cycle to query, so
        major_index=-2 will query the penultimate major cycle etc.

        Inputs:
        field               The field index over which to calculate the peak residual, int
        major_index         The major cycle index to query, int

        Returns:
        peakres             The peak residual, float
        """

        peakres = 0.0

        for chan in range(self.nchan):
            for stokes in range(self.nstokes):
                masksum = self.get_key('masksum', field, chan, stokes)[major_index]
                if masksum > 0:
                    peakres = max(peakres, self.get_key('peakRes', field, chan, stokes)[major_index])

        return peakres


    def has_converged(self, niterleft=0, threshold=0, nmajorleft=0, masksum=None, peakres=None):
        """
        Check stopping criteria for convergence, based on the criteria specified here -
        https://casadocs.readthedocs.io/en/stable/notebooks/synthesis_imaging.html#Returned-Dictionary

        If peakres is provided, then prefer that over what is in the return
        dict. This is to account for the usage case where the user has modified
        the mask in between major cycles, and we need to update values of the
        peak residual in order to determine if we want to continue
        deconvolution.
        """

        # TODO : Implement StopCode 3, 8
        # Note : For InteractiveClean, stopcode 3 is handled by the GUI for now
        # Stopcode 8 requires some work to figure out what nsigmathreshold is
        # and how it is calculated, so leaving that out for the moment.
        # NSigma is not exposed in the GUI as of 2023-12-15.

        stopcode = 0
        stopDescription = ''

        nmajordone = self.get_key('nmajordone')
#        if nmajordone >= 2:
#            # Peak residual over last two major cycles
#            peakres1 = self.get_peakres(major_index=-1)
#            peakres2 = self.get_peakres(major_index=-2)
#        else:
#            peakres1 = 0
#            peakres2 = 0
#
#        peakres_list = np.asarray([self.get_peakres(major_index=-1*(ii+1)) for ii in range(nmajordone)])
#        #min_peakres = np.amin(peakres_list[peakres_list != 0])
#        min_peakres = np.amin(peakres_list)
#        if min_peakres==0:
#            print("peakres = 0 ! ")

        if peakres != None:
            _peakres = peakres
        else:
            _peakres = self.get_peakres()

        if masksum !=None:
            use_masksum = masksum      ## If the mask has been zero'd out and iterations have been skipped (i.e. no summaryminor).
        else:
            use_masksum = self.check_masksum()    ## If iterations have happened, latest info will be in the summaryminor.

        if use_masksum == 0:
            stopcode = 7
            stopDescription = 'Zero mask'
        elif niterleft<=0:
            stopcode = 1
            stopDescription = 'Reached the iteration limit'
        elif _peakres <= threshold:
            stopcode = 2
            stopDescription = 'Reached global stopping threshold (within mask)'
        elif (nmajorleft != -1 and nmajorleft==0):
            stopcode = 9
            stopDescription = 'Reached the major cycle limit (nmajor)'
        # Stopcode 3 : Force Stop is handled by InteractiveClean GUI for now
        # TODO : If this is used to run iteration control for non-interactive clean, implement this
#        elif nmajordone > 2 and np.allclose(peakres1, peakres2):
#            stopcode = 4
#            stopDescription = 'No change in peak residual across consecutive major cycles'
#        elif peakres1 > 3*peakres2 and peakres2 != 0:
#            stopcode = 5
#            stopDescription = 'Peak residual increased by more than 3x across consecutive major cycles'
#        elif peakres1 > 3*min_peakres:
#            stopcode = 6
#            stopDescription = 'Peak residual increased by more than 3x from the minimum reached'

        return  stopcode, stopDescription




    def image_dimensions(self):
        """
        Given the input image, uses the ia tool to query for the number of Stokes
        planes and frequency channels.

        Inputs:
        None

        Returns:
        nstokes         Number of Stokes planes in the image
        nfreq           Number of frequency channels in the image
        """
        ia = image()

        # At this point we've already checked residname exists
        ia.open(self.residname)
        csys = ia.coordsys()

        shape = ia.shape()

        #  Figure out which axis is which
        stokes_axis = csys.findaxisbyname('Stokes')
        freq_axis = csys.findaxisbyname('Frequency')

        nstokes = shape[stokes_axis]
        nfreq = shape[freq_axis]

        ia.close()

        return nstokes, nfreq, stokes_axis, freq_axis


    def fill_summary_minor(self, channo, stokes, stokes_axis, freq_axis, fullsummary):
        """
        Given the input image name, and the corresponding field, channel number, and
        Stokes plane, extract the relevant information from the image to generate a
        summaryminor dict as defined
        https://casadocs.readthedocs.io/en/stable/notebooks/synthesis_imaging.html#Minor-Cycle-Summary-Dictionary

        Inputs:
        channo          Channel number to query in the image, int
        stokes          Stokes plane to query in the image, int
        stokes_axis     The axis to index for Stokes, int
        freq_axis       The axis to index for frequency, int
        fullsummary     Construct a full summary, or only a subset, bool

        Returns:
        summaryparams     Dict containing the necessary (key:value) pairs
        """

        ia = image()

        if not os.path.exists(self.residname):
            raise FileNotFoundError(f'Residual image {self.residname} does not exist.')

        ia.open(self.residname)
        shape = ia.shape()

        if stokes_axis == 2 and freq_axis == 3:
            blc = [0, 0, stokes, channo]
            trc = [shape[0], shape[1], stokes, channo]
        elif stokes_axis == 3 and freq_axis == 2:
            blc = [0, 0, channo, stokes]
            trc = [shape[0], shape[1], channo, stokes]

        data = ia.getchunk(blc, trc, dropdeg=True)
        ia.close()

        # Get the mask if it exists
        if len(self.maskname) > 0 and os.path.exists(self.maskname):
            ia.open(self.maskname)
            mask = ia.getchunk(blc, trc, dropdeg=True)
            ia.close()
        else:
            mask = [] # No mask, so everything is unmasked

        # If model image exists, calc model flux, else set to 0
        model_sum = 0
        if os.path.exists(self.modelname):
            ia.open(self.modelname)
            model_data = ia.getchunk(blc, trc, dropdeg=True)
            model_sum = np.sum(model_data)
            ia.close()

        if len(mask) == 0:
            peak_resid = np.amax(data)
        else:
            peak_resid = np.amax(data*mask)

        if fullsummary:
            peak_resid_NM = np.amax(data)
            mask_sum = np.sum(mask)

        summaryparams = dict()
        # This entire function is only invoked in the special case of niter=0
        summaryparams['iterDone'] = [0.0,]
        summaryparams['peakRes'] = [peak_resid,]
        # model flux has to be zero because no iterations were performed
        summaryparams['modelFlux'] = [model_sum,]
        # No threshold because no deconvolution done
        summaryparams['cycleThresh'] = [0.0,]

        if fullsummary:
            summaryparams['cycleStartIters'] = [0.0,]
            summaryparams['startIterDone'] = [0.0,]
            summaryparams['startPeakRes'] = [peak_resid,]
            summaryparams['startModelFlux'] = [model_sum,]
            summaryparams['startPeakResNM'] = [peak_resid_NM,]
            summaryparams['peakResNM'] = [peak_resid_NM,]
            summaryparams['masksum'] = [mask_sum,]
            summaryparams['mpiServer'] = [0.0,]
            summaryparams['stopCode'] = [3,]


        return summaryparams


    def _validate_mask(self):
        """
        Check if maskname is a valid iamge, and if not, set it to an empty string.
        """

        if os.path.exists(self.maskname) and os.path.isdir(self.maskname):
            try:
                ia.open(self.maskname)
                ia.close()
            except RuntimeError:
                self.maskname = ''
        else:
            self.maskname = ''


    def construct_summary_minor(self, paramList):
        """
        Constructs and populates a nested dictionary containing the summaryMinor()
        information required by tclean.

        This is a duplicate of the existing summaryMinor() class in C++, but is
        being re-written here to avoid issues with modifying iterControl.

        Inputs:
        paramList        Object that contains all imaging parameters

        Returns:
        None
        """

        impars = paramList.allimpars
        decpars = paramList.alldecpars

        # Each field is stored as a different key in impars
        nfields = len(impars.keys())

        for ff in range(nfields):
            self.residname=impars[str(ff)]['imagename']+'.residual.tt0' if(os.path.exists(impars[str(ff)]['imagename']+'.residual.tt0')) else impars[str(ff)]['imagename']+'.residual'
            self.modelname=impars[str(ff)]['imagename']+'.model.tt0' if(os.path.exists(impars[str(ff)]['imagename']+'.model.tt0')) else impars[str(ff)]['imagename']+'.model'
            if(os.path.exists(impars[str(ff)]['imagename']+'.mask')):
                 self.maskname=impars[str(ff)]['imagename']+'.mask'

            if len(decpars[str(ff)]['mask']) > 0 and os.path.exists(decpars[str(ff)]['mask']):
                self.maskname = decpars[str(ff)]['mask']
            elif os.path.exists(impars[str(ff)]['imagename']+'.mask') and os.path.isdir(impars[str(ff)]['imagename']+'.mask'):
                self.maskname = impars[str(ff)]['imagename']+'.mask'
            else:
                self.maskname = ''

            # Check that the derived mask name corresponds to a real mask on disk
            # Note : This only affects the tclean(niter=0) functionality
            self._validate_mask()

            fullsummary = decpars[str(ff)]['fullsummary']
            nstokes, nfreq, stokes_axis, freq_axis = self.image_dimensions()

            if ff not in self._returndict['summaryminor']:
                self._returndict['summaryminor'][ff] = dict()

            for cc in range(nfreq):
                if cc not in self._returndict['summaryminor'][ff]:
                    self._returndict['summaryminor'][ff][cc] = dict()

                for ss in range(nstokes):
                    if ss not in self._returndict['summaryminor'][ff][cc]:
                        self._returndict['summaryminor'][ff][cc][ss] = dict()

                    self._returndict['summaryminor'][ff][cc][ss] = self.fill_summary_minor(cc, ss, stokes_axis, freq_axis, fullsummary)


    def construct_residual_dict(self, paramList):
        """
        Construct the residual dictionary given the input image name and associated parameters. This residual dictionary is meant to
        duplicate that generated by imager.getSummary(fullsummary) for the special
        case of niter = 0 to avoid initializing the deconvolver.

        Inputs:
        paramList   The tclean inputs, defaults where not specified. dict

        Returns:
        returndict  The return dictionary with imaging statistics. dict
        """

        imagename = paramList.allimpars['0']['imagename']

        self.residname = imagename+'.residual.tt0' if(os.path.exists(imagename +'.residual.tt0')) else imagename +'.residual'
        do_summary_minor = True
        # Only fill summaryminor if the residual image exists
        if not os.path.exists(self.residname):
            do_summary_minor = False
            #raise FileNotFoundError(f'{residname} does not exist on disk. Cannot construct tclean return dictionary.')

        # Initialize the values that don't need to inspect any images
        self._returndict['cleanstate'] = 'running'
        self._returndict['cyclefactor'] = paramList.getAllPars()['cyclefactor']
        self._returndict['cycleiterdone'] = 0
        self._returndict['cycleniter'] = 0
        self._returndict['cyclethreshold'] = 0
        self._returndict['interactiveiterdone'] = 0
        self._returndict['interactivemode'] = paramList.alldecpars['0']['interactive']
        self._returndict['interactiveniter'] = 0
        self._returndict['interactivethreshold'] = 0

        self._returndict['iterdone'] = 0
        self._returndict['loopgain'] = 0
        self._returndict['maxpsffraction'] = 0
        self._returndict['maxpsfsidelobe'] = 0
        self._returndict['minpsffraction'] = 0

        self._returndict['niter'] = 0
        self._returndict['nmajordone'] = 1
        self._returndict['nsigma'] = 0.0
        # stopcode 3 --> Zero iterations performed
        self._returndict['stopcode'] = 3

        self._returndict['summarymajor'] = np.array([0,])

        if do_summary_minor:
            self.construct_summary_minor(paramList)

        self._returndict['threshold'] = paramList.getAllPars()['threshold']
        self._returndict['stopDescription'] = 'Zero iterations performed'


        return self._returndict
