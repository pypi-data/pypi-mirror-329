"""
Functions for formatting a response from a database query

Response formatters accept one required parameters and two optional parameters:
    result_set: list[dict] The result set from the query, generated by calling cursor.fetchall()
    pg_config: Optional[PostgresConfig] The configuration for the database connection.
                This is used to fetch the column types for the tables in the result set.
                In the future consider prefetching the database schema and passing it instead of
                a database configuration object.
    command: Optional[SQLCommand] The command that generated the result set
"""

from collections import namedtuple
from typing import List, Dict
from sqlark.column_definition import ColumnDefinition
from sqlark.utilities import (
    decompose_row,
    build_dataclasses,
)


# Disable unused-argument warning for pg_config and command. These arguments exist for consistency
# pylint: disable=unused-argument
def default_response_formatter(
    result_set: list[dict], pg_config=None, command=None
) -> list[dict]:
    """
    Returns the result set as a list of dictionaries
    """
    return [dict(r) for r in result_set]


# Disable unused-argument warning for pg_config and command. These arguments exist for consistency
# pylint: disable=unused-argument
def decompose_dict_response_formatter(
    result_set: list[Dict], pg_config=None, command=None
) -> list[Dict]:
    """
    Returns the result set as a list of Dictionaries.
    Each item in the list is a dictionary where the key is the table name
    and the value is a dictionary of column values for that table
    i.e. {"posts": {"id": 1, "title": "Post 1"}, "comments": {"id": 1, "post_id": 1, "comment": "Comment 1"}}
    """
    return [decompose_row(r) for r in result_set]


def object_response_formatter(
    result_set: list[dict], pg_config=None, command=None
) -> list[object]:
    """
    Returns the result set as a list of objects
    If the result set contains only one table, the objects will be of that type
    If the result set contains multiple tables, each row will map to an aggregate obejct
    with one attribute per table in the result set
    """
    if command is None:
        raise ValueError("Command is required for object_response_formatter")

    if pg_config is None:
        raise ValueError("pg_config is required for object_response_formatter")

    # Construct the dataclasses for each table in the result set
    table_classes = build_dataclasses(command.get_column_definitions(pg_config))
    decomposed = [decompose_row(r) for r in result_set]

    if len(table_classes) == 1:
        # If the result set only contains one table, return a list of objects of that type
        table, datacls = table_classes.popitem()
        return [datacls(**(row[table] if table in row else row)) for row in decomposed]

    # Construct a Row object with one attribute per table in result set
    Row = namedtuple("Row", table_classes.keys())  # type: ignore

    # Looks complex, but it's just a list comprehension that creates a namedtuple for each row
    return [
        Row(**{tab: table_classes[tab](**values) for tab, values in row.items()})
        for row in decomposed
    ]


class RelationFormatter:
    """
    Formats a result set as a hierarchical set of objects based on the relations defined in this formatter
    """

    def __init__(self):
        self._relations = {}
        self._table_classes = {}

    def set_relation(
        self, attribute_name: str, foreign_table: str, relationship_type: str = "many"
    ) -> "RelationFormatter":
        """
        Define a relation between two tables
        When formatting results, a new attribute will be added to an object based on the attribute_name
        The value of the attributed will be an object of the foreign_table

        The attribute name is specified as "tablename.attribute" where tablename is the name of the table
        that the attribute belongs to

        The relationship_type is the type of relationship between the tables, either "one" or "many",
        default is "many"
        """
        if "." not in attribute_name:
            raise ValueError(
                "Attribute name must be in the format 'tablename.attribute'"
            )

        self._relations[tuple(attribute_name.split("."))] = (
            foreign_table,
            relationship_type,
        )
        return self

    def extended_column_defs(
        self, command, pg_config
    ) -> Dict[str, List[ColumnDefinition]]:
        """
        Return the column definitions for the command with the extended fields added for the relationships
        """
        # A dictionary of table names mapped to a list of column definitions
        column_defs: Dict[str, List[ColumnDefinition]] = command.get_column_definitions(
            pg_config
        )

        for (attribute_table, attribute_name), (
            foreign_table,
            relationship_type,
        ) in self._relations.items():
            column_defs[attribute_table].append(
                ColumnDefinition(
                    table_name=attribute_table,
                    name=attribute_name,
                    data_type=foreign_table,
                    is_nullable=True,
                    default=None,
                    is_list=relationship_type == "many",
                )
            )

        return column_defs

    # pylint: disable=too-many-locals,too-many-branches,too-many-nested-blocks
    def format(
        self, result_set: list[dict], pg_config=None, command=None
    ) -> list[object]:
        """
        Format the result set as a hierarchical set of objects using the relation definitions
        The primary table is the root of the hierarchy for each row.
        """
        # Decompose the result set into a list of dictionaries
        # Each dictionary represents a row in the result set
        # and is keyed by table name, with values as dictionaries of column values
        # i.e. {"posts": {"id": 1, "title": "Post 1"}, "comments": {"id": 1, "post_id": 1, "comment": "Comment 1"}}
        decomposed_rows = decompose_dict_response_formatter(
            result_set, pg_config, command
        )

        # Construct the dataclasses for the response
        self._table_classes = build_dataclasses(
            self.extended_column_defs(command, pg_config)
        )

        obj_cache: List[
            object
        ] = []  # a cache of objects that have already been created
        response: List[object] = []
        for row in decomposed_rows:
            for table, values in row.items():
                # Construct the row object for the current table
                row_obj = self._table_classes[table](**values)

                # If the table is the primary table, add the object to the response
                # otherwise, cache the object for use in relationships
                if table == command.table_name:
                    response_obj = next((r for r in response if r == row_obj), None)
                    if response_obj is None:
                        # If the root object is not already in the response, add it
                        response.append(row_obj)
                    else:
                        row_obj = response_obj
                else:
                    cached_obj = next((o for o in obj_cache if o == row_obj), None)
                    if cached_obj is None:
                        obj_cache.append(row_obj)
                    else:
                        row_obj = cached_obj

                # Add the foreign objects to the current row object
                for (attribute_table, attribute_name), (
                    foreign_table,
                    relationship_type,
                ) in self._relations.items():
                    # Skip if the attribute does not apply to the current table
                    if attribute_table != table:
                        continue

                    # Construct the object for the foreign table
                    foreign_obj = self._table_classes[foreign_table](
                        **row[foreign_table]
                    )
                    if foreign_obj in obj_cache:
                        foreign_obj = next((o for o in obj_cache if o == foreign_obj))
                    else:
                        obj_cache.append(foreign_obj)

                    # If all attributes of the foreign_obj are None, set the foreign_obj to none
                    if all(v is None for v in row[foreign_table].values()):
                        foreign_obj = None

                    if hasattr(row_obj, attribute_name):
                        # If the attribute already exists, convert it to a list and
                        # append the foreign object to the attribute
                        if relationship_type == "many":
                            if foreign_obj:
                                getattr(row_obj, attribute_name).append(foreign_obj)
                        else:
                            setattr(row_obj, attribute_name, foreign_obj)
                    else:
                        # If the attribute does not exist, create it and set the foreign object as the value
                        if relationship_type == "many":
                            setattr(
                                row_obj,
                                attribute_name,
                                [foreign_obj] if foreign_obj else [],
                            )
                        else:
                            setattr(row_obj, attribute_name, foreign_obj)
        return response
